/** Copyright [2011] [The Odysseus Team]
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
package de.uniol.inf.is.odysseus.nexmark.generator;

/**
 * Ein einfacher "Kalender" der zur Zeitbestimmung dient. Mit ihm werden
 * Zeitpunkte beginnend bei 0 erzeugt.
 * 
 * @author Bernd Hochschulz
 * 
 */
public class SimpleCalendar {
	private long startTime;

	/**
	 * Erzeugt einene neuen {@link SimpleCalendar}.
	 */
	public SimpleCalendar() {
		startTime = System.currentTimeMillis();
	}

	/**
	 * Die Zeit wird wieder auf "0" gesetzt. 
	 */
	public void reset() {
		startTime = System.currentTimeMillis();
	}

	/**
	 * @return Die Zeit die seit dem Start oder Reset dieses {@link SimpleCalendar} vergangen sind.
	 */
	public long getTimeInMS() {
		return System.currentTimeMillis() - startTime;
	}
}

// package de.uniol.inf.is.odysseus.evaluation.benchmark.nexmark.generator;
//
// /*
// NEXMark Generator -- Niagara Extension to XMark Data Generator
//
// Acknowledgements:
// The NEXMark Generator was developed using the xmlgen generator
// from the XMark Benchmark project as a basis. The NEXMark
// generator generates streams of auction elements (bids, items
// for auctions, persons) as opposed to the auction files
// generated by xmlgen. xmlgen was developed by Florian Waas.
// See http://www.xml-benchmark.org for information.
//
// Copyright (c) Dept. of Computer Science & Engineering,
// OGI School of Science & Engineering, OHSU. All Rights Reserved.
//
// Permission to use, copy, modify, and distribute this software and
// its documentation is hereby granted, provided that both the
// copyright notice and this permission notice appear in all copies
// of the software, derivative works or modified versions, and any
// portions thereof, and that both notices appear in supporting
// documentation.
//
// THE AUTHORS AND THE DEPT. OF COMPUTER SCIENCE & ENGINEERING
// AT OHSU ALLOW USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION,
// AND THEY DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
// WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
//
// This software was developed with support from NSF ITR award
// IIS0086002 and from DARPA through NAVY/SPAWAR
// Contract No. N66001-99-1-8098.
//
// */
//
// import java.util.*;
//
// class SimpleCalendar {
//    
// private int minIncrementMS; // minimaler Zeitraum fuer das Inkrementieren
// private int maxIncrementMS; // maximaler Zeitraum fuer das Inkrementieren
// private long time_ms = 0; // Zeit in Millisekunden
// private Random rnd; // Zufallszahlen-Generator
//    
//    
// /**
// * Konstruktor
// * @param rnd Zu verwendendes Random-Objekt
// * @param minIncrementMS Minimaler Zeitraum fuer das Inkrementieren (!= 0)
// * @param maxIncrementMS Maximaler Zeitraum fuer das Inkrementieren (!= 0)
// */
// SimpleCalendar(Random rnd, int minIncrementMS, int maxIncrementMS) {
// this.rnd = rnd;
// // Ein Wert von 0 ist nicht erlaubt, da zwei Dokumente unterschiedliche
// // Zeitstempel haben muessen.
// if (minIncrementMS == 0) {
// this.maxIncrementMS = 1;
// } else {
// this.minIncrementMS = minIncrementMS;
// }
// if (maxIncrementMS == 0) {
// this.maxIncrementMS = 1;
// } else {
// this.maxIncrementMS = maxIncrementMS;
// }
// }
//
//    
// /**
// * Liefert die Zeit in Millisekunden.
// * @return
// */
// long getTimeInMS() {
// return time_ms;
// }
//    
//    
// /**
// * Inkrementiert die Zeit, wobei die im Konstruktor
// * uebergebenen Angaben beruecksichtigt werden.
// */
// void incrementTime() {
// int diff = maxIncrementMS - minIncrementMS;
// int incr = rnd.nextInt(diff+1) + minIncrementMS; // Erhoehung um untere
// Schranke
// //time_ms += incr;
// //assert time_ms >= 0 : "time overflowed";
// incrementTime(incr);
// }
//    
// void incrementTime(int incr) {
// time_ms += incr;
// assert time_ms >= 0 : "time overflowed";
// }
//
// }
