 /**
 * JavaCC file
 * @author Jonas Jacobi
 */options{  JDK_VERSION = "1.5";  IGNORE_CASE = true;}PARSER_BEGIN(PQLParserImpl)package de.uniol.inf.is.odysseus.parser.pql.impl;import java.beans.BeanInfo;import java.beans.IntrospectionException;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedList;import java.util.List;import java.util.Map;import java.util.Set;import de.uniol.inf.is.odysseus.datadictionary.DataDictionary;
import de.uniol.inf.is.odysseus.usermanagement.User;import de.uniol.inf.is.odysseus.logicaloperator.ILogicalOperator;import de.uniol.inf.is.odysseus.logicaloperator.LogicalSubscription;import de.uniol.inf.is.odysseus.planmanagement.query.IQuery;import de.uniol.inf.is.odysseus.planmanagement.query.Query;import de.uniol.inf.is.odysseus.logicaloperator.builder.IOperatorBuilder;import de.uniol.inf.is.odysseus.logicaloperator.builder.InputOperatorItem;import de.uniol.inf.is.odysseus.logicaloperator.builder.OperatorBuilderFactory;import de.uniol.inf.is.odysseus.logicaloperator.builder.PredicateItem;import de.uniol.inf.is.odysseus.logicaloperator.builder.ValidationException;import de.uniol.inf.is.odysseus.parser.pql.PQLParser;import de.uniol.inf.is.odysseus.sourcedescription.sdf.schema.SDFEntity;public class PQLParserImpl{  static private ILogicalOperator createOperator(String identifier, Map < String, Object > parameters, List < InputOperatorItem > inputOps)  {    IOperatorBuilder builder = OperatorBuilderFactory.createOperatorBuilder(identifier.toUpperCase(), getUser());    List < ILogicalOperator > inputOperators = new ArrayList < ILogicalOperator > ();    for (int i = 0; i < inputOps.size(); ++i)    {      builder.setInputOperator(i, inputOps.get(i).operator, inputOps.get(i).outputPort);    }    PQLParser.initParameters(builder.getParameters(), parameters);    if (!builder.validate())    {      throw new ValidationException(identifier, builder.getErrors());    }    ILogicalOperator operator = builder.createOperator();    return operator;  }  static private Set < ILogicalOperator > findRoots(ILogicalOperator op)  {        return findRoots(op, new ArrayList < ILogicalOperator > ());  }  static private Set < ILogicalOperator > findRoots(ILogicalOperator op, List < ILogicalOperator > visited)  {    Set < ILogicalOperator > result = new HashSet < ILogicalOperator > ();    if (!visited.contains(op))    {      visited.add(op);      Collection < LogicalSubscription > subscriptions = op.getSubscriptions();      if (subscriptions.isEmpty())      {        return Collections.singleton(op);      }      for (LogicalSubscription sub : subscriptions)      {        result.addAll(findRoots(sub.getTarget(), visited));      }    }    return result;  }

   static User user;
  
  static public User getUser(){	return user;
  }

  static public void setUser(User newUser)  {	user = newUser;
  }
    }PARSER_END(PQLParserImpl)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :{  < IDENTIFIER :    (< LETTER >)+    (      < DIGIT >    | < LETTER >    | < SPECIAL_CHARS >    )* >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #SPECIAL_CHARS :    "_"  | "." >| < CHAR_LITERAL :    "'" (~[ "'" ])* "'"    (      "'" (~[ "'" ])* "'"    )* >| < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >}TOKEN : /* Numeric Constants */{  < FLOAT :    ("-")?    (      < INTEGER > "." < INTEGER >    | "." < INTEGER >    ) >| < INTEGER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}List < IQuery > query() :{  Map < String, ILogicalOperator > namedOps = new HashMap < String, ILogicalOperator > ();  Map < String, Map < String, Object > > namedOpParameters = new HashMap < String, Map < String, Object > > ();  ILogicalOperator outputStream;}{  (    namedStream(namedOps, namedOpParameters)  )+  < EOF >  {    LinkedList < ILogicalOperator > result = new LinkedList < ILogicalOperator > ();    Set < ILogicalOperator > roots = new HashSet < ILogicalOperator > ();    for (ILogicalOperator op : namedOps.values())    {      roots.addAll(findRoots(op));    }    List < IQuery > queries = new ArrayList < IQuery > ();    BeanInfo beanInfo;    try    {      beanInfo = Introspector.getBeanInfo(IQuery.class);    }    catch (IntrospectionException e)    {      {        if (true) throw new RuntimeException(e);      }    }    PropertyDescriptor [ ] properties = beanInfo.getPropertyDescriptors();    for (Map.Entry < String, ILogicalOperator > opEntry : namedOps.entrySet())    {      String queryName = opEntry.getKey();      ILogicalOperator topOperator = opEntry.getValue();      if (roots.contains(topOperator))      {        IQuery query = new Query();        query.setLogicalPlan(topOperator);        queries.add(query);        PQLParser.initQueryParameters(namedOpParameters.get(queryName));        for (String parameterName : namedOpParameters.get(queryName).keySet())        {          boolean found = false;          for (PropertyDescriptor property : properties)          {            if (property.getName().equalsIgnoreCase(parameterName))            {              Method method = property.getWriteMethod();              try              {                method.invoke(query, PQLParser.getQueryParameter(parameterName).getValue());              }              catch (Exception e)              {                throw new RuntimeException(e);              }              found = true;            }          }          if (!found)          {            throw new RuntimeException("unknown parameter for query: " + parameterName);          }        }      }      else      {        if (!namedOpParameters.get(queryName).isEmpty())        {          {            if (true)            {              if (true) throw new IllegalArgumentException("query parameters can only be defined for root operators, not for: " + queryName);            }          }        }      }    }    return queries;  }}void namedStream(Map < String, ILogicalOperator > namedOps, Map < String, Map < String, Object > > namedOpParameters) :{  Token name;  ILogicalOperator op;  boolean isView = false;  Map < String, Object > parameters = new HashMap < String, Object > ();}{  name = < IDENTIFIER > [ "{" parameters = parameterMap() "}" ]  (    "="  | ":="    {      isView = true;    }  )  op = operator(namedOps)  {    String nameStr = name.image.toUpperCase();    if (namedOps.containsKey(nameStr))    {      throw new IllegalArgumentException("multiple definition of '" + nameStr + "'");    }    if (isView)    {      nameStr = name.image;      DataDictionary dd = DataDictionary.getInstance();      if (dd.containsView(nameStr, getUser()))      {        throw new IllegalArgumentException("multiple definition of view '" + nameStr + "'");      }      SDFEntity entity = new SDFEntity(nameStr);      entity.setAttributes(op.getOutputSchema());      DataDictionary.getInstance().addSourceType(nameStr, "RelationalStreaming");      DataDictionary.getInstance().addEntity(nameStr, entity, getUser());      dd.setView(nameStr, op, user);      //get access operator for view, so other operators don't get subscribed
      //to top operator of the view
      op = dd.getView(nameStr, getUser());    }    namedOpParameters.put(nameStr.toUpperCase(), parameters);    namedOps.put(nameStr.toUpperCase(), op);  }}ILogicalOperator operator(Map < String, ILogicalOperator > namedOps) :{  Token identifier;  Token port;  Map < String, Object > parameters = new HashMap < String, Object > ();  List < InputOperatorItem > inputOps = new ArrayList < InputOperatorItem > ();}{  (    LOOKAHEAD(< IDENTIFIER > "(")    identifier = < IDENTIFIER > "("    (      "{" parameters = parameterMap() "}" [ "," inputOps = operatorList(namedOps) ]    | inputOps = operatorList(namedOps)    )    ")"    {      return createOperator(identifier.image, parameters, inputOps);    }  | identifier = < IDENTIFIER >    {      ILogicalOperator op = namedOps.get(identifier.image.toUpperCase());      if (op == null)      {        throw new IllegalArgumentException("no such operator: " + identifier.image);      }      return op;    }  )}Map < String, Object > parameterMap() :{  Map < String, Object > parameters = new HashMap < String, Object > ();}{  parameter(parameters)  (    "," parameter(parameters)  )*  {    return parameters;  }}void parameter(Map < String, Object > parameters) :{  Token id;  Object value;}{  id = < IDENTIFIER > "=" value = parameterValue()  {    parameters.put(id.image.toUpperCase(), value);  }}Object parameterValue() :{  Token t;  Object value;}{  (    t = < FLOAT >    {      value = Double.valueOf(t.image);    }  | t = < INTEGER >    {      value = Long.valueOf(t.image);    }  | t = < CHAR_LITERAL >    {      value = t.image.substring(1, t.image.length() - 1);    }  | value = list()  | value = predicate()  )  {    return value;  }}List < Object > list() :{  Object value;  List < Object > list = new ArrayList < Object > ();}{  "["  [    value = parameterValue()    {      list.add(value);    }    (      "," value = parameterValue()      {        list.add(value);      }    )*  ]  "]"  {    return list;  }}List < InputOperatorItem > operatorList(Map < String, ILogicalOperator > namedOps) :{  List list = new LinkedList();  Token tPort = null;  ILogicalOperator operator;  int port = 0;}{  [    [ tPort = < INTEGER > ":" ] operator = operator(namedOps)    {      port = tPort == null ? 0 : Integer.parseInt(tPort.image);      list.add(new InputOperatorItem(operator, port));    }    (      "," [ tPort = < INTEGER > ":" ] operator = operator(namedOps)      {        port = tPort == null ? 0 : Integer.parseInt(tPort.image);        list.add(new InputOperatorItem(operator, port));      }    )*  ]  {    return list;  }}PredicateItem predicate() :{  Token predicateType;  Token predicate;}{  predicateType = < IDENTIFIER > "(" predicate = < CHAR_LITERAL > ")"  {    return new PredicateItem(predicateType.image, predicate.image.substring(1, predicate.image.length() - 1));  }}