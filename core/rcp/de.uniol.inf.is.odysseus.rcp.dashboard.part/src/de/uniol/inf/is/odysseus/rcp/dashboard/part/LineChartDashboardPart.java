/*******************************************************************************
 * Copyright 2012 The Odysseus Team
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package de.uniol.inf.is.odysseus.rcp.dashboard.part;

import java.awt.Color;
import java.util.List;
import java.util.Map;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.data.general.Dataset;

import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.collect.Maps;

import de.uniol.inf.is.odysseus.core.collection.Tuple;
import de.uniol.inf.is.odysseus.core.physicaloperator.IPhysicalOperator;
import de.uniol.inf.is.odysseus.core.physicaloperator.IPunctuation;
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFAttribute;
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema;

public class LineChartDashboardPart extends AbstractChartDashboardPart {

	private static final String TITLE_SETTING = "Title";
	private static final String X_AXIS_LABEL_SETTING = "X-Axis label";
	private static final String Y_AXIS_LABEL_SETTING = "Y-Axis label";
	private static final String X_AXIS_SETTING = "X-Axis";
	private static final String Y_AXIS_SETTING = "Y-Axis";
	private static final String ATTRIBUTE_SEPARATOR = ",";
	private static final String MAX_DATA_COUNT = "Value count";

	private String[] xAttributes;
	private String[] yAttributes;
	private final Map<String, Integer> accessDescriptors = Maps.newHashMap();

	@Override
	public void settingChanged(String settingName, Object oldValue, Object newValue) {
	}

	@Override
	protected void addPunctuationToChart(IPunctuation punctuation, int port) {

	}

	@Override
	protected void addStreamElementToChart(Tuple<?> element, int port) {
		final Object[] xAxisValues = determineValues(element, xAttributes);
		final Object[] yAxisValues = determineValues(element, yAttributes);

		for (int i = 0; i < xAxisValues.length; i++) {
			if (xAxisValues[i] != null && yAxisValues[i] != null) {
				addDataValue((Number) yAxisValues[i], yAttributes[i], (Comparable<?>) xAxisValues[i]);
			}
		}
	}

	@Override
	protected JFreeChart createChart() {
		return ChartFactory.createLineChart(getSettingValue(TITLE_SETTING, "Line Chart"), getSettingValue(X_AXIS_LABEL_SETTING, "X-Axis"), getSettingValue(Y_AXIS_LABEL_SETTING, "Y-Axis"),
				(DefaultCategoryDataset) getDataset(), PlotOrientation.VERTICAL, true, true, false);
	}

	@Override
	protected Dataset createDataset() {
		return new DefaultCategoryDataset();
	}

	@Override
	protected void decorateChart(JFreeChart chart) {
		chart.setBackgroundPaint(Color.white);

		final CategoryPlot plot = (CategoryPlot) chart.getPlot();
		plot.setBackgroundPaint(Color.WHITE);
	}

	@Override
	protected void startChart(List<IPhysicalOperator> physicalRoots) throws Exception {
		xAttributes = checkAndSplit((String) getSettingValue(X_AXIS_SETTING, null));
		yAttributes = checkAndSplit((String) getSettingValue(Y_AXIS_SETTING, null));

		checkAttributeLists();

		accessDescriptors.putAll(determineAttributeAccess(xAttributes, physicalRoots));
		accessDescriptors.putAll(determineAttributeAccess(yAttributes, physicalRoots));

		((DefaultCategoryDataset) getDataset()).clear();
	}

	private void addDataValue(final Number value, final Comparable<?> xAxis, final Comparable<?> yAxis) {
		final DefaultCategoryDataset dataset = (DefaultCategoryDataset) getDataset();
		dataset.addValue(value, xAxis, yAxis);
		if (dataset.getColumnCount() > getSettingValue(MAX_DATA_COUNT, 50)) {
			dataset.removeColumn(0);
		}
	}

	private void checkAttributeLists() throws Exception {
		if (xAttributes.length == 0) {
			throw new Exception("At least one attribute for x-axis must be specified!");
		}

		if (yAttributes.length == 0) {
			throw new Exception("At least one attribute for y-axis must be specified!");
		}

		if (xAttributes.length != yAttributes.length) {
			throw new Exception("Number of attributes for x- and y-axis must be equal!");
		}
	}

	private Object[] determineValues(Tuple<?> element, String[] attributes) {
		final Object[] results = new Number[attributes.length];

		for (int i = 0; i < attributes.length; i++) {
			results[i] = element.getAttribute(accessDescriptors.get(attributes[i]));
		}

		return results;
	}


	private static String[] checkAndSplit(String attributeList) {
		Preconditions.checkArgument(!Strings.isNullOrEmpty(attributeList), "AttributeList must not be null or empty!");

		final String[] attributes = attributeList.split(ATTRIBUTE_SEPARATOR);
		for (int i = 0; i < attributes.length; i++) {
			attributes[i] = attributes[i].trim();
		}

		return attributes;
	}

	private static Map<String, Integer> determineAttributeAccess(String[] attributes, List<IPhysicalOperator> operators) throws Exception {
		final Map<String, Integer> descriptors = Maps.newHashMap();

		for (final String attribute : attributes) {
			boolean found = false;
			for (final IPhysicalOperator operator : operators) {
				final SDFSchema schema = operator.getOutputSchema();

				final List<SDFAttribute> sdfAttrs = schema.getAttributes();
				for (int i = 0; i < sdfAttrs.size(); i++) {
					if (attribute.equals(sdfAttrs.get(i).getAttributeName())) {
						descriptors.put(attribute, i);
						found = true;
						break;
					}
				}
				if (found) {
					break;
				}
			}

			if (!found) {
				throw new Exception("Could not find attribute " + attribute + "!");
			}
		}

		return descriptors;
	}
}
