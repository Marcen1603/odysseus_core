grammar de.uniol.inf.is.odysseus.iql.basic.BasicIQL with org.eclipse.xtext.common.Terminals

generate basicIQL "http://www.uniol.de/inf/is/odysseus/iql/basic/BasicIQL"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvm

IQLModel:
	('namespace' name=QualifiedName ';')?
	namespaces+=IQLNamespace*
	(elements+=IQLModelElement)*
;

IQLModelElement:
	(javametadata+=IQLJavaMetadata)*
	inner=(IQLClass | IQLInterface)
; 


IQLNamespace :
	'use' (static?='static')? importedNamespace = QualifiedNameWithWildcard ';'
;

IQLClass returns jvm::JvmGenericType:
	{IQLClass}
	'class' simpleName=ID ('extends' extendedClass=JvmTypeReference)? ('implements' extendedInterfaces+=JvmTypeReference (',' extendedInterfaces+=JvmTypeReference)*)? '{'
		members += (IQLAttribute | IQLMethod | IQLJavaMember)*
	'}'	
;

IQLInterface returns jvm::JvmGenericType:
	{IQLInterface}
	'interface' simpleName=ID ('extends' extendedInterfaces+=JvmTypeReference (',' extendedInterfaces+=JvmTypeReference)?)? '{'
		members += (IQLMethodDeclaration | IQLJavaMember )*
	'}'	
;


IQLJavaMetadata:
	java=IQLJava
;

/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////

IQLAttribute returns jvm::JvmField:
	{IQLAttribute}		
	type=JvmTypeReference simpleName=ID (init=IQLVariableInitialization)? ';'
;

JvmTypeReference returns jvm::JvmTypeReference:
    IQLSimpleTypeRef | IQLArrayTypeRef
;

IQLSimpleTypeRef returns jvm::JvmTypeReference:
	{IQLSimpleTypeRef}
	type=[jvm::JvmType|QualifiedName]
;

IQLArrayTypeRef returns jvm::JvmTypeReference:
	{IQLArrayTypeRef}
	type=IQLArrayType
;

IQLArrayType returns jvm::JvmType:
	{IQLArrayType}
	componentType=[jvm::JvmType|QualifiedName] (dimensions+=ArrayBrackets)+
;

ArrayBrackets :
	'[' ']'
;

JvmFormalParameter returns jvm::JvmFormalParameter:
	parameterType=JvmTypeReference name=ID;


IQLMethod returns jvm::JvmOperation:
	{IQLMethod}		
	(override?='override')?
	simpleName=ID ('(' (parameters+=JvmFormalParameter (',' parameters+=JvmFormalParameter)*)? ')')? (':' returnType=JvmTypeReference)?
	body=IQLStatementBlock
;


IQLMethodDeclaration returns jvm::JvmOperation:
	{IQLMethodDeclaration}	
	simpleName=ID '(' (parameters+=JvmFormalParameter (',' parameters+=JvmFormalParameter)*)? ')' (':' returnType=JvmTypeReference)?';'
;

IQLJavaMember returns jvm::JvmMember:
	{IQLJavaMember}
	java=IQLJava
;

/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////

IQLMetadataList:
	elements +=IQLMetadata (',' elements+=IQLMetadata)*
;

IQLMetadata:
	name=ID ('=' value=IQLMetadataValue)?
;

IQLMetadataValue returns IQLMetadataValue:
	IQLMetadataValueSingle | IQLMetadataValueList | IQLMetadataValueMap
;

IQLMetadataValueSingle returns IQLMetadataValue:
	{IQLMetadataValueSingleInt} value = INT|
	{IQLMetadataValueSingleDouble} value = DOUBLE|
	{IQLMetadataValueSingleString} value = STRING|
	{IQLMetadataValueSingleBoolean} value = BOOLEAN|
	{IQLMetadataValueSingleTypeRef} value = JvmTypeReference |	
	{IQLMetadataValueSingleNull} 'null'	
;


IQLMetadataValueList returns IQLMetadataValue:
	{IQLMetadataValueList}
	'[' (elements+=IQLMetadataValue (',' elements+=IQLMetadataValue)*)? ']'
;

IQLMetadataValueMap returns IQLMetadataValue:
	{IQLMetadataValueMap}
	'{' (elements+=IQLMetadataValueMapElement (',' elements+=IQLMetadataValueMapElement)*)? '}'
;

IQLMetadataValueMapElement:
	key=(IQLMetadataValue) '=' value=IQLMetadataValue
;


/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////

IQLVariableDeclaration returns jvm::JvmIdentifiableElement:
	{IQLVariableDeclaration}
	ref=JvmTypeReference name=ID
;

IQLVariableInitialization:
	{IQLVariableInitialization}
	(argsList=IQLArgumentsList (argsMap=IQLArgumentsMap)?) |  (argsMap=IQLArgumentsMap) | ('=' value=IQLExpression)
;

IQLArgumentsList:
	{IQLArgumentsList}	
	'(' (elements+=IQLExpression (',' elements+=IQLExpression)*)? ')'	 
;


IQLArgumentsMap:
	{IQLArgumentsMap}	
	'{' (elements+=IQLArgumentsMapKeyValue (',' elements+=IQLArgumentsMapKeyValue)*)? '}'	
;

IQLArgumentsMapKeyValue :
	key=[jvm::JvmIdentifiableElement | QualifiedName] '=' value=IQLExpression
;

/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////


IQLStatement:	
	IQLStatementBlock |
	IQLExpressionStatement |
	IQLIfStatement |
	IQLWhileStatement |
	IQLDoWhileStatement |
	IQLForStatement |
	IQLForEachStatement	|
	IQLSwitchStatement |	
	IQLVariableStatement |
	IQLBreakStatement |
	IQLContinueStatement |
	IQLReturnStatement | 
	IQLConstructorCallStatement |
	IQLJavaStatement
;

IQLStatementBlock returns IQLStatement:
	{IQLStatementBlock}
	'{' statements += IQLStatement* '}'
;

IQLJavaStatement returns IQLStatement:
	{IQLJavaStatement}
	java=IQLJava
;

IQLIfStatement returns IQLStatement:
	{IQLIfStatement}
	'if' '(' predicate=IQLExpression ')'
	thenBody=IQLStatement
	(=>'else' elseBody=IQLStatement)?
;
	
IQLWhileStatement returns IQLStatement:
	{IQLWhileStatement}
	'while' '(' predicate=IQLExpression ')'
		body=IQLStatement
;
		
IQLDoWhileStatement returns IQLStatement:
	{IQLDoWhileStatement}
   'do'
       body=IQLStatement
   'while' '(' predicate=IQLExpression ')' ';'
;
   
IQLForStatement returns IQLStatement:
	{IQLForStatement}
	'for' '(' var=IQLVariableDeclaration '=' value=IQLExpression ';' predicate=IQLExpression ';' updateExpr=IQLExpression ')'
		body=IQLStatement
;
		
IQLForEachStatement returns IQLStatement:
	{IQLForEachStatement}
	'for' '(' var=IQLVariableDeclaration ':' forExpression=IQLExpression ')'
		body=IQLStatement
;

IQLSwitchStatement returns IQLStatement:
	{IQLSwitchStatement}
	'switch' '(' expr=IQLExpression ')' '{'
	(cases+=IQLCasePart)*
	('default' ':' statements += IQLStatement*)?
	'}';
	
IQLCasePart:
	{IQLCasePart}
	'case' expr=IQLLiteralExpression ':' statements += IQLStatement*
;
		
IQLExpressionStatement returns IQLStatement:
	{IQLExpressionStatement}
	expression=IQLExpression ';'
;	

IQLVariableStatement returns IQLStatement:
	{IQLVariableStatement}
	var=IQLVariableDeclaration init=IQLVariableInitialization ';'
;	

IQLConstructorCallStatement returns IQLStatement:
	{IQLConstructorCallStatement}
	(this?='this' | super?='super') args=IQLArgumentsList ';'
;

IQLBreakStatement returns IQLStatement:
	{IQLBreakStatement}
	'break' ';'
;

IQLContinueStatement returns IQLStatement:
	{IQLContinueStatement}
	'continue' ';'
;

IQLReturnStatement returns IQLStatement:
	{IQLReturnStatement}
	'return' (expression=IQLExpression)? ';'
;	


/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////

IQLExpression: 
	IQLAssignmentExpression
;

IQLAssignmentExpression returns IQLExpression:
	IQLLogicalOrExpression (
		=>({IQLAssignmentExpression.leftOperand=current} op=OpAssign) rightOperand=IQLAssignmentExpression
	)?
;

OpAssign:
	'=' | '+=' | '-=' | '*=' | '/=' | '%='
;	

IQLLogicalOrExpression returns IQLExpression:
	IQLLogicalAndExpression 
	(=>({IQLLogicalOrExpression.leftOperand=current} op=OpLogicalOr) rightOperand=IQLLogicalAndExpression)*
;

OpLogicalOr:
	'||';
	
IQLLogicalAndExpression returns IQLExpression:
	IQLEqualityExpression 
	(=>({IQLLogicalAndExpression.leftOperand=current} op=OpLogicalAnd) rightOperand=IQLEqualityExpression)*
;

OpLogicalAnd:
	'&&';

IQLEqualityExpression returns IQLExpression:
	IQLRelationalExpression
	(=>({IQLEqualityExpression.leftOperand=current} op=OpEquality) rightOperand=IQLRelationalExpression)*
;

OpEquality:
	'==' | '!=' 
;	

IQLRelationalExpression returns IQLExpression:
	IQLAdditiveExpression
	(=>({IQLInstanceOfExpression.leftOperand=current} 'instanceof') targetRef=JvmTypeReference |
	 =>({IQLRelationalExpression.leftOperand=current} op=OpRelational) rightOperand=IQLAdditiveExpression)*
;

OpRelational:
	'>' | '>=' | '<' | '<=' 
;

IQLAdditiveExpression returns IQLExpression:
	IQLMultiplicativeExpression
	(=>({IQLAdditiveExpression.leftOperand=current} op=OpAdd) rightOperand=IQLMultiplicativeExpression)*;

OpAdd:
	'+' | '-';

IQLMultiplicativeExpression returns IQLExpression:
	IQLUnaryExpression
	(=>({IQLMultiplicativeExpression.leftOperand=current} op=OpMulti) rightOperand=IQLUnaryExpression)*
;


OpMulti:
	'*' | '/' | '%'
;

IQLUnaryExpression returns IQLExpression:
	({IQLPlusMinusExpression} op=OpUnaryPlusMinus) operand=IQLMemberCallExpression |
	({IQLBooleanNotExpression} op=OpUnaryBooleanNot) operand=IQLMemberCallExpression |	
	({IQLPrefixExpression} op=OpPrefix) operand=IQLMemberCallExpression |
	=>({IQLTypeCastExpression} '(' targetRef=JvmTypeReference ')') operand=IQLMemberCallExpression |
	IQLMemberCallExpression (=>({IQLPostfixExpression.operand=current} op=OpPostfix))?
;

OpUnaryPlusMinus:
	"-" | "+";
	
OpUnaryBooleanNot:
	"!";	
	
OpPrefix:
	"++" | "--"
;	

OpPostfix:
	"++" | "--"
;	


IQLMemberCallExpression returns IQLExpression:
	IQLOtherExpressions	
	(=>({IQLArrayExpression.leftOperand=current} '[' expressions+=IQLExpression (',' expressions+=IQLExpression)* ']') |
		=>({IQLMemberSelectionExpression.leftOperand=current} '.') sel=IQLMemberSelection
	)*
;

IQLMemberSelection:
	member=[jvm::JvmMember] (args=IQLArgumentsList)?
;

IQLOtherExpressions returns IQLExpression:
    {IQLJvmElementCallExpression} element=[jvm::JvmIdentifiableElement | QualifiedName] (args=IQLArgumentsList)?  |
    {IQLThisExpression} 'this'  |
    {IQLSuperExpression} 'super'  |    
    {IQLParenthesisExpression} '(' expr = IQLExpression ')'  |
    {IQLNewExpression} 'new' ((ref=IQLArrayTypeRef) | (ref=IQLSimpleTypeRef ((argsList=IQLArgumentsList  (argsMap=IQLArgumentsMap)?) | argsMap=IQLArgumentsMap))) |
    IQLLiteralExpression
; 

IQLLiteralExpression returns IQLExpression:
	{IQLLiteralExpressionInt} value=INT |
	{IQLLiteralExpressionDouble} value=DOUBLE |
	{IQLLiteralExpressionString} value=STRING |
   	{IQLLiteralExpressionBoolean} value = BOOLEAN |
   	{IQLLiteralExpressionRange} value = RANGE |    
   	{IQLLiteralExpressionType} 'class('value = JvmTypeReference')' |   	
	{IQLLiteralExpressionNull} 'null' |
	(=>IQLLiteralExpressionList) |
	IQLLiteralExpressionMap
;

IQLLiteralExpressionList returns IQLExpression:
	{IQLLiteralExpressionList} 
	'[' (elements += IQLExpression (',' elements += IQLExpression)*)? ']'
;

IQLLiteralExpressionMap returns IQLExpression:
	{IQLLiteralExpressionMap} 
	'[' (elements += IQLLiteralExpressionMapKeyValue (',' elements += IQLLiteralExpressionMapKeyValue)*)? ']'
;

IQLLiteralExpressionMapKeyValue :
	key = IQLExpression ':' value = IQLExpression
;

/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////

QualifiedNameWithWildcard:
    QualifiedName '::*'?
;

QualifiedName:
	ID ('::' ID)*
;

terminal RANGE:
	INT'..'INT
;


IQLJava hidden(SL_COMMENT, ML_COMMENT):
    '$*' text = IQLJavaText '*$'
;

IQLJavaText:
	(IQL_JAVA_KEYWORDS | WS | ID | BOOLEAN | DOUBLE | STRING | INT | ANY_OTHER |
	'+'  | '+='  | '-'  | '-='  | '*'   | '*='   | '/' | '/=' | '%'  | '%=' |
	'++' | '--'	 | '>'  | '>='  | '<'   | '<='   | '!' | '!=' | '&&' | '||' |
	'==' | '='   | '~'  | '?:'  | '|'   | '|='   | '^' | '^=' | '&'  | '&=' |
	'>>' | '>>=' | '<<' | '<<=' | '>>>' | '>>>=' |
	'['  | ']'   |'{'   |'}'    |  '('  |')'     |
	 '.' | ':'   | ';'  | ','   | 'null')*
;

IQL_JAVA_KEYWORDS:
	'break'   | 'case'   | 'class' | 'continue'   | 'default'   | 'do'        | 'else' |
	'extends' | 'for'    | 'if'    | 'implements' | 'instanceof'| 'interface' | 'new'  |
    'package' | 'return' | 'super' | 'switch'     | 'this'      | 'while'     |
	
	'abstract'     | 'assert'  | 'catch'  | 'const'     |  'enum'     | 'final'      | 'finally'   |
	'goto'         | 'import'  | 'native' | 'private'   | 'protected' | 'public'     | 'static'    |
	'synchronized' | 'throw'   | 'throws' | 'transient' | 'try'       | 'volatile'   | 'strictfp'
;


BOOLEAN returns ecore::EBoolean:
	'true' | 'false'
;

@Override 
terminal INT returns ecore::EInt: 
	('0'..'9')+
;

terminal DOUBLE returns ecore::EDouble:
  ('0'..'9')* '.' ('0'..'9')+
 ;
  