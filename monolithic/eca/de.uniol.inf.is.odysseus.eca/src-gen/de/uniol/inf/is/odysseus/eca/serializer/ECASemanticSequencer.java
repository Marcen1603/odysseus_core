/*
 * generated by Xtext
 */
package de.uniol.inf.is.odysseus.eca.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import de.uniol.inf.is.odysseus.eca.eCA.ACTIONS;
import de.uniol.inf.is.odysseus.eca.eCA.COMMANDACTION;
import de.uniol.inf.is.odysseus.eca.eCA.CONDITIONS;
import de.uniol.inf.is.odysseus.eca.eCA.Constant;
import de.uniol.inf.is.odysseus.eca.eCA.DefinedEvent;
import de.uniol.inf.is.odysseus.eca.eCA.ECAPackage;
import de.uniol.inf.is.odysseus.eca.eCA.EcaValue;
import de.uniol.inf.is.odysseus.eca.eCA.Expression;
import de.uniol.inf.is.odysseus.eca.eCA.FREECONDITION;
import de.uniol.inf.is.odysseus.eca.eCA.MAPCONDITION;
import de.uniol.inf.is.odysseus.eca.eCA.Model;
import de.uniol.inf.is.odysseus.eca.eCA.QUERYCONDITION;
import de.uniol.inf.is.odysseus.eca.eCA.RNDQUERY;
import de.uniol.inf.is.odysseus.eca.eCA.Rule;
import de.uniol.inf.is.odysseus.eca.eCA.RuleSource;
import de.uniol.inf.is.odysseus.eca.eCA.SOURCECONDITION;
import de.uniol.inf.is.odysseus.eca.eCA.SUBCONDITION;
import de.uniol.inf.is.odysseus.eca.eCA.SYSTEMCONDITION;
import de.uniol.inf.is.odysseus.eca.eCA.Source;
import de.uniol.inf.is.odysseus.eca.eCA.Timer;
import de.uniol.inf.is.odysseus.eca.eCA.Window;
import de.uniol.inf.is.odysseus.eca.services.ECAGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ECASemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ECAGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ECAPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ECAPackage.ACTIONS:
				sequence_ACTIONS(context, (ACTIONS) semanticObject); 
				return; 
			case ECAPackage.COMMANDACTION:
				sequence_COMMANDACTION(context, (COMMANDACTION) semanticObject); 
				return; 
			case ECAPackage.CONDITIONS:
				sequence_CONDITIONS(context, (CONDITIONS) semanticObject); 
				return; 
			case ECAPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case ECAPackage.DEFINED_EVENT:
				sequence_DefinedEvent(context, (DefinedEvent) semanticObject); 
				return; 
			case ECAPackage.ECA_VALUE:
				sequence_EcaValue(context, (EcaValue) semanticObject); 
				return; 
			case ECAPackage.EXPRESSION:
				if(context == grammarAccess.getACTIONSRule() ||
				   context == grammarAccess.getACTIONSAccess().getACTIONSLeftAction_1_0() ||
				   context == grammarAccess.getSUBACTIONSRule()) {
					sequence_SUBACTIONS(context, (Expression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getCONDITIONSRule() ||
				   context == grammarAccess.getCONDITIONSAccess().getCONDITIONSLeftAction_1_0() ||
				   context == grammarAccess.getSUBCONDITIONRule()) {
					sequence_SUBCONDITION(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case ECAPackage.FREECONDITION:
				sequence_FREECONDITION(context, (FREECONDITION) semanticObject); 
				return; 
			case ECAPackage.MAPCONDITION:
				sequence_MAPCONDITION(context, (MAPCONDITION) semanticObject); 
				return; 
			case ECAPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ECAPackage.QUERYCONDITION:
				sequence_QUERYCONDITION(context, (QUERYCONDITION) semanticObject); 
				return; 
			case ECAPackage.RNDQUERY:
				sequence_RNDQUERY(context, (RNDQUERY) semanticObject); 
				return; 
			case ECAPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case ECAPackage.RULE_SOURCE:
				sequence_RuleSource(context, (RuleSource) semanticObject); 
				return; 
			case ECAPackage.SOURCECONDITION:
				sequence_SOURCECONDITION(context, (SOURCECONDITION) semanticObject); 
				return; 
			case ECAPackage.SUBCONDITION:
				sequence_SUBCONDITION(context, (SUBCONDITION) semanticObject); 
				return; 
			case ECAPackage.SYSTEMCONDITION:
				sequence_SYSTEMCONDITION(context, (SYSTEMCONDITION) semanticObject); 
				return; 
			case ECAPackage.SOURCE:
				sequence_Source(context, (Source) semanticObject); 
				return; 
			case ECAPackage.TIMER:
				sequence_Timer(context, (Timer) semanticObject); 
				return; 
			case ECAPackage.WINDOW:
				sequence_Window(context, (Window) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (left=ACTIONS_ACTIONS_1_0 right=SUBACTIONS)
	 */
	protected void sequence_ACTIONS(EObject context, ACTIONS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (subActname=ID (functAction=RNDQUERY | actionValue=EcaValue | innerAction+=COMMANDACTION*))
	 */
	protected void sequence_COMMANDACTION(EObject context, COMMANDACTION semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=CONDITIONS_CONDITIONS_1_0 right=SUBCONDITION)
	 */
	protected void sequence_CONDITIONS(EObject context, CONDITIONS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID constValue=INT)
	 */
	protected void sequence_Constant(EObject context, Constant semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.CONSTANT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.CONSTANT__NAME));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.CONSTANT__CONST_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.CONSTANT__CONST_VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConstantAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstantAccess().getConstValueINTTerminalRuleCall_3_0(), semanticObject.getConstValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID definedSource=Source definedAttribute=ID definedOperator=Operator definedValue=EcaValue)
	 */
	protected void sequence_DefinedEvent(EObject context, DefinedEvent semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.DEFINED_EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.DEFINED_EVENT__NAME));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.DEFINED_EVENT__DEFINED_SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.DEFINED_EVENT__DEFINED_SOURCE));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.DEFINED_EVENT__DEFINED_ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.DEFINED_EVENT__DEFINED_ATTRIBUTE));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.DEFINED_EVENT__DEFINED_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.DEFINED_EVENT__DEFINED_OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.DEFINED_EVENT__DEFINED_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.DEFINED_EVENT__DEFINED_VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDefinedEventAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDefinedEventAccess().getDefinedSourceSourceParserRuleCall_3_0(), semanticObject.getDefinedSource());
		feeder.accept(grammarAccess.getDefinedEventAccess().getDefinedAttributeIDTerminalRuleCall_5_0(), semanticObject.getDefinedAttribute());
		feeder.accept(grammarAccess.getDefinedEventAccess().getDefinedOperatorOperatorParserRuleCall_6_0(), semanticObject.getDefinedOperator());
		feeder.accept(grammarAccess.getDefinedEventAccess().getDefinedValueEcaValueParserRuleCall_7_0(), semanticObject.getDefinedValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (intValue=INT | idValue=ID | constValue=[Constant|ID] | stringValue=STRING | doubleValue=DOUBLE)
	 */
	protected void sequence_EcaValue(EObject context, EcaValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     freeCondition=STRING
	 */
	protected void sequence_FREECONDITION(EObject context, FREECONDITION semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.FREECONDITION__FREE_CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.FREECONDITION__FREE_CONDITION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFREECONDITIONAccess().getFreeConditionSTRINGTerminalRuleCall_0(), semanticObject.getFreeCondition());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     mapCond=STRING
	 */
	protected void sequence_MAPCONDITION(EObject context, MAPCONDITION semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.MAPCONDITION__MAP_COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.MAPCONDITION__MAP_COND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMAPCONDITIONAccess().getMapCondSTRINGTerminalRuleCall_1_0(), semanticObject.getMapCond());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (constants+=Constant* defEvents+=DefinedEvent* windowSize=Window? timeIntervall=Timer? rules+=Rule*)
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (queryNot='!'? queryFunct=RNDQUERY)
	 */
	protected void sequence_QUERYCONDITION(EObject context, QUERYCONDITION semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (priOperator=Operator priVal=INT (sel='MIN' | sel='MAX')? stateName=ID)
	 */
	protected void sequence_RNDQUERY(EObject context, RNDQUERY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (defSource=[DefinedEvent|ID] | newSource=Source | preSource=PREDEFINEDSOURCE)
	 */
	protected void sequence_RuleSource(EObject context, RuleSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID source=RuleSource ruleConditions=CONDITIONS ruleActions=ACTIONS)
	 */
	protected void sequence_Rule(EObject context, Rule semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.RULE__NAME));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.RULE__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.RULE__SOURCE));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.RULE__RULE_CONDITIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.RULE__RULE_CONDITIONS));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.RULE__RULE_ACTIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.RULE__RULE_ACTIONS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRuleAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRuleAccess().getSourceRuleSourceParserRuleCall_2_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getRuleAccess().getRuleConditionsCONDITIONSParserRuleCall_4_0(), semanticObject.getRuleConditions());
		feeder.accept(grammarAccess.getRuleAccess().getRuleActionsACTIONSParserRuleCall_6_0(), semanticObject.getRuleActions());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (condAttribute=ID operator=Operator value=EcaValue)
	 */
	protected void sequence_SOURCECONDITION(EObject context, SOURCECONDITION semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.SOURCECONDITION__COND_ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.SOURCECONDITION__COND_ATTRIBUTE));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.SOURCECONDITION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.SOURCECONDITION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.SOURCECONDITION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.SOURCECONDITION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSOURCECONDITIONAccess().getCondAttributeIDTerminalRuleCall_0_0(), semanticObject.getCondAttribute());
		feeder.accept(grammarAccess.getSOURCECONDITIONAccess().getOperatorOperatorParserRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getSOURCECONDITIONAccess().getValueEcaValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     comAction=COMMANDACTION
	 */
	protected void sequence_SUBACTIONS(EObject context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (subsource=SOURCECONDITION | subsys=SYSTEMCONDITION)
	 */
	protected void sequence_SUBCONDITION(EObject context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (subfree=FREECONDITION | (submap=MAPCONDITION?) | queryCond=QUERYCONDITION)
	 */
	protected void sequence_SUBCONDITION(EObject context, SUBCONDITION semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (systemAttribute=SYSTEMFUNCTION operator=Operator value=EcaValue)
	 */
	protected void sequence_SYSTEMCONDITION(EObject context, SYSTEMCONDITION semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.SYSTEMCONDITION__SYSTEM_ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.SYSTEMCONDITION__SYSTEM_ATTRIBUTE));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.SYSTEMCONDITION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.SYSTEMCONDITION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.SYSTEMCONDITION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.SYSTEMCONDITION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSYSTEMCONDITIONAccess().getSystemAttributeSYSTEMFUNCTIONParserRuleCall_1_0(), semanticObject.getSystemAttribute());
		feeder.accept(grammarAccess.getSYSTEMCONDITIONAccess().getOperatorOperatorParserRuleCall_2_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getSYSTEMCONDITIONAccess().getValueEcaValueParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Source(EObject context, Source semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.SOURCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.SOURCE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSourceAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     timerIntervallValue=INT
	 */
	protected void sequence_Timer(EObject context, Timer semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.TIMER__TIMER_INTERVALL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.TIMER__TIMER_INTERVALL_VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimerAccess().getTimerIntervallValueINTTerminalRuleCall_2_0(), semanticObject.getTimerIntervallValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     windowValue=INT
	 */
	protected void sequence_Window(EObject context, Window semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ECAPackage.Literals.WINDOW__WINDOW_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ECAPackage.Literals.WINDOW__WINDOW_VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWindowAccess().getWindowValueINTTerminalRuleCall_2_0(), semanticObject.getWindowValue());
		feeder.finish();
	}
}
