 /**
 * JavaCC file
 */options{  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(RelationalPredicateParser)package de.uniol.inf.is.odysseus.parser.pql.relational.predicateParser;import de.uniol.inf.is.odysseus.base.predicate.AndPredicate;import de.uniol.inf.is.odysseus.base.predicate.IPredicate;import de.uniol.inf.is.odysseus.base.predicate.NotPredicate;import de.uniol.inf.is.odysseus.base.predicate.OrPredicate;import de.uniol.inf.is.odysseus.relational.base.RelationalTuple;import de.uniol.inf.is.odysseus.relational.base.predicate.RelationalPredicate;import de.uniol.inf.is.odysseus.sourcedescription.sdf.schema.IAttributeResolver;import de.uniol.inf.is.odysseus.sourcedescription.sdf.schema.SDFExpression;public class RelationalPredicateParser{  private IAttributeResolver resolver;  public void setAttributeResolver(IAttributeResolver resolver)  {    this.resolver = resolver;  }}PARSER_END(RelationalPredicateParser)SKIP :{  " "| "\r"| "\n"| "\t"}TOKEN :{  < K_AND : "AND" >| < K_NOT : "NOT" >| < K_OR : "OR" >}TOKEN : /* Numeric Constants */{  < FLOAT :    ("-")?    (      < INTEGER > "." < INTEGER >    | "." < INTEGER >    ) >| < INTEGER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}TOKEN :{  < IDENTIFIER :    (< LETTER >)+    (      < DIGIT >    | < LETTER >    | < SPECIAL_CHARS >    )* >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #SPECIAL_CHARS :    ":"  | "_"  | "."  | "*" >| < CHAR_LITERAL : "\"" (~[ "\"" ])* "\"" >| < COMPARE_OPERATOR :    "="  | "<>"  | ">"  | "<"  | "<="  | ">=" >}IPredicate < RelationalTuple <? > > Predicate() :{  IPredicate < RelationalTuple <? > > predicate;}{  (    LOOKAHEAD(OrPredicate())    predicate = OrPredicate()  | LOOKAHEAD(AndPredicate())    predicate = AndPredicate()  | predicate = NotPredicate()  | predicate = SimplePredicate()  )  {    return predicate;  }}OrPredicate OrPredicate() :{  IPredicate < RelationalTuple <? > > first, second;}{  first = SimplePredicate() < K_OR > second = Predicate()  {    return new OrPredicate(first, second);  }}AndPredicate AndPredicate() :{  IPredicate < RelationalTuple <? > > first, second;}{  first = SimplePredicate() < K_AND > second = Predicate()  {    return new AndPredicate(first, second);  }}IPredicate < RelationalTuple <? > > NotPredicate() :{  IPredicate < RelationalTuple <? > > predicate;}{  < K_NOT > predicate = Predicate()  {    return new NotPredicate(predicate);  }}IPredicate < RelationalTuple <? > > SimplePredicate() :{  IPredicate < RelationalTuple <? > > predicate;}{  LOOKAHEAD("(" Predicate())  "(" predicate = Predicate() ")"  {    return predicate;  }| predicate = BasicPredicate()  {    return predicate;  }}IPredicate < RelationalTuple <? > > BasicPredicate() :{  IPredicate < RelationalTuple <? > > predicate;  String first, second, cOp;}{  first = Expression() cOp = CompareOperator() second = Expression()  {    SDFExpression exp = new SDFExpression("", first+ cOp+ second, resolver);    return new RelationalPredicate(exp);  }}String Expression() :{  String first;  String tOp;  String second;}{  LOOKAHEAD(SimpleToken() MathOperator())  first = SimpleToken() tOp = MathOperator() second = Expression()  {    return first+ tOp+ second;  }| first = SimpleToken()  {    return first;  }}String MathOperator() :{}{  "*"  {    return "*";  }| "+"  {    return "+";  }| "-"  {    return "-";  }| "/"  {    return "/";  }| "^"  {    return "^";  }}String SimpleToken() :{  String value;}{  value = Number()  {    return value;  }| value = String()  {    return value;  }| LOOKAHEAD(FunctionExpression())  value = FunctionExpression()  {    return value;  }| "(" value = Expression() ")"  {    return "("+ value+ ")";  }| "-" value = Identifier()  {    return "-"+ value;  }| value = Identifier()  {    return value;  }}String String() :{  Token t;}{  t = < CHAR_LITERAL >  {    return t.image;  }}String Number() :{  Token t;}{  (    t = < FLOAT >  | t = < INTEGER >  )  {    return t.image;  }}String FunctionExpression() :{  String tmp;  StringBuilder result = new StringBuilder();}{  tmp = Identifier()  {    result.append(tmp);    result.append('(');  }  "("  [    tmp = Expression()    {      result.append(tmp);    }    (      "," tmp = Expression()      {        result.append(",");        result.append(tmp);      }    )*  ]  ")"  {    result.append(')');    return result.toString();  }}String Identifier() :{  Token t;}{  t = < IDENTIFIER >  {    return t.image;  }}String CompareOperator() :{  Token t;}{  t = < COMPARE_OPERATOR >  {    if (t.image.equals("="))    {      return "==";    }    if (t.image.equals("<>"    )    )    {      return "!=";    }    return t.image;  }}
