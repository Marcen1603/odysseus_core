/**
* JJTree file
*/

options {
  JDK_VERSION = "1.5";
  IGNORE_CASE = true;
  MULTI = true;
  VISITOR = true;
  DEBUG_PARSER = true;
  DEBUG_TOKEN_MANAGER = false;
  //  NODE_DEFAULT_VOID=true;
  JJTREE_OUTPUT_DIRECTORY = "parser";
  NODE_PACKAGE = "de.uniol.inf.is.odysseus.pqlhack.parser";
  //LOOKAHEAD = 2;
  //FORCE_LA_CHECK = true;
}
 
PARSER_BEGIN(ProceduralExpressionParser) 
package de.uniol.inf.is.odysseus.pqlhack.parser;

public class ProceduralExpressionParser{} PARSER_END(ProceduralExpressionParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
/*| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">*/
}


TOKEN : /* Keywords */ {
	<K_ACCESS: "ACCESS">
|	<K_AS: "AS">
|	<K_AND: "AND">
|	<K_AVG: "AVG">
|   <K_BROKER: "BROKER">
|	<K_COUNT: "COUNT">
|	<K_DEFAULT: "DEFAULT">
|	<K_JOIN: "JOIN">
|	<K_LOGICAL: "LOGICAL">
|	<K_MAX: "MAX">
|	<K_MIN: "MIN">
|	<K_NOT: "NOT">
|	<K_OR: "OR">
|	<K_ON: "ON">
|	<K_PLAN: "PLAN">
|	<K_PROJECTION: "PROJECTION">
|   <K_QUEUE: "QUEUE">
|   <K_RELATIONAL_PROJECTION: "RPROJECTION">
|   <K_RELATIONAL_SELECTION: "RSELECTION">
|   <K_RELATIONAL_JOIN: "RJOIN">
|   <K_RELATIONAL_NEST: "RNEST">
|   <K_RELATIONAL_UNNEST: "RUNNEST">
|	<K_SELECTION: "SELECTION">
|	<K_SET_PREDICTION: "SET-PREDICTION">
|	<K_SIZE: "SIZE">
|	<K_SLIDE: "SLIDE">
|	<K_SLDING_TIME_WINDOW: "SLIDING-TIME-WINDOW">
|	<K_SUM: "SUM">
|	<K_TUMBLING_TIME_WINDOW: "TUMBLING-TIME-WINDOW">
|	<K_WHERE: "WHERE">
|   <K_TEST: "TESTOP">
}

TOKEN:{
  <IDENTIFIER:(<LETTER>)+(<DIGIT>
  | <LETTER>
  | <SPECIAL_CHARS>)*>
  | <#LETTER:["a"-"z", "A"-"Z"]>
  | <#SPECIAL_CHARS:":"
  | "_"
  | ".">
  | <CHAR_LITERAL:"'"(~["'"])*"'"("'"(~["'"])*"'")*>
  | <QUOTED_IDENTIFIER:"\""(~["\n", "\r", "\""])*"\"">
  | <COMPARE_OPERATOR:"="
  | "<>"
  | ">"
  | "<"
  | "<="
  | ">=">
  | <REGEXP: "/" ("^")?(<LETTER> | <DIGIT> | "\\" | "+" | "." | "*" | "?" | "$")+ "/" >
}

TOKEN:/* Numeric Constants */
{
  //  <NUMBER:<FLOAT>
//  | <FLOAT>(["e", "E"](["-", "+"])?<FLOAT>)?>
//  | <#FLOAT:<INTEGER>
//  | <INTEGER>("."<INTEGER>)?
//  | "."<INTEGER>>
<FLOAT:("-")?(<INTEGER>"."<INTEGER>
  | "."<INTEGER>)>
  | <INTEGER:(<DIGIT>)+>
  | <#DIGIT:["0"-"9"]>
 | <IPADDRESS:<DIGIT>(<DIGIT>)?(<DIGIT>)?"."<DIGIT>(<DIGIT>)?(<DIGIT>)?"."<DIGIT>(<DIGIT>)?(<DIGIT>)?"."<DIGIT>(<DIGIT>)?(<DIGIT>)?>
}

ASTLogicalPlan LogicalPlan():{}{
	<K_LOGICAL><K_PLAN>":"
	AlgebraOp() {return jjtThis;}
}

void AlgebraOp():{}{
	ProjectionOp() |
	SelectionOp() | RelationalSelectionOp() |
	JoinOp() | RelationalJoinOp() |
	RelationalNestOp() |
	RelationalUnnestOp() |
	WindowOp() |
	AccessOp() |
	BrokerOp() |
	PredictionOp() |
	TestOp()
}

void TestOp(): {}{
    <K_TEST>"(" AlgebraOp() ")"
}

void ProjectionOp(): {}{
	<K_PROJECTION>"(" AlgebraOp() ","  (Identifier()#ProjectionIdentifier)*")"
}

void RelationalProjectionOp(): {}{
	<K_RELATIONAL_PROJECTION>"(" AlgebraOp() ","  (Identifier()#ProjectionIdentifier)*")"
}

/*void TumblingWindow(): {}{
	<K_TUMBLING_TIME_WINDOW>"(" AlgebraOp() "," Number()#WindowSize "," Number()#WindowAdvance ")"
}*/

void SelectionOp(): {
	Token windowSize;
}{
    // window size is a hack for evaluation of range predicates
	<K_SELECTION>"(" AlgebraOp() "," Predicate() ("," windowSize = <INTEGER> {jjtThis.setWindowSize(windowSize.image);})? ")"
}

void RelationalSelectionOp():{
	Token windowSize;
}{
	<K_RELATIONAL_SELECTION>"(" AlgebraOp() "," Predicate() ")"
}

void RelationalJoinOp(): {
	Token windowSize;

}{
	// Here no join predicate will be set
	// this will be done by the restructuring component
	<K_JOIN>"(" AlgebraOp() "," AlgebraOp() "," Predicate()")"
}

void RelationalNestOp(): {
}{
	// NEST stream, a, b AS z, z is the attribute name of the nesting. 
	<K_RELATIONAL_NEST>"(" AlgebraOp() "," Identifier() "," (Identifier())* ")"
}

void RelationalUnnestOp(): {
}{
	// NEST stream, a, b AS z, z is the attribute name of the nesting. 
	<K_RELATIONAL_UNNEST>"(" AlgebraOp() "," Identifier() ")"
}

void JoinOp(): {
	Token windowSize;

}{
	// Here no join predicate will be set
	// this will be done by the restructuring component
	// window size is a hack for evaluation of window size
	<K_RELATIONAL_JOIN>"(" AlgebraOp() "," AlgebraOp() "," Predicate() ("," windowSize = <INTEGER> {jjtThis.setWindowSize(windowSize.image);})? ")"
}

void WindowOp():{}{
	// at the moment only sliding time windows are supported
	SlidingTimeWindow()
}

void SlidingTimeWindow(): {}{
	<K_SLDING_TIME_WINDOW>"(" AlgebraOp()"," Number()"," Number() [","Identifier()#TimestampAttribute]")"
}

void AccessOp(): {}{
	<K_ACCESS>"(" Identifier() [<K_AS> Identifier()] ")"
}

void BrokerOp(): {}{
	<K_BROKER>"(" Identifier() [LOOKAHEAD(2) "," <K_QUEUE>"(" AlgebraOp() ")" {jjtThis.setQueue(true);}] ("," AlgebraOp() {jjtThis.increaseNoOfChildOps();})* ")"
}

void PredictionOp() : {}{
	<K_SET_PREDICTION>"(" AlgebraOp() "," (PredictionDefinition())+ [<K_DEFAULT> DefaultPredictionDefinition()] ")"
}

void Predicate():{}{
  LOOKAHEAD(OrPredicate())OrPredicate()
  | LOOKAHEAD(AndPredicate())AndPredicate()
  | NotPredicate()
  | SimplePredicate()
}
void SimplePredicate():{}{
  LOOKAHEAD("("Predicate())"("Predicate()")"
  | LOOKAHEAD(BasicPredicate()) BasicPredicate()
  /*| LOOKAHEAD(SpatialPredicate()) SpatialPredicate()
  | ProbabilityPredicate()*/
}

void BasicPredicate():{}{
	Expression()CompareOperator()Expression()
}

void OrPredicate():{}{
  SimplePredicate()<K_OR>Predicate()
}
void AndPredicate():{}{
  SimplePredicate()<K_AND>Predicate()
}
void NotPredicate():{}{
  <K_NOT>Predicate()
}

void Expression():{
  String tOp;
}
{
  LOOKAHEAD(SimpleToken()MathOperator())SimpleToken()tOp = MathOperator(){
    jjtThis.setOperator(tOp);
  }
  Expression()
  | SimpleToken()
}

void SimpleToken():{}{
  Number()
  | String()
  /*| LOOKAHEAD(AggregateExpression())AggregateExpression()*/
  | LOOKAHEAD(FunctionExpression())FunctionExpression()
  | "("Expression()")"
  | Identifier()
//TODO DISTINCE Expression
}

void FunctionExpression():{}{
  Identifier()#FunctionName "("Expression()")"
}
/*void AggregateExpression():{}{
  AggregateFunction()"("Identifier()")"
}*/
/*void AggregateFunction():{
  Token t;
}
{
  (t = <K_AVG>
  | t = <K_COUNT>
  | t = <K_MAX>
  | t = <K_MIN>
  | t = <K_SUM>){
    jjtThis.setFunction(AggregateFunction.valueOf(AggregateFunction.class , t.image.toUpperCase()));
  }
}*/

void Number():{
  Token t;
}
{
  (t = <FLOAT>
  | t = <INTEGER>){
    jjtThis.setValue(t.image);
  }
}

void String():{
  Token t;
}
{
  t = <CHAR_LITERAL>{
    jjtThis.setValue(t.image);
  }
}

String MathOperator()#void :{}{
  "*"{
    return "*";
  }
  | "+"{
    return "+";
  }
  | "-"{
    return "-";
  }
  | "/"{
    return "/";
  }
  | "^"{
    return "^";
  }
}

void Identifier():{
  Token sign = null;
  Token t;
}
{
 (sign = "-")?
  t = <IDENTIFIER>{
    jjtThis.setName((sign != null && sign.image != null ? sign.image : "") + t.image);
  }
}

void CompareOperator():{
  Token t;
}
{
  t = <COMPARE_OPERATOR> {
    jjtThis.setOperator(t.image);
  }
}

void PredictionDefinition(): {} {
	(PredictionFunctionDefinition())+ <K_WHERE> Predicate() ";"
}

void DefaultPredictionDefinition(): {}{
	(PredictionFunctionDefinition())+";"
}

void PredictionFunctionDefinition(): {}{
	Identifier() ":=" Expression()";"	
}