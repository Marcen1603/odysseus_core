 /**
 * JavaCC file
 */options{  JDK_VERSION = "1.5";  STATIC = true;  IGNORE_CASE = true;}PARSER_BEGIN(PQLParserImpl)package de.uniol.inf.is.odysseus.parser.pql.impl;import java.io.Reader;import java.util.List;import java.util.LinkedList;import java.util.Map;import java.util.HashMap;import de.uniol.inf.is.odysseus.base.ILogicalOperator;import de.uniol.inf.is.odysseus.base.IQueryParser;import de.uniol.inf.is.odysseus.base.QueryParseException;import de.uniol.inf.is.odysseus.parser.pql.IOperatorBuilder;public class PQLParserImpl{  private static Map < String, IOperatorBuilder > operatorBuilders = new HashMap < String, IOperatorBuilder > ();  public static void addOperatorBuilder(String identifier, IOperatorBuilder builder)  {    if (operatorBuilders.containsKey(identifier.toUpperCase()))    {      throw new IllegalArgumentException("builder for '" + identifier.toUpperCase() + "' already available");    }    operatorBuilders.put(identifier.toUpperCase(), builder);  }  public static void removeOperatorBuilder(String identifier)  {    operatorBuilders.remove(identifier.toUpperCase());  }  static private ILogicalOperator createOperator(String identifier, Map < String, Object > parameters, List < ILogicalOperator > inputOps)  {    IOperatorBuilder builder = operatorBuilders.get(identifier.toUpperCase());    if (builder == null)    {      throw new IllegalArgumentException("unknown operator type: " + identifier.toUpperCase());    }    return builder.createOperator(parameters, inputOps);  }}PARSER_END(PQLParserImpl)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :{  < K_OUT : "OUT" >| < IDENTIFIER :    (< LETTER >)+    (      < DIGIT >    | < LETTER >    | < SPECIAL_CHARS >    )* >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #SPECIAL_CHARS :    "_"  | "." >| < CHAR_LITERAL :    "'" (~[ "'" ])* "'"    (      "'" (~[ "'" ])* "'"    )* >| < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >}TOKEN : /* Numeric Constants */{  < FLOAT :    ("-")?    (      < INTEGER > "." < INTEGER >    | "." < INTEGER >    ) >| < INTEGER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}ILogicalOperator query() :{  Map < String, ILogicalOperator > namedOps = new HashMap < String, ILogicalOperator > ();  ILogicalOperator result;}{  (    namedOperator(namedOps)  )*  < K_OUT > ":" result = operator(namedOps)  {    return result;  }}void namedOperator(Map < String, ILogicalOperator > namedOps) :{  Token name;  ILogicalOperator op;}{  name = < IDENTIFIER > ":" op = operator(namedOps)  {    String nameStr = name.image.toUpperCase();    if (namedOps.containsKey(nameStr))    {      throw new IllegalArgumentException("multiple definition of '"+ nameStr+ "'");    }    namedOps.put(nameStr, op);  }}ILogicalOperator operator(Map < String, ILogicalOperator > namedOps) :{  Token identifier;  Map < String, Object > parameters = new HashMap<String, Object > ();  List < ILogicalOperator > inputOps;}{  LOOKAHEAD(< IDENTIFIER > "(")  identifier = < IDENTIFIER > "(" [ "[" parameters = parameterList() "]" "," ] inputOps = operatorList(namedOps) ")"  {    return createOperator(identifier.image, parameters, inputOps);  }| identifier = < IDENTIFIER >  {    ILogicalOperator op = namedOps.get(identifier.image.toUpperCase());    if (op == null)    {      throw new IllegalArgumentException("no such operator: "+ identifier.image);    }    return op;  }}Map<String, Object > parameterList() :{  Map<String, Object > parameters = new HashMap< String, Object> ();}{  parameter(parameters)  (    "," parameter(parameters)  )*  {    return parameters;  }}void parameter(Map < String, Object > parameters) :{
  Token t;  Token id;  Object value;}{  id = < IDENTIFIER > "="  (    t = < FLOAT >    {      value = Double.valueOf(t.image);    }  | t = < INTEGER >    {      value = Integer.valueOf(t.image);    }  | t = < CHAR_LITERAL >    {      value = t.image.substring(1, t.image.length() - 2);    }  )  {    parameters.put(id.image.toUpperCase(), value);  }}List < ILogicalOperator > operatorList(Map < String, ILogicalOperator > namedOps) :{  List list = new LinkedList();  ILogicalOperator operator;}{  [    operator = operator(namedOps)    {      list.add(operator);    }    (      "," operator = operator(namedOps)      {        list.add(operator);      }    )*  ]  {    return list;  }}