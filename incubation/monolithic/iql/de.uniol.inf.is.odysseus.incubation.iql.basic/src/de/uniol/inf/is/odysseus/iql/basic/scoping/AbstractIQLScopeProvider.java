/**
 * generated by Xtext
 */
package de.uniol.inf.is.odysseus.iql.basic.scoping;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeSet;

import javax.inject.Inject;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.common.types.JvmField;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmIdentifiableElement;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.common.types.access.IJvmTypeProvider;
import org.eclipse.xtext.common.types.access.impl.ClasspathTypeProvider;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.ImportNormalizer;
import org.eclipse.xtext.scoping.impl.ImportScope;
import org.eclipse.xtext.scoping.impl.SimpleScope;

import de.uniol.inf.is.odysseus.core.collection.Pair;
import de.uniol.inf.is.odysseus.iql.basic.basicIQL.IQLClass;
import de.uniol.inf.is.odysseus.iql.basic.basicIQL.IQLFile;
import de.uniol.inf.is.odysseus.iql.basic.basicIQL.IQLMemberSelectionExpression;
import de.uniol.inf.is.odysseus.iql.basic.basicIQL.IQLNamespace;
import de.uniol.inf.is.odysseus.iql.basic.basicIQL.IQLStatementBlock;
import de.uniol.inf.is.odysseus.iql.basic.basicIQL.IQLVariableDeclaration;
import de.uniol.inf.is.odysseus.iql.basic.lookup.IIQLLookUp;
import de.uniol.inf.is.odysseus.iql.basic.typing.TypeResult;
import de.uniol.inf.is.odysseus.iql.basic.typing.exprparser.IIQLExpressionParser;
import de.uniol.inf.is.odysseus.iql.basic.typing.factory.IIQLTypeFactory;
import de.uniol.inf.is.odysseus.iql.basic.typing.utils.IIQLTypeUtils;


/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it
 */
@SuppressWarnings("restriction")
public abstract class AbstractIQLScopeProvider<T extends IIQLTypeFactory, L extends IIQLLookUp, P extends IIQLExpressionParser, U extends IIQLTypeUtils> extends AbstractDeclarativeScopeProvider implements IIQLScopeProvider {

	protected P exprParser;
	
	protected U typeUtils;
	
	@Inject
	protected IQualifiedNameProvider qualifiedNameProvider;
	
	protected L lookUp;

	@Inject
	protected IQualifiedNameConverter converter;
	
	@Inject
	protected IQLClasspathTypeProviderFactory factory;
	
	protected T typeFactory;
	
	public AbstractIQLScopeProvider(T typeFactory, L lookUp, P exprParser, U typeUtils) {
		this.typeFactory = typeFactory;
		this.lookUp = lookUp;
		this.exprParser = exprParser;
		this.typeUtils = typeUtils;

	}
	
	public IScope scope_IQLSimpleType_type(IQLFile file, EReference type) {	
		Collection<JvmType> types = getAllTypes(file);
		
		IJvmTypeProvider provider = factory.findOrCreateTypeProvider(EcoreUtil2.getResourceSet(file));
		IScope parentScope = new IQLClasspathBasedTypeScope((ClasspathTypeProvider) provider, converter, null);
	
		IScope scope =  Scopes.scopeFor(types, qualifiedNameProvider, parentScope);
		return new ImportScope(createImportNormalizers(file), scope, null, type.getEReferenceType(), true);
	}
	
	public IScope scope_IQLArrayType_type(IQLFile file, EReference type) {	
		Collection<JvmType> types = getAllTypes(file);


		IJvmTypeProvider provider = factory.findOrCreateTypeProvider(EcoreUtil2.getResourceSet(file));
		IScope parentScope = new IQLClasspathBasedTypeScope((ClasspathTypeProvider) provider, converter, null);
		IScope scope =  Scopes.scopeFor(types, qualifiedNameProvider, parentScope);
		return new ImportScope(createImportNormalizers(file), scope, null, type.getEReferenceType(), true);
	}
	
	@Override
	public Collection<JvmType> getAllTypes(EObject node) {
		IQLFile file =  EcoreUtil2.getContainerOfType(node, IQLFile.class);		
		Collection<JvmType> types = lookUp.getAllTypes(getUsedNamespaces(file), file.eResource());
		return types;
	}

	
	public IScope scope_IQLJvmElementCallExpression_element(IQLStatementBlock expr, EReference type) {
		Collection<IEObjectDescription> elements = getIQLJvmElementCallExpression(expr);
		return new SimpleScope(elements);
	}
	
	@Override
	public Collection<IEObjectDescription> getIQLJvmElementCallExpression(EObject expr) {
		JvmGenericType type = EcoreUtil2.getContainerOfType(expr, JvmGenericType.class);

		Collection<JvmIdentifiableElement> elements = new HashSet<>();
		EObject container = expr;
		while (container != null && !(container instanceof JvmGenericType)) {
			elements.addAll(EcoreUtil2.getAllContentsOfType(container, IQLVariableDeclaration.class));
			elements.addAll(EcoreUtil2.getAllContentsOfType(container, JvmFormalParameter.class));
			container = container.eContainer();
		}
		if (type instanceof IQLClass) {
			IQLClass clazz = (IQLClass) type;
			Collection<JvmTypeReference> importedTypes = typeFactory.getImportedTypes(expr);
			elements.addAll(lookUp.getPublicAttributes(typeUtils.createTypeRef(clazz), importedTypes, true));
			elements.addAll(lookUp.getProtectedAttributes(typeUtils.createTypeRef(clazz), importedTypes, true));
		
			elements.addAll(lookUp.getPublicMethods(typeUtils.createTypeRef(clazz), importedTypes,true));
			elements.addAll(lookUp.getProtectedMethods(typeUtils.createTypeRef(clazz), importedTypes,true));

		}
			
		Map<String, Pair<JvmOperation, JvmOperation>> properties = new HashMap<>();
		Collection<IEObjectDescription> result = new HashSet<>();
		for (JvmIdentifiableElement element : elements) {
			if (elements instanceof JvmOperation) {
				JvmOperation method = (JvmOperation) element;
				if (typeUtils.isSetter(method)) {
					String name = typeUtils.getNameWithoutSetterPrefix(method);
					Pair<JvmOperation, JvmOperation> pair = properties.get(name);
					if (pair == null) {
						pair = new Pair<JvmOperation, JvmOperation>();
						properties.put(name, pair);
					}
					pair.setE1(method);
				} else if (typeUtils.isGetter(method)) {
					String name = typeUtils.getNameWithoutGetterPrefix(method);
					Pair<JvmOperation, JvmOperation> pair = properties.get(name);
					if (pair == null) {
						pair = new Pair<JvmOperation, JvmOperation>();
						properties.put(name, pair);
					}
					pair.setE2(method);
				}
			} 			
			result.add(EObjectDescription.create(qualifiedNameProvider.getFullyQualifiedName(element), element));
		}
		for (Entry<String, Pair<JvmOperation, JvmOperation>> entry : properties.entrySet()) {
			if (entry.getValue().getE1() != null && entry.getValue().getE2() != null) {
				String name = firstCharLowerCase(entry.getKey());
				result.add(EObjectDescription.create(name, entry.getValue().getE1()));
				result.add(EObjectDescription.create(name, entry.getValue().getE2()));
			}
		}
		return result;
	}	
	
	
	public IScope scope_IQLMemberSelectionExpression_member(IQLMemberSelectionExpression expr, EReference type) {		
		Collection<IEObjectDescription> elements = new HashSet<>();
		elements.addAll(getScopeIQLMemberSelection(expr));		
		return new SimpleScope(elements);
	}
	
	
	@Override
	public Collection<IEObjectDescription> getScopeIQLMemberSelection(IQLMemberSelectionExpression expr) {
		Collection<IEObjectDescription> result = new HashSet<>();
		TypeResult typeResult = exprParser.getType(expr.getLeftOperand());
		
		if (typeUtils.isArray(typeResult.getRef())) {
			result.addAll(getScopeIQLAttributeSelection(typeUtils.createTypeRef(List.class, typeFactory.getSystemResourceSet()), false, false));
			result.addAll(getScopeIQLMethodSelection(typeUtils.createTypeRef(List.class, typeFactory.getSystemResourceSet()), false, false));

		} else {
			boolean isThis = exprParser.isThis(expr.getLeftOperand());
			boolean isSuper = exprParser.isSuper(expr.getLeftOperand());
			
			result.addAll(getScopeIQLAttributeSelection(typeResult.getRef(),isThis, isSuper));
			result.addAll(getScopeIQLMethodSelection(typeResult.getRef(),isThis, isSuper));

		}
		return result;
	}
	
	@Override
	public Collection<IEObjectDescription> getScopeIQLAttributeSelection(JvmTypeReference typeRef, boolean isThis, boolean isSuper) {
		Collection<JvmField> attributes = null;
		attributes = lookUp.getPublicAttributes(typeRef, true);
		if (isThis || isSuper) {
			attributes.addAll(lookUp.getProtectedAttributes(typeRef, true));
		}
		Collection<IEObjectDescription> result = new HashSet<>();
		for (JvmField attribute : attributes) {
			result.add(EObjectDescription.create(qualifiedNameProvider.getFullyQualifiedName(attribute), attribute));
		}
		return result;
	}
	
	
	@Override
	public Collection<IEObjectDescription> getScopeIQLMethodSelection(JvmTypeReference typeRef, boolean isThis, boolean isSuper) {
		Collection<JvmOperation> methods = null;
		methods = lookUp.getPublicMethods(typeRef, true);
		if (isThis || isSuper) {
			methods.addAll(lookUp.getProtectedMethods(typeRef, true));
		}
		Map<String, Pair<JvmOperation, JvmOperation>> properties = new HashMap<>();
		Collection<IEObjectDescription> result = new HashSet<>();
		for (JvmOperation method : methods) {
			if (typeUtils.isSetter(method)) {
				String name = typeUtils.getNameWithoutSetterPrefix(method);
				Pair<JvmOperation, JvmOperation> pair = properties.get(name);
				if (pair == null) {
					pair = new Pair<JvmOperation, JvmOperation>();
					properties.put(name, pair);
				}
				pair.setE1(method);
			} else if (typeUtils.isGetter(method)) {
				String name = typeUtils.getNameWithoutGetterPrefix(method);
				Pair<JvmOperation, JvmOperation> pair = properties.get(name);
				if (pair == null) {
					pair = new Pair<JvmOperation, JvmOperation>();
					properties.put(name, pair);
				}
				pair.setE2(method);
			}			
			result.add(EObjectDescription.create(qualifiedNameProvider.getFullyQualifiedName(method), method));
		}
		for (Entry<String, Pair<JvmOperation, JvmOperation>> entry : properties.entrySet()) {
			if (entry.getValue().getE1() != null && entry.getValue().getE2() != null) {
				String name = firstCharLowerCase(entry.getKey());
				result.add(EObjectDescription.create(name, entry.getValue().getE1()));
				result.add(EObjectDescription.create(name, entry.getValue().getE2()));
			}
		}
		return result;
	}
	
	protected String firstCharLowerCase(String s) {
		return Character.toLowerCase(s.charAt(0)) + s.substring(1);
	}
	
	@Override
	public Collection<String> getUsedNamespaces(EObject obj) {
		Collection<String> namespaces = new HashSet<>();
		IQLFile file = EcoreUtil2.getContainerOfType(obj, IQLFile.class);
		//namespaces.addAll(typeFactory.getImplicitImports());
		for (IQLNamespace namespace : file.getNamespaces()) {
			String name = namespace.getImportedNamespace();
			name = name.replaceAll(IQLQualifiedNameConverter.DELIMITER, ".");
			namespaces.add(name);
		}
		return namespaces;
	}
	
	protected List<ImportNormalizer> createImportNormalizers(EObject obj) {
		IQLFile file = EcoreUtil2.getContainerOfType(obj, IQLFile.class);
		List<ImportNormalizer> imports = new ArrayList<>();		
		Set<String> wildCards = new TreeSet<>();	
		for (IQLNamespace namespace : file.getNamespaces()) {
			String name = namespace.getImportedNamespace();
			boolean wildcard = name.endsWith("*");
			if (wildcard) {
				wildCards.add(name);
			} else {
				imports.add(new IQLImportNormalizer(converter.toQualifiedName(name), wildcard, true));
			}
		}
		
		for (String name : typeFactory.getImplicitImports()) {
			boolean wildcard = name.endsWith("*");
			if (wildcard) {
				name = name.substring(0, name.lastIndexOf(".*"));
				wildCards.add(name);
			} else {
				imports.add(new IQLImportNormalizer(converter.toQualifiedName(name), wildcard, true));
			}
		}
		
		for (String name : wildCards) {
			imports.add(new IQLImportNormalizer(converter.toQualifiedName(name), true, true));
		}
		
		return imports;
	} 
}
