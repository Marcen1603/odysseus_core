options{  IGNORE_CASE = true;
  MULTI = true;
  VISITOR = true;
  //  NODE_DEFAULT_VOID=true;
  //  JJTREE_OUTPUT_DIRECTORY = "";
  NODE_PACKAGE = "de.uniol.inf.is.odysseus.mining.smql.parser";
  DEBUG_PARSER = false;
  //DEBUG_TOKEN_MANAGER = false;}PARSER_BEGIN(SMQLParser)package de.uniol.inf.is.odysseus.mining.smql.parser;

@ SuppressWarnings("all") public class SMQLParser{}PARSER_END(SMQLParser)SKIP :{  " "| "\r"| "\n"| "\t"}TOKEN :{  < K_AND : "AND" > | < K_AVG : "AVG" >| < K_BY : "BY" >| < K_CLEAN : "CLEAN" >| < K_CORRECT : "CORRECT" >| < K_COUNT : "COUNT" >| < K_CREATE : "CREATE" >| < K_DETECT : "DETECT" >| < K_DISCARD : "DISCARD" >| < K_DISCOVERY : "DISCOVERY" >| < K_DOMAIN : "DOMAIN" >| < K_FUNCTION : "FUNCTION" >| < K_IN : "IN" >| < K_KNOWLEDGE : "KNOWLEDGE" >| < K_LAST : "LAST" >| < K_MAX : "MAX" >| < K_MIN : "MIN" >| < K_NOT : "NOT" >| < K_OF : "OF" >| < K_OUT : "OUT" >| < K_OUTLIER : "OUTLIER" >| < K_OR : "OR" >| < K_PROCESS : "PROCESS" >| < K_RANGE : "RANGE" >| < K_ROUND : "ROUND" >| < K_SIGMA : "SIGMA" >| < K_SUM : "SUM" >| < K_TIME : "TIME" >| < K_TO : "TO" >| < K_TUPLE : "TUPLE" >| < K_VALUE : "VALUE" >}TOKEN : /* Numeric Constants */{  //  <NUMBER:<FLOAT>  //  | <FLOAT>(["e", "E"](["-", "+"])?<FLOAT>)?>  //  | <#FLOAT:<INTEGER>  //  | <INTEGER>("."<INTEGER>)?  //  | "."<INTEGER>>  < FLOAT :    ("-")?    (      < INTEGER > "." < INTEGER >    | "." < INTEGER >    ) >| < INTEGER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >| < IPADDRESS : < DIGIT > (< DIGIT >)? (< DIGIT >)? "." < DIGIT > (< DIGIT >)? (< DIGIT >)? "." < DIGIT > (< DIGIT >)? (< DIGIT >)? "." < DIGIT > (< DIGIT >)? (< DIGIT >)? >}SPECIAL_TOKEN :{  < LINE_COMMENT : "--" (~[ "\r", "\n" ])* >| < MULTI_LINE_COMMENT :    "/*" (~[ "*" ])* "*"    (      "*"    |      (        ~[ "*", "/" ] (~[ "*" ])* "*"      )    )*    "/" >}TOKEN :{  < IDENTIFIER :    (< LETTER >)+    (      < DIGIT >    | < LETTER >    | < SPECIAL_CHARS >    )* >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #SPECIAL_CHARS :    ":"  | "_"  | "."  | "*" >| < CHAR_LITERAL :    "'" (~[ "'" ])* "'"    (      "'" (~[ "'" ])* "'"    )* >| < SQL_STRING :    "[[" (~[ "[", "]" ])* "]]"    (      "[[" (~[ "[", "]" ])* "]]"    )* >| < QUOTED_IDENTIFIER : "\"" (~[ "\n", "\r", "\"" ])* "\"" >| < COMPARE_OPERATOR :    "="  | "<>"  | ">"  | "<"  | "<="  | ">=" >| < REGEXP :    "/" ("^")?    (      < LETTER >    | < DIGIT >    | "\\"    | "+"    | "."    | "*"    | "?"    | "$"    )+    "/" >| < JDBC_STRING :    "jdbc:"    (      (        < DIGIT >      | < LETTER >      | < SPECIAL_CHARS >      | "?"      | ";"      | "/"      | "="      )*    )* >}SimpleNode Start() :{}{  CreateKnowledgeDiscoveryProcess()  {    return jjtThis;  }}String Identifier():{  Token t;}{  t = < IDENTIFIER >  {        {jjtThis.jjtSetValue(getToken(0).image);}    return t.image;  }}Long Integer() :{  Token t;}{  t = < INTEGER >  {    Long value = Long.parseLong(t.image);    return value;  }}Float Float() :{  Token t;}{  t = < FLOAT >  {    Float value = Float.parseFloat(t.image);    return value;  }}void Number():{}{	Integer()|Float()}void CreateKnowledgeDiscoveryProcess() :{}{	< K_CREATE > <K_KNOWLEDGE > < K_DISCOVERY > <K_PROCESS > Identifier() "{" ProcessPhases() "}"	  }void ProcessPhases() :{}{	(CleanPhase())*	  }
void CleanPhase() :{}{ 	< K_CLEAN > Identifier() "{" OutlierDetections() "}" }void OutlierDetections() :{}{ 	(OutlierDetection())+ }void OutlierDetection():{}{  < K_DETECT > < K_OUTLIER > DetectionMethod() < K_IN > Identifier() < K_AND > CorrectionMethod()}void DetectionMethod():{}{ 	(	   LOOKAHEAD(3)< K_OUT > < K_OF > <K_RANGE > Integer() (< K_TUPLE > | < K_TIME >)	| < K_VALUE > Integer()	| < K_SIGMA > Integer()	| < K_FUNCTION > Identifier()	|  LOOKAHEAD(3)< K_OUT > < K_OF > <K_DOMAIN > Number() < K_TO > Number()	)  (     ParameterList()  )?}void ParameterList() :{}{	"(" Parameter() ("," Parameter())* ")"}void Parameter() :{}{	Identifier() ":=" ( Number() | Identifier() )}void CorrectionMethod():{}{  CorrectionMethodDiscard() | CorrectionMethodFunction()}void CorrectionMethodDiscard():{}{  < K_DISCARD >}void CorrectionMethodFunction():{}{  < K_CORRECT > < K_BY >  "["	(	  < K_FUNCTION > Identifier()	| < K_VALUE > Number()	| < K_LAST > < K_VALUE >		)  "]"  }