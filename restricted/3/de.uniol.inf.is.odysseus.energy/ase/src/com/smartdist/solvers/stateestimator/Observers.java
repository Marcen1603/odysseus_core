/*
 * 
 * This work is copyright.
 * 
 * Copyright 2012-2014 Dr. Olav Krause
 * 
 */

package com.smartdist.solvers.stateestimator;

import java.util.Vector;

import com.smartdist.modelconnecting.*;
import com.smartdist.util.Complex;

/**
 * @author uqokraus
 * 
 *         This class will derive the theoretical values and the individual
 *         measurement model coverages from a) the FourWireNetwork the estimator
 *         was run on b) the set of Connectors your're interested in and c) the
 *         EstimationResultSet generated by the estimator
 * 
 */

// TODO implement it ;-)

public class Observers {

	Vector<ModelConnector> connectors = new Vector<ModelConnector>();
	Vector<Double> modelCoverage = new Vector<Double>();

	public void addConnector(ModelConnector connector) {
		this.connectors.add(connector);
		this.modelCoverage.add(90.);
	}

	public Vector<ModelConnector> getConnectors() {
		return this.connectors;
	}

	public Vector<Double> getModelCoverage() {
		return this.modelCoverage;
	}

	public int numberOfConnectors() {
		return this.connectors.size();
	}

	public ModelConnector getConnector(int i) {
		return this.connectors.elementAt(i);
	}

	public void calculateModelCoverages(EstimationResultSet results) {
		double[][] rightSingularVectors = results.rightSingularVectors;
		int rank = results.rank;

		double[] tempJacobian = null;
		double[] tempProjection = new double[rank];
		double[] tempProjected = null;
		double tempNormJacobian = 0;
		double tempNormProjected = 0;
		for (int i = 0; i < this.connectors.size(); i++) {
			for (int j = 0; j < rank; j++) {
				tempProjection[j] = 0;
			}
			tempNormJacobian = 0;
			tempJacobian = this.connectors.elementAt(i).myJacobianRow(
					results.voltages);
			for (int j = 0; j < tempJacobian.length; j++) {
				tempNormJacobian += tempJacobian[j] * tempJacobian[j];
				for (int k = 0; k < rank; k++) {
					tempProjection[k] += tempJacobian[j]
							* rightSingularVectors[j][k];
				}
			}
			tempNormJacobian = java.lang.Math.sqrt(tempNormJacobian);
			tempProjected = new double[tempJacobian.length];
			for (int j = 0; j < tempJacobian.length; j++) {
				for (int k = 0; k < rank; k++) {
					tempProjected[j] += rightSingularVectors[j][k]
							* tempProjection[k];
				}
			}
			tempNormProjected = 0;
			for (int j = 0; j < tempProjected.length; j++) {
				tempNormProjected += tempProjected[j] * tempProjected[j];
			}
			tempNormProjected = java.lang.Math.sqrt(tempNormProjected);
			if (tempNormJacobian != 0) {
				if ((tempNormProjected / tempNormJacobian) > 1.) {
					this.modelCoverage.setElementAt(0., i);
				} else {
					this.modelCoverage
							.setElementAt(
									java.lang.Math
											.acos((tempNormProjected / tempNormJacobian))
											/ java.lang.Math.PI * 180., i);
				}
			} else {
				this.modelCoverage.setElementAt(90., i);
			}
		}

	}

	public double[][] getJacobian(Complex[] assumedVoltages) {
		double[][] Jacobian = new double[this.connectors.size()][2 * assumedVoltages.length];
		double[] temp = null;
		for (int i = 0; i < Jacobian.length; i++) {
			temp = this.connectors.elementAt(i).myJacobianRow(assumedVoltages);
			for (int j = 0; j < Jacobian[i].length; j++) {
				Jacobian[i][j] = temp[j];
			}
		}
		return Jacobian;
	}

}
