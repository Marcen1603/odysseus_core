/*
 * 
 * This work is copyright.
 * 
 * Copyright 2012-2014 Dr. Olav Krause
 * 
 */


package com.smartdist.modelling.network;

import java.util.Collection;
import java.util.Iterator;

import com.smartdist.util.Complex;

import edu.uci.ics.jung.graph.DirectedSparseMultigraph;

/**
 * <p>
 * To be able to model a distribution network with acceptable accuracy, within
 * SmartDist it is modeled as a four wire ABCN network. All values are physical
 * and there is no 'per unit' representation.
 * </p>
 * 
 * <p>
 * Since the JUNG graph framework doesn't allow 'loose ends' or additional
 * elements associated with just one vertex, the vertex class Node is designed
 * as a container for instances of class FourTerminalElement. It may contain any
 * number of instances of FourTerminalElements, including nil. These elements
 * can represent an electric load, a shunt compensation facility or comparable
 * devices, connected to just one Busbar in the electric power grid.
 * </p>
 * 
 * <p>
 * The edge class in the FourWireNetwork is class EightTerminalElement. This can
 * represent a line, a transformer or any other element connecting two Busbars
 * in the electric Power Grid.
 * </p>
 * 
 * <p>
 * Both fundamental modeling elements, FourTerminalElement and
 * EightTerminalElement, have to produce and pass a Admittance-based model of
 * their terminal behavior in physical domain. If you are unfamiliar with this
 * concept, please refer to <A
 * HREF="http://en.wikipedia.org/wiki/Two-port_network"> this article on
 * Wikipedia for a quick overview </A> and n-port network theory in general.
 * </p>
 * 
 * 
 * @author Dr. Olav Krause
 * 
 */
public class FourWireNetwork extends
		DirectedSparseMultigraph<Node, EightTerminalElement> {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	public static final int phaseA = 0;
	public static final int phaseB = 1;
	public static final int phaseC = 2;
	public static final int phaseN = 3;

	public Complex[][] networkAdmittanceMatrix = null;
	public double nominalFrequency = 0;
	public double baseMVA = 0; // used for p.u. calculations. when calculating
								// in physical parameters, set to 0

	/**
	 * <p>
	 * The process of generating the overall network model is triggered by
	 * invocation of {@link #generateAdmittanceMatrices(double)} In the process
	 * of generating the overall network model, the instance of
	 * {@link FourWireNetwork} will:
	 * <OL type="1">
	 * <LI>enumerate all its instances of class Node consecutively with int
	 * number 0...n
	 * <LI>generate the overall admittance matrix of type {@link Complex} and of
	 * size 4n*4n
	 * <LI>will invoke generateAdmittanceMatrix(double) of all its edges, which
	 * are of type {@link EightTerminalElement}.
	 * <LI>will invoke generateAdmittanceMatrix(double) of {@link Node}
	 * <OL type="a">
	 * <LI>generate a 4*4 array of Complex[][] as the overall admittance matrix
	 * of the particular instance of Node
	 * <LI>invoke generate admittanceMatrix(double) of all its associated
	 * instances of FourTerminalElement
	 * <LI>sum the admittance elements generated by the instances of
	 * FourTerminalElement into the corresponding fields of the previously
	 * generated admittance matrix
	 * <LI>return the generated admittance matrix
	 * </OL>
	 * <LI>will sum all admittances received from its Vertices and Edges into
	 * the overall admittance matrix. Here:
	 * <OL type="a">
	 * <LI>the 4*4 elements received from a vertex are simply copied element by
	 * element into the column and row corresponding to the vertex' Node and the
	 * respective phase
	 * <LI>The 8*8 elements recieved from an edge contain four different parts.
	 * <OL type="i">
	 * <LI>upper left quarter: currents at the start node as a function of
	 * voltage at start node
	 * <LI>upper right quarter: currents at the start node as a function of
	 * voltage at the terminal node
	 * <LI>lower left quarter: currents at the terminal node as a function of
	 * voltage at the start node
	 * <LI>lower right quarter: currents at the terminal node as a function of
	 * voltage at the terminal node
	 * </OL>
	 * <LI>according to this interpretation, the elements can be sorted into the
	 * overall admittance matrix by summing them with the previous value of the
	 * respective element of the overall admittance matrix
	 * </OL>
	 * </OL>
	 * </p>
	 * 
	 * @param nominalFrequency
	 *            nominal operational frequency of the power grid in Hertz.
	 * @return for a network with n vertices, this function returns a 4n*4n
	 *         array of {@link com.smartdist.util.Complex}, representing the
	 *         admittance matrix of the entire network in physical parameter. No
	 *         use of per unit system!
	 */

	public FourWireNetwork(double nominalFrequency) {
		this.nominalFrequency = nominalFrequency;
	}

	public void generateAdmittanceMatrices() {

		// Enumerate vertices
		Iterator<Node> vertexIterator = this.getVertices().iterator();
		int modelNumber = 0;
		for (; vertexIterator.hasNext();) {
			vertexIterator.next().setModelNumber(modelNumber++);
		}

		// Initialize the overall admittance matrix
		int numberOfVertices = this.vertices.size();
		Complex[][] networkAdmittanceMatrix = new Complex[4 * numberOfVertices][4 * numberOfVertices];
		for (int i = 0; i < 4 * numberOfVertices; i++) {
			for (int j = 0; j < 4 * numberOfVertices; j++) {
				networkAdmittanceMatrix[i][j] = new Complex(0, 0);
			}
		}

		// Invoke generateAdmittanceMatrix of edges
		Iterator<EightTerminalElement> edgeIterator = this.getEdges()
				.iterator();
		Complex[][] tempEightMatrix = null;
		EightTerminalElement tempEdge = null;
		int startNode, terminalNode = 0;
		for (; edgeIterator.hasNext();) {
			tempEdge = edgeIterator.next();
			tempEightMatrix = tempEdge
					.generateAdmittanceMatrix(nominalFrequency);
			startNode = this.getSource(tempEdge).getModelNumber();
			terminalNode = this.getDest(tempEdge).getModelNumber();
			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					// upper left quarter
					networkAdmittanceMatrix[4 * startNode + i][4 * startNode
							+ j].add(tempEightMatrix[i][j]);
					// upper right quarter
					networkAdmittanceMatrix[4 * startNode + i][4 * terminalNode
							+ j].add(tempEightMatrix[i][4 + j]);
					// lower left corner
					networkAdmittanceMatrix[4 * terminalNode + i][4 * startNode
							+ j].add(tempEightMatrix[4 + i][j]);
					// lower right quarter
					networkAdmittanceMatrix[4 * terminalNode + i][4
							* terminalNode + j]
							.add(tempEightMatrix[4 + i][4 + j]);
				}
			}
		}

		// Invoke generateAdmittanceMatrix of vertices
		vertexIterator = this.getVertices().iterator();
		Complex[][] tempFourMatrix = null;
		Node tempVertex = null;
		int tempNode = 0;
		for (; vertexIterator.hasNext();) {
			tempVertex = vertexIterator.next();
			tempFourMatrix = tempVertex
					.generateAdmittanceMatrix(nominalFrequency);
			tempNode = tempVertex.getModelNumber();
			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					networkAdmittanceMatrix[4 * tempNode + i][4 * tempNode + j]
							.add(tempFourMatrix[i][j]);
				}
			}
		}

		this.networkAdmittanceMatrix = networkAdmittanceMatrix;
	}

	@Override
	public boolean addVertex(Node vertex) {
		return super.addVertex(vertex);
	}

	@Override
	public boolean addEdge(EightTerminalElement edge, Node source, Node dest) {
		return super.addEdge(edge, source, dest);
	}

	@Override
	public int getVertexCount() {
		return super.getVertexCount();
	}

	@Override
	public Collection<Node> getVertices() {
		return super.getVertices();
	}
}
