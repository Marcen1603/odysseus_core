/**
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.cql2.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Guice;
import com.google.inject.Injector;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.AccessAO;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.AggregateAO;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.SenderAO;
import de.uniol.inf.is.odysseus.parser.cql2.CQLRuntimeModule;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.AccessFramework;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Alias;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Attribute;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ComplexSelect;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Create;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateAccessFramework;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateChannelFormatViaFile;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateChannelFrameworkViaPort;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateDatabaseSink;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateDatabaseStream;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateView;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ExpressionComponent;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Function;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.InnerSelect2;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Query;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SchemaDefinition;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SelectArgument;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SelectExpression;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SimpleSelect;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Source;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Starthing;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.StreamTo;
import de.uniol.inf.is.odysseus.parser.cql2.generator.AttributeStruct;
import de.uniol.inf.is.odysseus.parser.cql2.generator.SourceStruct;
import de.uniol.inf.is.odysseus.parser.cql2.generator.builder.AbstractPQLOperatorBuilder;
import de.uniol.inf.is.odysseus.parser.cql2.generator.builder.PQLBuilderModule;
import de.uniol.inf.is.odysseus.parser.cql2.generator.cache.CacheModule;
import de.uniol.inf.is.odysseus.parser.cql2.generator.cache.ICacheService;
import de.uniol.inf.is.odysseus.parser.cql2.generator.cache.OperatorCache;
import de.uniol.inf.is.odysseus.parser.cql2.generator.parser.IAttributeNameParser;
import de.uniol.inf.is.odysseus.parser.cql2.generator.parser.IExistenceParser;
import de.uniol.inf.is.odysseus.parser.cql2.generator.parser.IJoinParser;
import de.uniol.inf.is.odysseus.parser.cql2.generator.parser.IPredicateParser;
import de.uniol.inf.is.odysseus.parser.cql2.generator.parser.IRenameParser;
import de.uniol.inf.is.odysseus.parser.cql2.generator.parser.ISelectParser;
import de.uniol.inf.is.odysseus.parser.cql2.generator.parser.ParserModule;
import de.uniol.inf.is.odysseus.parser.cql2.generator.utility.IUtilityService;
import de.uniol.inf.is.odysseus.parser.cql2.generator.utility.UtilityModule;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGenerator2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Generates PQL text from a CQL text.
 */
@SuppressWarnings("all")
public class CQLGenerator implements IGenerator2 {
  private final Logger log = LoggerFactory.getLogger(CQLGenerator.class);
  
  private Map<String, String> databaseConnections = CollectionLiterals.<String, String>newHashMap();
  
  private IPredicateParser predicateParser;
  
  private IUtilityService utilityService;
  
  private ICacheService cacheService;
  
  private IAttributeNameParser attributeParser;
  
  private IRenameParser renameParser;
  
  private IJoinParser joinParser;
  
  private ISelectParser selectParser;
  
  private IExistenceParser existenceParser;
  
  private AbstractPQLOperatorBuilder builder;
  
  public CQLGenerator() {
    CQLRuntimeModule _cQLRuntimeModule = new CQLRuntimeModule();
    UtilityModule _utilityModule = new UtilityModule();
    CacheModule _cacheModule = new CacheModule();
    PQLBuilderModule _pQLBuilderModule = new PQLBuilderModule();
    ParserModule _parserModule = new ParserModule();
    Injector injector = Guice.createInjector(_cQLRuntimeModule, _utilityModule, _cacheModule, _pQLBuilderModule, _parserModule);
    this.utilityService = injector.<IUtilityService>getInstance(IUtilityService.class);
    this.cacheService = injector.<ICacheService>getInstance(ICacheService.class);
    this.predicateParser = injector.<IPredicateParser>getInstance(IPredicateParser.class);
    this.attributeParser = injector.<IAttributeNameParser>getInstance(IAttributeNameParser.class);
    this.renameParser = injector.<IRenameParser>getInstance(IRenameParser.class);
    this.joinParser = injector.<IJoinParser>getInstance(IJoinParser.class);
    this.selectParser = injector.<ISelectParser>getInstance(ISelectParser.class);
    this.existenceParser = injector.<IExistenceParser>getInstance(IExistenceParser.class);
    this.builder = injector.<AbstractPQLOperatorBuilder>getInstance(AbstractPQLOperatorBuilder.class);
  }
  
  public void clear() {
    this.predicateParser.clear();
    this.utilityService.clear();
    this.joinParser.clear();
    this.renameParser.clear();
    this.selectParser.clear();
    this.cacheService.getOperatorCache().flush();
    this.cacheService.getSourceCache().clear();
    this.cacheService.getSelectCache().flush();
    this.cacheService.getExpressionCache().clear();
  }
  
  @Override
  public void afterGenerate(final Resource input, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
  }
  
  @Override
  public void beforeGenerate(final Resource input, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
  }
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    fsa.generateFile(("" + Integer.valueOf(1)), this.parseStatement(((Query[])Conversions.unwrapArray(Iterables.<Query>filter(IteratorExtensions.<EObject>toIterable(resource.getAllContents()), Query.class), Query.class))[0]));
  }
  
  /**
   * Parses a {@link Query} object that either represents a {@link ComplexSelect}, {@link Create} or {@link StreamTo}.
   * It returns an operator plan that consists of PQL-operators.
   */
  public CharSequence parseStatement(final Query query) {
    this.log.debug("parsing CQL query: selecting query type");
    EObject _type = query.getType();
    if ((_type instanceof ComplexSelect)) {
      EObject _type_1 = query.getType();
      ComplexSelect select = ((ComplexSelect) _type_1);
      String _operation = select.getOperation();
      boolean _tripleNotEquals = (_operation != null);
      if (_tripleNotEquals) {
        this.selectParser.parseComplex(select.getLeft(), select.getRight(), select.getOperation());
      } else {
        this.selectParser.parse(select.getLeft());
      }
    } else {
      EObject _type_2 = query.getType();
      if ((_type_2 instanceof Create)) {
        EObject _type_3 = query.getType();
        this.parseCreate(((Create) _type_3));
      } else {
        EObject _type_4 = query.getType();
        if ((_type_4 instanceof StreamTo)) {
          EObject _type_5 = query.getType();
          this.parseStreamTo(((StreamTo) _type_5));
        }
      }
    }
    return this.cacheService.getOperatorCache().getPQL();
  }
  
  public CharSequence parseCreate(final Create statement) {
    CharSequence _xifexpression = null;
    EObject _create = statement.getCreate();
    if ((_create instanceof CreateView)) {
      EObject _create_1 = statement.getCreate();
      _xifexpression = this.parseCreateView(((CreateView) _create_1));
    } else {
      CharSequence _xifexpression_1 = null;
      EObject _create_2 = statement.getCreate();
      if ((_create_2 instanceof CreateAccessFramework)) {
        EObject _create_3 = statement.getCreate();
        _xifexpression_1 = this.parseCreateAccessFramework(((CreateAccessFramework) _create_3), statement.getType());
      } else {
        CharSequence _xifexpression_2 = null;
        EObject _create_4 = statement.getCreate();
        if ((_create_4 instanceof CreateChannelFormatViaFile)) {
          EObject _create_5 = statement.getCreate();
          _xifexpression_2 = this.parseCreateStreamFile(((CreateChannelFormatViaFile) _create_5));
        } else {
          CharSequence _xifexpression_3 = null;
          EObject _create_6 = statement.getCreate();
          if ((_create_6 instanceof CreateChannelFrameworkViaPort)) {
            EObject _create_7 = statement.getCreate();
            _xifexpression_3 = this.parseCreateStreamChannel(((CreateChannelFrameworkViaPort) _create_7));
          } else {
            String _xifexpression_4 = null;
            EObject _create_8 = statement.getCreate();
            if ((_create_8 instanceof CreateDatabaseStream)) {
              EObject _create_9 = statement.getCreate();
              _xifexpression_4 = this.parseCreateDatabaseStream(((CreateDatabaseStream) _create_9));
            } else {
              String _xifexpression_5 = null;
              EObject _create_10 = statement.getCreate();
              if ((_create_10 instanceof CreateDatabaseSink)) {
                EObject _create_11 = statement.getCreate();
                _xifexpression_5 = this.parseCreateDatabaseSink(((CreateDatabaseSink) _create_11));
              }
              _xifexpression_4 = _xifexpression_5;
            }
            _xifexpression_3 = _xifexpression_4;
          }
          _xifexpression_2 = _xifexpression_3;
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  private CharSequence parseCreateView(final CreateView view) {
    SimpleSelect _select = view.getSelect().getSelect();
    SimpleSelect select = ((SimpleSelect) _select);
    this.selectParser.parse(select);
    String viewName = view.getName();
    this.cacheService.getOperatorCache().addSink(viewName);
    return viewName;
  }
  
  private final String SINK_INPUT_KEYWORD = "--INPUT--";
  
  private final String VIEW = "VIEW_KEY_";
  
  private CharSequence parseCreateAccessFramework(final CreateAccessFramework create, final String type) {
    String operator = null;
    String _upperCase = type.toUpperCase();
    if (_upperCase != null) {
      switch (_upperCase) {
        case "STREAM":
          operator = "ACCESS";
          break;
        case "SINK":
          operator = "SENDER";
          break;
      }
    }
    operator = this.buildCreate1(operator, create.getPars(), create.getAttributes(), create.getAttributes().getName()).toString();
    boolean _equals = type.toUpperCase().equals("SINK");
    if (_equals) {
      boolean _contains = operator.contains(this.SINK_INPUT_KEYWORD);
      boolean _not = (!_contains);
      if (_not) {
        OperatorCache _operatorCache = this.cacheService.getOperatorCache();
        String _name = create.getAttributes().getName();
        String _plus = (this.VIEW + _name);
        return _operatorCache.registerOperator(_plus, operator);
      } else {
        Map<String, String> _sinks = this.cacheService.getOperatorCache().getSinks();
        String _name_1 = create.getAttributes().getName();
        String _plus_1 = (this.VIEW + _name_1);
        _sinks.put(_plus_1, operator);
      }
    } else {
      OperatorCache _operatorCache_1 = this.cacheService.getOperatorCache();
      String _name_2 = create.getAttributes().getName();
      String _plus_2 = (this.VIEW + _name_2);
      _operatorCache_1.registerOperator(_plus_2, operator);
    }
    return "";
  }
  
  private String parseCreateDatabaseSink(final CreateDatabaseSink sink) {
    String _xblockexpression = null;
    {
      Map<String, String> args = CollectionLiterals.<String, String>newHashMap();
      args.put("connection", sink.getDatabase());
      args.put("table", sink.getTable());
      String type = "";
      boolean _contains = this.databaseConnections.keySet().contains(sink.getDatabase());
      if (_contains) {
        type = this.databaseConnections.get(sink.getDatabase());
      } else {
        String _database = sink.getDatabase();
        String _plus = ("Database connection " + _database);
        String _plus_1 = (_plus + " could not be found");
        throw new IllegalArgumentException(_plus_1);
      }
      args.put("type", type);
      args.put("input", this.SINK_INPUT_KEYWORD);
      String _xifexpression = null;
      String _option = sink.getOption();
      boolean _tripleNotEquals = (_option != null);
      if (_tripleNotEquals) {
        String _xifexpression_1 = null;
        boolean _equals = sink.getOption().toUpperCase().equals("DROP");
        if (_equals) {
          _xifexpression_1 = args.put("drop", "true");
        } else {
          _xifexpression_1 = args.put("truncate", "true");
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  private CharSequence extractSchema(final SchemaDefinition schema) {
    ArrayList<String> attributenames = CollectionLiterals.<String>newArrayList();
    ArrayList<String> datatypes = CollectionLiterals.<String>newArrayList();
    for (int i = 0; (i < (schema.getArguments().size() - 1)); i = (i + 2)) {
      {
        attributenames.add(schema.getArguments().get(i));
        datatypes.add(schema.getArguments().get((i + 1)));
      }
    }
    return this.utilityService.generateKeyValueString(attributenames, datatypes, ",");
  }
  
  private int getTimeInMilliseconds(final String time, final int value) {
    String _upperCase = time.toUpperCase();
    if (_upperCase != null) {
      switch (_upperCase) {
        case "MILLISECONDS":
        case "MILLISECOND":
          return value;
        case "SECONDS":
        case "SECOND":
          return (value * 1000);
        case "MINUTES":
        case "MINUTE":
          return (value * (60 * 1000));
        case "HOURS":
        case "HOUR":
          return (value * ((60 * 60) * 1000));
        case "DAYS":
        case "DAY":
          return (value * (((24 * 60) * 60) * 1000));
        case "WEEKS":
        case "WEEK":
          return (value * ((((7 * 24) * 60) * 60) * 1000));
        default:
          return 0;
      }
    } else {
      return 0;
    }
  }
  
  public String parseCreateDatabaseStream(final CreateDatabaseStream stream) {
    Map<String, String> args = CollectionLiterals.<String, String>newHashMap();
    args.put("connection", stream.getDatabase());
    args.put("table", stream.getTable());
    args.put("attributes", this.extractSchema(stream.getAttributes()).toString());
    String operator = "";
    String waitMillis = Integer.valueOf(this.getTimeInMilliseconds(stream.getUnit().getName(), stream.getSize())).toString();
    boolean _equals = waitMillis.equals("0.0");
    boolean _not = (!_equals);
    if (_not) {
      args.put("waiteach", waitMillis);
    }
    OperatorCache _operatorCache = this.cacheService.getOperatorCache();
    String _name = stream.getAttributes().getName();
    String _plus = (this.VIEW + _name);
    return _operatorCache.registerOperator(_plus, operator);
  }
  
  private CharSequence parseCreateStreamFile(final CreateChannelFormatViaFile file) {
    Map<String, String> args = CollectionLiterals.<String, String>newHashMap();
    args.put("source", file.getAttributes().getName());
    args.put("wrapper", "GenericPull");
    args.put("protocol", file.getType());
    args.put("transport", "File");
    args.put("datahandler", "Tuple");
    args.put("schema", this.extractSchema(file.getAttributes()).toString());
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("[\'filename\',\'");
    String _filename = file.getFilename();
    _builder.append(_filename);
    _builder.append("\'],[\'delimiter\',\';\'],[\'textDelimiter\',\"\'\"]");
    args.put("options", _builder.toString());
    String operator = this.builder.build(AccessAO.class, args);
    OperatorCache _operatorCache = this.cacheService.getOperatorCache();
    String _name = file.getAttributes().getName();
    String _plus = (this.VIEW + _name);
    return _operatorCache.registerOperator(_plus, operator);
  }
  
  private CharSequence parseCreateStreamChannel(final CreateChannelFrameworkViaPort channel) {
    Map<String, String> args = CollectionLiterals.<String, String>newHashMap();
    args.put("source", channel.getAttributes().getName());
    args.put("wrapper", "GenericPush");
    args.put("protocol", "SizeByteBuffer");
    args.put("transport", "NonBlockingTcp");
    args.put("datahandler", "Tuple");
    args.put("schema", this.extractSchema(channel.getAttributes()).toString());
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("[\'port\',\'");
    int _port = channel.getPort();
    _builder.append(_port);
    _builder.append("\'],[\'host\', \'");
    String _host = channel.getHost();
    _builder.append(_host);
    _builder.append("\']");
    args.put("options", _builder.toString());
    String operator = this.builder.build(AccessAO.class, args);
    OperatorCache _operatorCache = this.cacheService.getOperatorCache();
    String _name = channel.getAttributes().getName();
    String _plus = (this.VIEW + _name);
    return _operatorCache.registerOperator(_plus, operator);
  }
  
  private String parseStreamTo(final StreamTo query) {
    String _xblockexpression = null;
    {
      String lastOperator = "";
      String sink = "";
      Map<String, String> sinks = this.cacheService.getOperatorCache().getSinks();
      Set<String> _keySet = sinks.keySet();
      String _name = query.getName();
      String _plus = (this.VIEW + _name);
      boolean _contains = _keySet.contains(_plus);
      if (_contains) {
        String _name_1 = query.getName();
        String _plus_1 = (this.VIEW + _name_1);
        sink = sinks.get(_plus_1);
      } else {
        boolean _contains_1 = sinks.keySet().contains(query.getName());
        if (_contains_1) {
          sink = sinks.get(query.getName());
        }
      }
      InnerSelect2 _statement = query.getStatement();
      boolean _tripleNotEquals = (_statement != null);
      if (_tripleNotEquals) {
        SimpleSelect _select = query.getStatement().getSelect();
        this.selectParser.parse(((SimpleSelect) _select));
        lastOperator = this.cacheService.getOperatorCache().lastOperatorId();
      } else {
        lastOperator = query.getInputname();
      }
      String _xifexpression = null;
      boolean _notEquals = (!Objects.equal(sink, ""));
      if (_notEquals) {
        String _xblockexpression_1 = null;
        {
          sink = sink.replace("--INPUT--", lastOperator);
          boolean _isBACKUPState = this.cacheService.getOperatorCache().isBACKUPState();
          if (_isBACKUPState) {
            this.cacheService.getOperatorCache().changeToBACKUP();
          }
          sinks.remove(query.getName());
          _xblockexpression_1 = this.cacheService.getOperatorCache().registerOperator(sink, query.getName());
        }
        _xifexpression = _xblockexpression_1;
      } else {
        this.cacheService.getOperatorCache().getStreamTo().put(query.getName(), query.getName());
        this.cacheService.getOperatorCache().changeToBACKUP();
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  private Object[] buildAggregateOP(final Collection<SelectExpression> aggAttr, final List<Attribute> orderAttr, final CharSequence input) {
    String argsstr = "";
    List<String> args = CollectionLiterals.<String>newArrayList();
    List<String> aliases = CollectionLiterals.<String>newArrayList();
    String mapName = "";
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(aggAttr, Object.class)).length); i++) {
      {
        EObject _value = ((SelectExpression[])Conversions.unwrapArray(aggAttr, SelectExpression.class))[i].getExpressions().get(0).getValue();
        Function aggregation = ((Function) _value);
        String attributename = "";
        String datatype = "";
        EObject _value_1 = aggregation.getValue();
        EList<ExpressionComponent> components = ((SelectExpression) _value_1).getExpressions();
        int _size = components.size();
        boolean _equals = (_size == 1);
        if (_equals) {
          EObject comp = components.get(0).getValue();
          boolean _matched = false;
          if (comp instanceof Attribute) {
            _matched=true;
            attributename = this.attributeParser.parse(((Attribute)comp).getName());
            datatype = this.getDataTypeFrom(attributename);
          }
          if (!_matched) {
            if (comp instanceof Starthing) {
              _matched=true;
              attributename = "*";
            }
          }
        } else {
        }
        args.add(aggregation.getName());
        args.add(attributename);
        String alias = "";
        Alias _alias = ((SelectExpression[])Conversions.unwrapArray(aggAttr, SelectExpression.class))[i].getAlias();
        boolean _tripleNotEquals = (_alias != null);
        if (_tripleNotEquals) {
          alias = ((SelectExpression[])Conversions.unwrapArray(aggAttr, SelectExpression.class))[i].getAlias().getName();
        } else {
          alias = this.utilityService.getAggregationName(aggregation.getName());
        }
        args.add(alias);
        aliases.add(alias);
        boolean _notEquals = (!Objects.equal(datatype, ""));
        if (_notEquals) {
          args.add(datatype);
        }
        this.utilityService.addAggregationAttribute(((SelectExpression[])Conversions.unwrapArray(aggAttr, SelectExpression.class))[i], alias);
        args.add(",");
        String _argsstr = argsstr;
        final List<String> _converted_args = (List<String>)args;
        String _generateKeyValueString = this.utilityService.generateKeyValueString(((String[])Conversions.unwrapArray(_converted_args, String.class)));
        argsstr = (_argsstr + _generateKeyValueString);
        int _length = ((Object[])Conversions.unwrapArray(aggAttr, Object.class)).length;
        int _minus = (_length - 1);
        boolean _notEquals_1 = (i != _minus);
        if (_notEquals_1) {
          String _argsstr_1 = argsstr;
          argsstr = (_argsstr_1 + ",");
        }
        args.clear();
      }
    }
    String groupby = "";
    boolean _isEmpty = orderAttr.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      String _groupby = groupby;
      final java.util.function.Function<Attribute, String> _function = (Attribute e) -> {
        return this.attributeParser.parse(e.getName(), null);
      };
      String _generateListString = this.utilityService.generateListString(orderAttr.stream().<String>map(_function).collect(Collectors.<String>toList()));
      groupby = (_groupby + _generateListString);
    }
    Pair<String, String> _mappedTo = Pair.<String, String>of("aggregations", argsstr);
    String _xifexpression = null;
    boolean _notEquals = (!Objects.equal(groupby, ""));
    if (_notEquals) {
      _xifexpression = groupby;
    } else {
      _xifexpression = null;
    }
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("group_by", _xifexpression);
    String _xifexpression_1 = null;
    boolean _notEquals_1 = (!Objects.equal(mapName, ""));
    if (_notEquals_1) {
      _xifexpression_1 = mapName;
    } else {
      _xifexpression_1 = input.toString();
    }
    Pair<String, String> _mappedTo_2 = Pair.<String, String>of("input", _xifexpression_1);
    String _build = this.builder.build(AggregateAO.class, 
      CollectionLiterals.<String, String>newHashMap(_mappedTo, _mappedTo_1, _mappedTo_2));
    return new Object[] { aliases, _build };
  }
  
  private Object[] buildAggregateOP(final Collection<SelectExpression> list, final List<Attribute> list2, final List<Source> srcs) {
    return this.buildAggregateOP(list, list2, this.joinParser.buildJoin(srcs));
  }
  
  private CharSequence buildCreate1(final String type, final AccessFramework pars, final SchemaDefinition schema, final String name) {
    Class<?> t = null;
    String input = "--INPUT--";
    boolean _equals = type.equals("ACCESS");
    if (_equals) {
      t = AccessAO.class;
    } else {
      t = SenderAO.class;
    }
    Map<String, String> streamTo = this.cacheService.getOperatorCache().getStreamTo();
    boolean _contains = streamTo.keySet().contains(name);
    if (_contains) {
      input = streamTo.get(name);
    }
    Map<String, String> argss = CollectionLiterals.<String, String>newHashMap();
    boolean _equals_1 = t.equals(AccessAO.class);
    if (_equals_1) {
      argss.put("source", name);
    } else {
      argss.put("sink", name);
    }
    argss.put("wrapper", pars.getWrapper());
    argss.put("protocol", pars.getProtocol());
    argss.put("transport", pars.getTransport());
    argss.put("datahandler", pars.getDatahandler());
    String _xifexpression = null;
    boolean _containsKey = argss.containsKey("source");
    if (_containsKey) {
      _xifexpression = this.extractSchema(schema).toString();
    } else {
      _xifexpression = null;
    }
    argss.put("schema", _xifexpression);
    argss.put("options", this.utilityService.generateKeyValueString(pars.getKeys(), pars.getValues(), ","));
    String _xifexpression_1 = null;
    boolean _containsKey_1 = argss.containsKey("sink");
    if (_containsKey_1) {
      _xifexpression_1 = input;
    } else {
      _xifexpression_1 = null;
    }
    argss.put("input", _xifexpression_1);
    return this.builder.build(t, argss);
  }
  
  private boolean isSame(final String attribute1, final String attribute2) {
    String name1 = attribute1;
    String name2 = attribute2;
    String source1 = "";
    String source2 = "";
    boolean _contains = name1.contains(".");
    if (_contains) {
      String[] split = name1.split("\\.");
      name1 = split[1];
      source1 = split[0];
    }
    boolean _contains_1 = name2.contains(".");
    if (_contains_1) {
      String[] split_1 = name2.split("\\.");
      name2 = split_1[1];
      source2 = split_1[0];
    }
    boolean _contains_2 = this.utilityService.getAttributeAliasesAsList().contains(name1);
    if (_contains_2) {
      name1 = this.utilityService.getAttributeFromAlias(name1).attributename;
    }
    boolean _contains_3 = this.utilityService.getAttributeAliasesAsList().contains(name2);
    if (_contains_3) {
      name2 = this.utilityService.getAttributeFromAlias(name2).attributename;
    }
    boolean _contains_4 = this.utilityService.getSourceAliasesAsList().contains(source1);
    if (_contains_4) {
      source1 = this.utilityService.getSourceNameFromAlias(source1);
    }
    boolean _contains_5 = this.utilityService.getSourceAliasesAsList().contains(source2);
    if (_contains_5) {
      source2 = this.utilityService.getSourceNameFromAlias(source2);
    }
    boolean _equals = name1.equals(name2);
    if (_equals) {
      if ((Objects.equal(source1, "") || Objects.equal(source2, ""))) {
        return true;
      } else {
        boolean _equals_1 = source1.equals(source2);
        if (_equals_1) {
          return true;
        }
      }
    }
    return false;
  }
  
  public boolean containsAttribute(final List<Attribute> list, final Attribute attribute) {
    for (final Attribute element : list) {
      boolean _isSame = this.isSame(attribute.getName(), element.getName());
      if (_isSame) {
        return true;
      }
    }
    return false;
  }
  
  public boolean isSelectAll(final SimpleSelect select) {
    EList<SelectArgument> _arguments = select.getArguments();
    for (final SelectArgument a : _arguments) {
      Attribute _attribute = a.getAttribute();
      boolean _tripleNotEquals = (_attribute != null);
      if (_tripleNotEquals) {
        return false;
      }
    }
    return true;
  }
  
  public List<SelectExpression> extractAggregationsFromArgument(final List<SelectArgument> args) {
    List<SelectExpression> list = CollectionLiterals.<SelectExpression>newArrayList();
    for (final SelectArgument a : args) {
      SelectExpression _expression = a.getExpression();
      boolean _tripleNotEquals = (_expression != null);
      if (_tripleNotEquals) {
        int _size = a.getExpression().getExpressions().size();
        boolean _equals = (_size == 1);
        if (_equals) {
          ExpressionComponent aggregation = a.getExpression().getExpressions().get(0);
          EObject function = aggregation.getValue();
          if ((function instanceof Function)) {
            boolean _isAggregateFunctionName = this.utilityService.isAggregateFunctionName(((Function)function).getName());
            if (_isAggregateFunctionName) {
              list.add(a.getExpression());
            }
          }
        }
      }
    }
    return list;
  }
  
  public Collection<SelectExpression> extractSelectExpressionsFromArgument(final List<SelectArgument> args) {
    Collection<SelectExpression> list = CollectionLiterals.<SelectExpression>newArrayList();
    for (final SelectArgument a : args) {
      SelectExpression _expression = a.getExpression();
      boolean _tripleNotEquals = (_expression != null);
      if (_tripleNotEquals) {
        int _size = a.getExpression().getExpressions().size();
        boolean _equals = (_size == 1);
        if (_equals) {
          ExpressionComponent aggregation = a.getExpression().getExpressions().get(0);
          EObject function = aggregation.getValue();
          if ((function instanceof Function)) {
            SelectExpression _expression_1 = a.getExpression();
            boolean _isMEPFunctionMame = this.utilityService.isMEPFunctionMame(((Function)function).getName(), this.selectParser.parseExpression(((SelectExpression) _expression_1)).toString());
            if (_isMEPFunctionMame) {
              list.add(a.getExpression());
            }
          } else {
            list.add(a.getExpression());
          }
        } else {
          list.add(a.getExpression());
        }
      }
    }
    return list;
  }
  
  public void setSchema(final List<SourceStruct> schemata) {
    this.utilityService.setSourcesStructs(schemata);
  }
  
  public String getDataTypeFrom(final Attribute attribute) {
    return this.getDataTypeFrom(attribute.getName());
  }
  
  public String getDataTypeFrom(final String attribute) {
    String attributename = attribute;
    String sourcename = "";
    boolean _contains = attribute.contains(".");
    if (_contains) {
      String[] splitted = attribute.split("\\.");
      boolean _isAttributeAlias = this.utilityService.isAttributeAlias(attributename);
      if (_isAttributeAlias) {
        String sourceFromAlias = this.utilityService.getSourceNameFromAlias(attributename);
        boolean _isSourceAlias = this.utilityService.isSourceAlias(sourceFromAlias);
        if (_isSourceAlias) {
          sourceFromAlias = this.utilityService.getSourceNameFromAlias(sourceFromAlias);
        }
        attributename = this.utilityService.getAttributenameFromAlias(attributename);
        sourcename = sourceFromAlias;
        Collection<AttributeStruct> _attributeList = this.utilityService.getSource(sourcename).getAttributeList();
        for (final AttributeStruct attr : _attributeList) {
          boolean _equals = attr.attributename.equals(attributename);
          if (_equals) {
            return attr.datatype;
          }
        }
      }
      sourcename = splitted[0];
      attributename = splitted[1];
      boolean _isAttributeAlias_1 = this.utilityService.isAttributeAlias(attributename);
      if (_isAttributeAlias_1) {
        attributename = this.utilityService.getAttributenameFromAlias(attributename);
      }
      boolean _isSourceAlias_1 = this.utilityService.isSourceAlias(sourcename);
      if (_isSourceAlias_1) {
        sourcename = this.utilityService.getSourceNameFromAlias(sourcename);
      }
      try {
        Collection<AttributeStruct> _attributeList_1 = this.utilityService.getSource(sourcename).getAttributeList();
        for (final AttributeStruct attr_1 : _attributeList_1) {
          boolean _equals_1 = attr_1.attributename.equals(attributename);
          if (_equals_1) {
            return attr_1.datatype;
          }
        }
      } catch (final Throwable _t) {
        if (_t instanceof IllegalArgumentException) {
          final IllegalArgumentException e = (IllegalArgumentException)_t;
          Collection<String> _get = this.utilityService.getSubQuerySources().get(sourcename);
          for (final String attr_2 : _get) {
            boolean _equals_2 = this.attributeParser.parse(attr_2).equals(attributename);
            if (_equals_2) {
              return this.utilityService.getAttribute(attr_2).getDatatype();
            }
          }
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
    } else {
      boolean _isAttributeAlias_2 = this.utilityService.isAttributeAlias(attributename);
      if (_isAttributeAlias_2) {
        String sourceFromAlias_1 = this.utilityService.getSourceNameFromAlias(attributename);
        boolean _isSourceAlias_2 = this.utilityService.isSourceAlias(sourceFromAlias_1);
        if (_isSourceAlias_2) {
          sourceFromAlias_1 = this.utilityService.getSourceNameFromAlias(sourceFromAlias_1);
        }
        attributename = this.utilityService.getAttributenameFromAlias(attributename);
        if ((attributename == null)) {
          attributename = attribute;
        }
        Collection<AttributeStruct> _attributeList_2 = this.utilityService.getSource(sourceFromAlias_1).getAttributeList();
        for (final AttributeStruct attr_3 : _attributeList_2) {
          boolean _equals_3 = attr_3.attributename.equals(attributename);
          if (_equals_3) {
            return attr_3.datatype;
          }
        }
      }
    }
    return "Double";
  }
  
  public Map<String, String> setDatabaseConnections(final Map<String, String> connections) {
    return this.databaseConnections = connections;
  }
}
