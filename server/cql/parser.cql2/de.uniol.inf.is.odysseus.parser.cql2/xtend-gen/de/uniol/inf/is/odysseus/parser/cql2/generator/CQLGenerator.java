/**
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.cql2.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.AccessAO;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.AggregateAO;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.ElementWindowAO;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.ExistenceAO;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.MapAO;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.RenameAO;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.SelectAO;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.SenderAO;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.TimeWindowAO;
import de.uniol.inf.is.odysseus.mep.FunctionStore;
import de.uniol.inf.is.odysseus.mep.MEP;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.AccessFramework;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Alias;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Attribute;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.BoolConstant;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ComplexPredicate;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ComplexSelect;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Create;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateAccessFramework;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateChannelFormatViaFile;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateChannelFrameworkViaPort;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateDatabaseSink;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateDatabaseStream;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateView;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Expression;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ExpressionComponent;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ExpressionsModel;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.FloatConstant;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Function;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.InnerSelect2;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.IntConstant;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Matrix;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.NestedSource;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Query;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SchemaDefinition;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SelectArgument;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SelectExpression;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SimpleSelect;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SimpleSource;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Source;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Starthing;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.StreamTo;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.StringConstant;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Time;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.TimebasedWindow;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.TuplebasedWindow;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Vector;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.WindowOperator;
import de.uniol.inf.is.odysseus.parser.cql2.generator.AttributeStruct;
import de.uniol.inf.is.odysseus.parser.cql2.generator.CQLGeneratorUtil;
import de.uniol.inf.is.odysseus.parser.cql2.generator.CQLPredicateParser;
import de.uniol.inf.is.odysseus.parser.cql2.generator.SourceStruct;
import de.uniol.inf.is.odysseus.parser.cql2.generator.builder.PQLOperatorBuilder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Predicate;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGenerator2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Generates PQL text from a CQL text.
 */
@SuppressWarnings("all")
public class CQLGenerator implements IGenerator2 {
  public enum Operator {
    MAP,
    
    AGGREGATE;
  }
  
  private final Logger log = LoggerFactory.getLogger(CQLGenerator.class);
  
  private Map<String, String> registry_Operators = CollectionLiterals.<String, String>newHashMap();
  
  private Map<String, String> registry_StreamTo = CollectionLiterals.<String, String>newHashMap();
  
  private Map<String, String> registry_Sinks = CollectionLiterals.<String, String>newHashMap();
  
  private Map<String, String> registryBackUp_Operators = CollectionLiterals.<String, String>newHashMap();
  
  private Map<String, List<String>> registry_NestedSelects = CollectionLiterals.<String, List<String>>newHashMap();
  
  private Map<String, List<String>> registry_RenamedAttributes = CollectionLiterals.<String, List<String>>newHashMap();
  
  private List<String> registryBackUp_OperatorNames = CollectionLiterals.<String>newArrayList();
  
  private List<String> registry_OperatorNames = CollectionLiterals.<String>newArrayList();
  
  /**
   * Contains string representations of all attributes mapped by their corresponding sources.
   */
  private int operatorCounter = 0;
  
  private int aggregationCounter = 0;
  
  private int expressionCounter = 0;
  
  private int selfJoinCounter = 1;
  
  private String predicateString = null;
  
  private String expressionString = null;
  
  private boolean firstJoinInQuery = true;
  
  private PQLOperatorBuilder builder = new PQLOperatorBuilder();
  
  private Map<String, String> databaseConnections = CollectionLiterals.<String, String>newHashMap();
  
  private List<String> querySources = CollectionLiterals.<String>newArrayList();
  
  private List<SimpleSelect> registry_SimpleSelect = CollectionLiterals.<SimpleSelect>newArrayList();
  
  private final String OP = "operator_";
  
  private final String ASSIG1 = "=";
  
  private final String ASSIG2 = ":=";
  
  private CQLPredicateParser predicateParser = new CQLPredicateParser(this);
  
  public void clear() {
    this.predicateParser.clear();
    this.registry_OperatorNames.clear();
    this.registry_Operators.clear();
    this.registry_NestedSelects.clear();
    this.registry_RenamedAttributes.clear();
    this.registry_SubQueries.clear();
    this.registry_SimpleSelect.clear();
    this.registry_existenceOperators.clear();
    this.renameAliases.clear();
    this.operatorCounter = 0;
    this.aggregationCounter = 0;
    this.expressionCounter = 0;
    this.selfJoinCounter = 1;
    this.predicateString = null;
    this.expressionString = null;
    this.firstJoinInQuery = true;
    this.querySources = CollectionLiterals.<String>newArrayList();
    CQLGeneratorUtil.clear();
  }
  
  @Override
  public void afterGenerate(final Resource input, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    this.clear();
  }
  
  @Override
  public void beforeGenerate(final Resource input, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    this.clear();
  }
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    CQLGeneratorUtil.getInstance(this);
    fsa.generateFile(("" + Integer.valueOf(1)), this.parseStatement(((Query[])Conversions.unwrapArray(Iterables.<Query>filter(IteratorExtensions.<EObject>toIterable(resource.getAllContents()), Query.class), Query.class))[0]));
  }
  
  public CharSequence parseStatement(final Query stmt) {
    EObject _type = stmt.getType();
    if ((_type instanceof ComplexSelect)) {
      EObject _type_1 = stmt.getType();
      ComplexSelect complexStatement = ((ComplexSelect) _type_1);
      String _operation = complexStatement.getOperation();
      boolean _tripleNotEquals = (_operation != null);
      if (_tripleNotEquals) {
        this.parseComplexSelect(complexStatement.getLeft(), complexStatement.getRight(), complexStatement.getOperation());
      } else {
        this.parseSimpleSelect(complexStatement.getLeft());
      }
    } else {
      EObject _type_2 = stmt.getType();
      if ((_type_2 instanceof Create)) {
        EObject _type_3 = stmt.getType();
        this.parseCreate(((Create) _type_3));
      } else {
        EObject _type_4 = stmt.getType();
        if ((_type_4 instanceof StreamTo)) {
          EObject _type_5 = stmt.getType();
          this.parseStreamTo(((StreamTo) _type_5));
        }
      }
    }
    String model = this.createModel();
    return model;
  }
  
  public CharSequence parseCreate(final Create statement) {
    CharSequence _xifexpression = null;
    EObject _create = statement.getCreate();
    if ((_create instanceof CreateView)) {
      EObject _create_1 = statement.getCreate();
      _xifexpression = this.parseCreateView(((CreateView) _create_1));
    } else {
      CharSequence _xifexpression_1 = null;
      EObject _create_2 = statement.getCreate();
      if ((_create_2 instanceof CreateAccessFramework)) {
        EObject _create_3 = statement.getCreate();
        _xifexpression_1 = this.parseCreateAccessFramework(((CreateAccessFramework) _create_3), statement.getType());
      } else {
        CharSequence _xifexpression_2 = null;
        EObject _create_4 = statement.getCreate();
        if ((_create_4 instanceof CreateChannelFormatViaFile)) {
          EObject _create_5 = statement.getCreate();
          _xifexpression_2 = this.parseCreateStreamFile(((CreateChannelFormatViaFile) _create_5));
        } else {
          CharSequence _xifexpression_3 = null;
          EObject _create_6 = statement.getCreate();
          if ((_create_6 instanceof CreateChannelFrameworkViaPort)) {
            EObject _create_7 = statement.getCreate();
            _xifexpression_3 = this.parseCreateStreamChannel(((CreateChannelFrameworkViaPort) _create_7));
          } else {
            String _xifexpression_4 = null;
            EObject _create_8 = statement.getCreate();
            if ((_create_8 instanceof CreateDatabaseStream)) {
              EObject _create_9 = statement.getCreate();
              _xifexpression_4 = this.parseCreateDatabaseStream(((CreateDatabaseStream) _create_9));
            } else {
              String _xifexpression_5 = null;
              EObject _create_10 = statement.getCreate();
              if ((_create_10 instanceof CreateDatabaseSink)) {
                EObject _create_11 = statement.getCreate();
                _xifexpression_5 = this.parseCreateDatabaseSink(((CreateDatabaseSink) _create_11));
              }
              _xifexpression_4 = _xifexpression_5;
            }
            _xifexpression_3 = _xifexpression_4;
          }
          _xifexpression_2 = _xifexpression_3;
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public String createModel() {
    String model = "";
    for (int i = 0; (i < this.registry_OperatorNames.size()); i++) {
      {
        boolean _contains = this.registry_OperatorNames.get(i).contains(this.VIEW);
        if (_contains) {
          String _model = model;
          String _replace = this.registry_OperatorNames.get(i).replace(this.VIEW, "");
          String _plus = (_replace + this.ASSIG2);
          String _get = this.registry_Operators.get(this.registry_OperatorNames.get(i));
          String _plus_1 = (_plus + _get);
          CharSequence _formatOutputString = this.formatOutputString(_plus_1);
          String _property = System.getProperty("line.separator");
          String _plus_2 = (_formatOutputString + _property);
          model = (_model + _plus_2);
        } else {
          String _model_1 = model;
          String _get_1 = this.registry_OperatorNames.get(i);
          String _plus_3 = (_get_1 + this.ASSIG1);
          String _get_2 = this.registry_Operators.get(this.registry_OperatorNames.get(i));
          String _plus_4 = (_plus_3 + _get_2);
          CharSequence _formatOutputString_1 = this.formatOutputString(_plus_4);
          String _property_1 = System.getProperty("line.separator");
          String _plus_5 = (_formatOutputString_1 + _property_1);
          model = (_model_1 + _plus_5);
        }
        Set<Map.Entry<String, List<String>>> _entrySet = this.registry_NestedSelects.entrySet();
        for (final Map.Entry<String, List<String>> entry : _entrySet) {
          boolean _equals = entry.getKey().equals(this.registry_OperatorNames.get(i));
          if (_equals) {
            List<String> l = entry.getValue();
            for (final String alias : l) {
              String _model_2 = model;
              String _key = entry.getKey();
              String _plus_6 = ((alias + this.ASSIG1) + _key);
              CharSequence _formatOutputString_2 = this.formatOutputString(_plus_6);
              String _property_2 = System.getProperty("line.separator");
              String _plus_7 = (_formatOutputString_2 + _property_2);
              model = (_model_2 + _plus_7);
            }
          }
        }
      }
    }
    return model;
  }
  
  public CharSequence prepareParsingSelect(final SimpleSelect select) {
    try {
      try {
        boolean _contains = this.registry_SimpleSelect.contains(select);
        boolean _not = (!_contains);
        if (_not) {
          List<NestedSource> subQueries = this.registerAllSource(select);
          for (final NestedSource subQuery : subQueries) {
            {
              this.prepareParsingSelect(subQuery.getStatement().getSelect());
              CQLGeneratorUtil.getSubQuerySources().put(subQuery.getAlias().getName(), 
                CQLGeneratorUtil.getQueryAttributes(subQuery.getStatement().getSelect()).keySet());
            }
          }
          Map<String, List<String>> attributes2 = CollectionLiterals.<String, List<String>>newHashMap();
          attributes2 = CQLGeneratorUtil.getSelectedAttributes(select, attributes2);
          List<SelectExpression> aggregations = this.extractAggregationsFromArgument(select.getArguments());
          List<SelectExpression> expressions = this.extractSelectExpressionsFromArgument(select.getArguments());
          if ((aggregations != null)) {
            CQLGeneratorUtil.addQueryAggregations(select, aggregations);
          }
          if ((expressions != null)) {
            CQLGeneratorUtil.getQueryExpressions().put(select, expressions);
          }
          if ((attributes2 != null)) {
            CQLGeneratorUtil.addQueryAttributes(select, attributes2);
          }
          this.registry_SimpleSelect.add(select);
          return null;
        }
      } catch (final Throwable _t) {
        if (_t instanceof Exception) {
          final Exception e = (Exception)_t;
          String _message = e.getMessage();
          String _plus = ("error occurred while parsing select: " + _message);
          this.log.error(_plus);
          throw e;
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      return null;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public List<NestedSource> registerAllSource(final SimpleSelect select) {
    ArrayList<NestedSource> list = CollectionLiterals.<NestedSource>newArrayList();
    EList<Source> _sources = select.getSources();
    for (final Source source : _sources) {
      {
        String name = "";
        if ((source instanceof SimpleSource)) {
          boolean _contains = this.querySources.contains(name = ((SimpleSource) source).getName());
          boolean _not = (!_contains);
          if (_not) {
            this.querySources.add(name);
          }
          if (((((SimpleSource)source).getAlias() != null) && (!CQLGeneratorUtil.getSource(source).aliases.contains(((SimpleSource)source).getAlias().getName())))) {
            this.registerSourceAlias(source);
          }
        } else {
          if ((source instanceof NestedSource)) {
            list.add(((NestedSource)source));
          }
        }
      }
    }
    return list;
  }
  
  private CharSequence parseComplexSelect(final SimpleSelect left, final SimpleSelect right, final String operator) {
    this.parseSimpleSelect(left);
    String rightSelectOperatorName = this.getLastOperator();
    this.registry_SimpleSelect.clear();
    this.parseSimpleSelect(right);
    String leftSelectOperatorName = this.getLastOperator();
    return this.registerOperator((((((operator + "(") + rightSelectOperatorName) + ",") + leftSelectOperatorName) + ")"));
  }
  
  private Map<SimpleSelect, String> registry_SubQueries = CollectionLiterals.<SimpleSelect, String>newHashMap();
  
  public void parseSimpleSelect(final SimpleSelect stmt) {
    this.prepareParsingSelect(stmt);
    List<SimpleSelect> subQueries = CollectionLiterals.<SimpleSelect>newArrayList(((SimpleSelect[])Conversions.unwrapArray(this.registry_SimpleSelect, SimpleSelect.class)));
    CharSequence result = null;
    this.firstJoinInQuery = true;
    this.expressionCounter = 0;
    this.aggregationCounter = 0;
    this.expressionString = null;
    this.registry_RenamedAttributes.clear();
    for (final SimpleSelect subQuery : subQueries) {
      {
        ExpressionsModel _predicates = subQuery.getPredicates();
        boolean _tripleEquals = (null == _predicates);
        if (_tripleEquals) {
          ExpressionsModel _having = subQuery.getHaving();
          boolean _tripleNotEquals = (_having != null);
          if (_tripleNotEquals) {
            result = this.parseSelectWithPredicate(subQuery);
          } else {
            result = this.parseSelectWithoutPredicate(subQuery);
          }
        } else {
          result = this.parseSelectWithPredicate(subQuery);
        }
        this.registry_SubQueries.put(subQuery, result.toString());
        String _distinct = stmt.getDistinct();
        boolean _tripleNotEquals_1 = (_distinct != null);
        if (_tripleNotEquals_1) {
          String operator = this.registry_Operators.get(this.getLastOperator());
          operator = (("DISTINCT(" + operator) + ")");
          this.registry_Operators.put(result.toString(), operator);
        }
      }
    }
  }
  
  private String parseAdditionalOperator(final CQLGenerator.Operator operator, final SimpleSelect select) {
    Object[] result = null;
    String operatorName = null;
    if (operator != null) {
      switch (operator) {
        case MAP:
          List<SelectExpression> expressions = CQLGeneratorUtil.getQueryExpressions().get(select);
          if (((expressions != null) && (!expressions.isEmpty()))) {
            result = this.buildMapOperator(expressions);
            operatorName = result[1].toString();
          }
          break;
        case AGGREGATE:
          List<SelectExpression> aggregations = CQLGeneratorUtil.getQueryAggregations(select);
          if (((aggregations != null) && (!aggregations.isEmpty()))) {
            result = this.buildAggregateOP(aggregations, select.getOrder(), select.getSources());
            operatorName = this.registerOperator(result[1].toString());
          }
          break;
        default:
          break;
      }
    }
    return operatorName;
  }
  
  public CharSequence parseSelectWithoutPredicate(final SimpleSelect select) {
    String projectInput = null;
    String operator1 = this.parseAdditionalOperator(CQLGenerator.Operator.MAP, select);
    String operator2 = this.parseAdditionalOperator(CQLGenerator.Operator.AGGREGATE, select);
    if ((((operator1 == null) && (operator2 == null)) && select.getArguments().isEmpty())) {
      projectInput = this.buildJoin(select.getSources()).toString();
      int _size = select.getSources().size();
      boolean _greaterThan = (_size > 1);
      if (_greaterThan) {
        return this.registerOperator(projectInput);
      } else {
        return this.registerOperator(this.buildProjection(select, projectInput));
      }
    } else {
      projectInput = this.buildInput2(select, operator1, operator2);
      return this.registerOperator(this.buildProjection(select, projectInput));
    }
  }
  
  public CharSequence parseSelectWithPredicate(final SimpleSelect stmt) {
    List<Expression> predicates = CollectionLiterals.<Expression>newArrayList();
    List<Source> sources = CollectionLiterals.<Source>newArrayList();
    ExpressionsModel _predicates = stmt.getPredicates();
    boolean _tripleNotEquals = (_predicates != null);
    if (_tripleNotEquals) {
      predicates.add(0, stmt.getPredicates().getElements().get(0));
      List<ComplexPredicate> complexPredicates = EcoreUtil2.<ComplexPredicate>getAllContentsOfType(stmt.getPredicates(), ComplexPredicate.class);
      if ((((complexPredicates != null) && (!complexPredicates.isEmpty())) && (complexPredicates.size() > 1))) {
        throw new IllegalArgumentException("queries with more then one complex predicates are not supported");
      }
    }
    ExpressionsModel _having = stmt.getHaving();
    boolean _tripleNotEquals_1 = (_having != null);
    if (_tripleNotEquals_1) {
      predicates.add(0, stmt.getHaving().getElements().get(0));
    }
    sources.addAll(stmt.getSources());
    String operator1 = this.parseAdditionalOperator(CQLGenerator.Operator.MAP, stmt);
    String operator2 = this.parseAdditionalOperator(CQLGenerator.Operator.AGGREGATE, stmt);
    this.predicateParser.clear();
    this.predicateParser.parse(predicates);
    String selectInput = this.buildInput2(stmt, operator1, operator2).toString();
    String predicate = this.predicateParser.parsePredicateString(this.predicateParser.getPredicateStringList());
    String select = "";
    boolean _equals = predicate.equals("");
    boolean _not = (!_equals);
    if (_not) {
      Pair<String, String> _mappedTo = Pair.<String, String>of("predicate", predicate);
      Pair<String, String> _mappedTo_1 = Pair.<String, String>of("input", selectInput);
      select = this.registerOperator(
        this.builder.build(SelectAO.class, CollectionLiterals.<String, String>newLinkedHashMap(_mappedTo, _mappedTo_1)));
    } else {
      Map<String, String> newArgs = this.registry_existenceOperators.get(0);
      String _get = newArgs.get("input");
      String _plus = (_get + ",");
      String _plus_1 = (_plus + selectInput);
      newArgs.put("input", _plus_1);
      this.registerOperator(this.builder.build(ExistenceAO.class, newArgs));
      String _lastOperator = this.getLastOperator();
      String _plus_2 = ("JOIN(" + _lastOperator);
      String _plus_3 = (_plus_2 + ",");
      String _plus_4 = (_plus_3 + selectInput);
      String _plus_5 = (_plus_4 + ")");
      return this.registerOperator(this.buildProjection(stmt, _plus_5));
    }
    this.registerExistenceOperator(selectInput, select);
    ArrayList<Attribute> attributes = CollectionLiterals.<Attribute>newArrayList();
    EList<SelectArgument> _arguments = stmt.getArguments();
    for (final SelectArgument arg : _arguments) {
      Attribute _attribute = arg.getAttribute();
      boolean _tripleNotEquals_2 = (_attribute != null);
      if (_tripleNotEquals_2) {
        attributes.add(arg.getAttribute());
      }
    }
    if ((((!this.checkIfSelectAll(attributes)) || (!CQLGeneratorUtil.getQueryAggregations(stmt).isEmpty())) || 
      (!CQLGeneratorUtil.getQueryExpressions().get(stmt).isEmpty()))) {
      return this.registerOperator(this.buildProjection(stmt, select));
    }
    return select;
  }
  
  private void registerExistenceOperator(final String selectInput, final String select) {
    boolean _isEmpty = this.registry_existenceOperators.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      boolean _equals = select.equals("");
      boolean _not_1 = (!_equals);
      if (_not_1) {
        for (final Map<String, String> args : this.registry_existenceOperators) {
          {
            Map<String, String> newArgs = args;
            String _get = args.get("input");
            String _plus = (_get + ",");
            String _plus_1 = (_plus + selectInput);
            newArgs.put("input", _plus_1);
            this.registerOperator(this.builder.build(ExistenceAO.class, newArgs));
          }
        }
        String t = this.registry_Operators.get(select);
        String _substring = t.substring(0, t.lastIndexOf("}"));
        String _plus = (_substring + "},");
        String _plus_1 = (_plus + "JOIN(");
        String _lastOperator = this.getLastOperator();
        String _plus_2 = (_plus_1 + _lastOperator);
        String _plus_3 = (_plus_2 + ",");
        String _plus_4 = (_plus_3 + selectInput);
        String _plus_5 = (_plus_4 + "))");
        this.registry_Operators.put(select, _plus_5);
        int _size = this.registry_OperatorNames.size();
        int _minus = (_size - 1);
        String lastOperator = this.registry_OperatorNames.get(_minus);
        this.registry_OperatorNames.remove(lastOperator);
        int _size_1 = this.registry_OperatorNames.size();
        int _minus_1 = (_size_1 - 1);
        this.registry_OperatorNames.add(_minus_1, lastOperator);
      } else {
        for (final Map<String, String> args_1 : this.registry_existenceOperators) {
          {
            Map<String, String> newArgs = args_1;
            String _get = args_1.get("input");
            String _plus_6 = (_get + ",");
            String _plus_7 = (_plus_6 + selectInput);
            newArgs.put("input", _plus_7);
            this.registerOperator(this.builder.build(ExistenceAO.class, newArgs));
          }
        }
      }
    }
  }
  
  public List<Map<String, String>> registry_existenceOperators = CollectionLiterals.<Map<String, String>>newArrayList();
  
  private CharSequence parseSelectExpression(final SelectExpression e) {
    String str = "";
    for (int i = 0; (i < e.getExpressions().size()); i++) {
      {
        ExpressionComponent _get = e.getExpressions().get(i);
        EObject component = ((ExpressionComponent) _get).getValue();
        boolean _matched = false;
        if (component instanceof Function) {
          _matched=true;
          String _str = str;
          String _name = ((Function)component).getName();
          String _plus = (_name + "(");
          EObject _value = ((Function)component).getValue();
          CharSequence _parseSelectExpression = this.parseSelectExpression(((SelectExpression) _value));
          String _plus_1 = (_plus + _parseSelectExpression);
          String _plus_2 = (_plus_1 + ")");
          str = (_str + _plus_2);
        }
        if (!_matched) {
          if (component instanceof Attribute) {
            _matched=true;
            String _str = str;
            String _attributename = this.getAttributename(((Attribute)component).getName());
            str = (_str + _attributename);
          }
        }
        if (!_matched) {
          if (component instanceof IntConstant) {
            _matched=true;
            String _str = str;
            int _value = ((IntConstant)component).getValue();
            String _plus = (Integer.valueOf(_value) + "");
            str = (_str + _plus);
          }
        }
        if (!_matched) {
          if (component instanceof FloatConstant) {
            _matched=true;
            String _str = str;
            String _value = ((FloatConstant)component).getValue();
            String _plus = (_value + "");
            str = (_str + _plus);
          }
        }
        if (!_matched) {
          if (component instanceof BoolConstant) {
            _matched=true;
            String _str = str;
            String _value = ((BoolConstant)component).getValue();
            String _plus = (_value + "");
            str = (_str + _plus);
          }
        }
        if (!_matched) {
          if (component instanceof StringConstant) {
            _matched=true;
            String _str = str;
            String _value = ((StringConstant)component).getValue();
            String _plus = ("\"" + _value);
            String _plus_1 = (_plus + "\"");
            str = (_str + _plus_1);
          }
        }
        if (!_matched) {
          if (component instanceof Vector) {
            _matched=true;
            String _str = str;
            String _value = ((Vector)component).getValue();
            str = (_str + _value);
          }
        }
        if (!_matched) {
          if (component instanceof Matrix) {
            _matched=true;
            String _str = str;
            String _value = ((Matrix)component).getValue();
            str = (_str + _value);
          }
        }
        int _size = e.getExpressions().size();
        int _minus = (_size - 1);
        boolean _notEquals = (i != _minus);
        if (_notEquals) {
          String _str = str;
          String _get_1 = e.getOperators().get(i);
          str = (_str + _get_1);
        }
      }
    }
    return str;
  }
  
  public CharSequence parseSelectExpressionType(final List<Object> components) {
    for (final Object comp : components) {
    }
    return "";
  }
  
  private final String VIEW = "VIEW_KEY_";
  
  private CharSequence parseCreateView(final CreateView view) {
    SimpleSelect _select = view.getSelect().getSelect();
    SimpleSelect select = ((SimpleSelect) _select);
    this.parseSimpleSelect(select);
    String lastOperator = this.getLastOperator();
    String operatorPlan = this.registry_Operators.get(this.getLastOperator());
    this.registry_Operators.remove(lastOperator);
    this.registry_OperatorNames.remove(lastOperator);
    String _name = view.getName();
    String _plus = (this.VIEW + _name);
    this.registry_Operators.put(_plus, operatorPlan);
    String _name_1 = view.getName();
    String _plus_1 = (this.VIEW + _name_1);
    this.registry_OperatorNames.add(_plus_1);
    return view.getName();
  }
  
  private final String SINK_INPUT_KEYWORD = "--INPUT--";
  
  private CharSequence parseCreateAccessFramework(final CreateAccessFramework create, final String type) {
    String operator = null;
    String _upperCase = type.toUpperCase();
    if (_upperCase != null) {
      switch (_upperCase) {
        case "STREAM":
          operator = "ACCESS";
          break;
        case "SINK":
          operator = "SENDER";
          break;
      }
    }
    operator = this.buildCreate1(operator, create.getPars(), create.getAttributes(), create.getAttributes().getName()).toString();
    boolean _equals = type.toUpperCase().equals("SINK");
    if (_equals) {
      boolean _contains = operator.contains(this.SINK_INPUT_KEYWORD);
      boolean _not = (!_contains);
      if (_not) {
        String _name = create.getAttributes().getName();
        String _plus = (this.VIEW + _name);
        return this.registerOperator(operator, _plus);
      } else {
        String _name_1 = create.getAttributes().getName();
        String _plus_1 = (this.VIEW + _name_1);
        this.registry_Sinks.put(_plus_1, operator);
      }
    } else {
      String _name_2 = create.getAttributes().getName();
      String _plus_2 = (this.VIEW + _name_2);
      this.registerOperator(operator, _plus_2);
    }
    return "";
  }
  
  private String parseCreateDatabaseSink(final CreateDatabaseSink sink) {
    String _xblockexpression = null;
    {
      Map<String, String> args = CollectionLiterals.<String, String>newHashMap();
      args.put("connection", sink.getDatabase());
      args.put("table", sink.getTable());
      String type = "";
      boolean _contains = this.databaseConnections.keySet().contains(sink.getDatabase());
      if (_contains) {
        type = this.databaseConnections.get(sink.getDatabase());
      } else {
        String _database = sink.getDatabase();
        String _plus = ("Database connection " + _database);
        String _plus_1 = (_plus + " could not be found");
        throw new IllegalArgumentException(_plus_1);
      }
      args.put("type", type);
      args.put("input", this.SINK_INPUT_KEYWORD);
      String _xifexpression = null;
      String _option = sink.getOption();
      boolean _tripleNotEquals = (_option != null);
      if (_tripleNotEquals) {
        String _xifexpression_1 = null;
        boolean _equals = sink.getOption().toUpperCase().equals("DROP");
        if (_equals) {
          _xifexpression_1 = args.put("drop", "true");
        } else {
          _xifexpression_1 = args.put("truncate", "true");
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  private CharSequence extractSchema(final SchemaDefinition schema) {
    ArrayList<String> attributenames = CollectionLiterals.<String>newArrayList();
    ArrayList<String> datatypes = CollectionLiterals.<String>newArrayList();
    for (int i = 0; (i < (schema.getArguments().size() - 1)); i = (i + 2)) {
      {
        attributenames.add(schema.getArguments().get(i));
        datatypes.add(schema.getArguments().get((i + 1)));
      }
    }
    return this.generateKeyValueString(attributenames, datatypes, ",");
  }
  
  private int getTimeInMilliseconds(final String time, final int value) {
    String _upperCase = time.toUpperCase();
    if (_upperCase != null) {
      switch (_upperCase) {
        case "MILLISECONDS":
        case "MILLISECOND":
          return value;
        case "SECONDS":
        case "SECOND":
          return (value * 1000);
        case "MINUTES":
        case "MINUTE":
          return (value * (60 * 1000));
        case "HOURS":
        case "HOUR":
          return (value * ((60 * 60) * 1000));
        case "DAYS":
        case "DAY":
          return (value * (((24 * 60) * 60) * 1000));
        case "WEEKS":
        case "WEEK":
          return (value * ((((7 * 24) * 60) * 60) * 1000));
        default:
          return 0;
      }
    } else {
      return 0;
    }
  }
  
  public String parseCreateDatabaseStream(final CreateDatabaseStream stream) {
    Map<String, String> args = CollectionLiterals.<String, String>newHashMap();
    args.put("connection", stream.getDatabase());
    args.put("table", stream.getTable());
    args.put("attributes", this.extractSchema(stream.getAttributes()).toString());
    String operator = "";
    String waitMillis = Integer.valueOf(this.getTimeInMilliseconds(stream.getUnit().getName(), stream.getSize())).toString();
    boolean _equals = waitMillis.equals("0.0");
    boolean _not = (!_equals);
    if (_not) {
      args.put("waiteach", waitMillis);
    }
    String _name = stream.getAttributes().getName();
    String _plus = (this.VIEW + _name);
    return this.registerOperator(operator, _plus);
  }
  
  private CharSequence parseCreateStreamFile(final CreateChannelFormatViaFile file) {
    Map<String, String> args = CollectionLiterals.<String, String>newHashMap();
    args.put("source", file.getAttributes().getName());
    args.put("wrapper", "GenericPull");
    args.put("protocol", file.getType());
    args.put("transport", "File");
    args.put("datahandler", "Tuple");
    args.put("schema", this.extractSchema(file.getAttributes()).toString());
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("[\'filename\',\'");
    String _filename = file.getFilename();
    _builder.append(_filename);
    _builder.append("\'],[\'delimiter\',\';\'],[\'textDelimiter\',\"\'\"]");
    args.put("options", _builder.toString());
    String operator = this.builder.build(AccessAO.class, args);
    String _name = file.getAttributes().getName();
    String _plus = (this.VIEW + _name);
    return this.registerOperator(operator, _plus);
  }
  
  private CharSequence parseCreateStreamChannel(final CreateChannelFrameworkViaPort channel) {
    Map<String, String> args = CollectionLiterals.<String, String>newHashMap();
    args.put("source", channel.getAttributes().getName());
    args.put("wrapper", "GenericPush");
    args.put("protocol", "SizeByteBuffer");
    args.put("transport", "NonBlockingTcp");
    args.put("datahandler", "Tuple");
    args.put("schema", this.extractSchema(channel.getAttributes()).toString());
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("[\'port\',\'");
    int _port = channel.getPort();
    _builder.append(_port);
    _builder.append("\'],[\'host\', \'");
    String _host = channel.getHost();
    _builder.append(_host);
    _builder.append("\']");
    args.put("options", _builder.toString());
    String operator = this.builder.build(AccessAO.class, args);
    String _name = channel.getAttributes().getName();
    String _plus = (this.VIEW + _name);
    return this.registerOperator(operator, _plus);
  }
  
  private String parseStreamTo(final StreamTo query) {
    String _xblockexpression = null;
    {
      String lastOperator = "";
      String sink = "";
      Set<String> _keySet = this.registry_Sinks.keySet();
      String _name = query.getName();
      String _plus = (this.VIEW + _name);
      boolean _contains = _keySet.contains(_plus);
      if (_contains) {
        String _name_1 = query.getName();
        String _plus_1 = (this.VIEW + _name_1);
        sink = this.registry_Sinks.get(_plus_1);
      } else {
        boolean _contains_1 = this.registry_Sinks.keySet().contains(query.getName());
        if (_contains_1) {
          sink = this.registry_Sinks.get(query.getName());
        }
      }
      InnerSelect2 _statement = query.getStatement();
      boolean _tripleNotEquals = (_statement != null);
      if (_tripleNotEquals) {
        SimpleSelect _select = query.getStatement().getSelect();
        this.parseSimpleSelect(((SimpleSelect) _select));
        lastOperator = this.getLastOperator();
      } else {
        lastOperator = query.getInputname();
      }
      String _xifexpression = null;
      boolean _notEquals = (!Objects.equal(sink, ""));
      if (_notEquals) {
        String _xblockexpression_1 = null;
        {
          sink = sink.replace("--INPUT--", lastOperator);
          boolean _isEmpty = this.registryBackUp_Operators.isEmpty();
          boolean _not = (!_isEmpty);
          if (_not) {
            this.registry_Operators = this.registryBackUp_Operators;
            this.registry_OperatorNames = this.registryBackUp_OperatorNames;
            this.registryBackUp_Operators.clear();
            this.registryBackUp_OperatorNames.clear();
          }
          this.registry_Sinks.remove(query.getName());
          _xblockexpression_1 = this.registerOperator(sink, query.getName());
        }
        _xifexpression = _xblockexpression_1;
      } else {
        this.registry_StreamTo.put(query.getName(), query.getName());
        this.registryBackUp_Operators = this.registry_Operators;
        this.registry_Operators.clear();
        this.registryBackUp_OperatorNames = this.registry_OperatorNames;
        this.registry_OperatorNames.clear();
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  private String buildInput2(final SimpleSelect select, final String... operators) {
    if ((operators != null)) {
      String _xifexpression = null;
      int _size = ((List<String>)Conversions.doWrapArray(operators)).size();
      boolean _greaterThan = (_size > 0);
      if (_greaterThan) {
        _xifexpression = operators[0];
      } else {
        _xifexpression = null;
      }
      String mapOperator = _xifexpression;
      String _xifexpression_1 = null;
      int _size_1 = ((List<String>)Conversions.doWrapArray(operators)).size();
      boolean _greaterThan_1 = (_size_1 > 1);
      if (_greaterThan_1) {
        _xifexpression_1 = operators[1];
      } else {
        _xifexpression_1 = null;
      }
      String aggregateOperator = _xifexpression_1;
      if (((mapOperator != null) && (aggregateOperator != null))) {
        String _buildJoin = this.buildJoin(select.getSources());
        return this.checkForGroupAttributes(aggregateOperator, select, 
          this.buildJoin(new String[] { aggregateOperator, _buildJoin }));
      } else {
        if ((mapOperator != null)) {
          return this.buildJoin(select.getSources());
        } else {
          if ((aggregateOperator != null)) {
            List<String> _xifexpression_2 = null;
            ExpressionsModel _predicates = select.getPredicates();
            boolean _tripleNotEquals = (_predicates != null);
            if (_tripleNotEquals) {
              final java.util.function.Function<Attribute, String> _function = (Attribute e) -> {
                return e.getName();
              };
              _xifexpression_2 = EcoreUtil2.<Attribute>getAllContentsOfType(select.getPredicates(), Attribute.class).stream().<String>map(_function).collect(
                Collectors.<String>toList());
            } else {
              _xifexpression_2 = null;
            }
            List<String> predicateAttributes = _xifexpression_2;
            boolean _containsAll = CQLGeneratorUtil.getRegisteredAggregationAttributes().containsAll(
              CQLGeneratorUtil.getProjectionAttributes().get(select));
            if (_containsAll) {
              if ((((predicateAttributes != null) && (!predicateAttributes.isEmpty())) && 
                CQLGeneratorUtil.getRegisteredAggregationAttributes().containsAll(predicateAttributes))) {
                return aggregateOperator;
              } else {
                String _buildJoin_1 = this.buildJoin(select.getSources());
                return this.checkForGroupAttributes(aggregateOperator, select, 
                  this.buildJoin(new String[] { aggregateOperator, _buildJoin_1 }));
              }
            } else {
              String _buildJoin_2 = this.buildJoin(select.getSources());
              return this.checkForGroupAttributes(aggregateOperator, select, 
                this.buildJoin(new String[] { aggregateOperator, _buildJoin_2 }));
            }
          }
        }
      }
    }
    return this.buildJoin(select.getSources());
  }
  
  private String checkForGroupAttributes(final String aggregateOperator, final SimpleSelect select, final String output) {
    boolean _contains = this.registry_Operators.get(aggregateOperator).contains("group_by");
    if (_contains) {
      String join = this.buildJoin(select.getSources());
      ArrayList<String> groupAttributes = CollectionLiterals.<String>newArrayList();
      for (int i = 0; (i < select.getOrder().size()); i++) {
        {
          String groupAttribute = select.getOrder().get(i).getName();
          groupAttributes.add(groupAttribute);
          groupAttributes.add(((groupAttribute + "_groupAttribute#") + Integer.valueOf(i)));
        }
      }
      Pair<String, String> _mappedTo = Pair.<String, String>of("pairs", "true");
      String _generateListString = this.generateListString(groupAttributes);
      Pair<String, String> _mappedTo_1 = Pair.<String, String>of("aliases", _generateListString);
      Pair<String, String> _mappedTo_2 = Pair.<String, String>of("input", aggregateOperator);
      String _build = this.builder.build(RenameAO.class, 
        CollectionLiterals.<String, String>newHashMap(_mappedTo, _mappedTo_1, _mappedTo_2));
      return this.buildJoin(
        new String[] { _build, join });
    }
    return output;
  }
  
  private CharSequence buildWindowOP(final SimpleSource source) {
    WindowOperator _window = source.getWindow();
    boolean _tripleEquals = (_window == null);
    if (_tripleEquals) {
      return source.getName();
    }
    Map<String, String> args = CollectionLiterals.<String, String>newHashMap();
    WindowOperator window = source.getWindow();
    if ((window instanceof TimebasedWindow)) {
      String _xifexpression = null;
      int _advance_size = ((TimebasedWindow)window).getAdvance_size();
      boolean _tripleNotEquals = (_advance_size != 0);
      if (_tripleNotEquals) {
        _xifexpression = Integer.valueOf(((TimebasedWindow)window).getAdvance_size()).toString();
      } else {
        _xifexpression = "1";
      }
      String var1 = _xifexpression;
      String _xifexpression_1 = null;
      Time _unit = ((TimebasedWindow)window).getUnit();
      boolean _tripleNotEquals_1 = (_unit != Time.NULL);
      if (_tripleNotEquals_1) {
        _xifexpression_1 = ((TimebasedWindow)window).getUnit().getName();
      } else {
        _xifexpression_1 = Time.NANOSECONDS.getName();
      }
      String var3 = _xifexpression_1;
      String _xifexpression_2 = null;
      Time _advance_unit = ((TimebasedWindow)window).getAdvance_unit();
      boolean _tripleNotEquals_2 = (_advance_unit != Time.NULL);
      if (_tripleNotEquals_2) {
        _xifexpression_2 = ((TimebasedWindow)window).getAdvance_unit().getName();
      } else {
        _xifexpression_2 = var3;
      }
      String var2 = _xifexpression_2;
      String _var2 = var2;
      String _xifexpression_3 = null;
      int _length = var2.length();
      int _minus = (_length - 1);
      boolean _equalsIgnoreCase = Character.valueOf(var2.charAt(_minus)).toString().equalsIgnoreCase("S");
      boolean _not = (!_equalsIgnoreCase);
      if (_not) {
        _xifexpression_3 = "S";
      } else {
        _xifexpression_3 = "";
      }
      var2 = (_var2 + _xifexpression_3);
      String _string = Integer.valueOf(((TimebasedWindow)window).getSize()).toString();
      String _plus = (_string + ",\'");
      String _plus_1 = (_plus + var3);
      String _plus_2 = (_plus_1 + "\'");
      args.put("size", _plus_2);
      args.put("advance", (((var1 + ",\'") + var2) + "\'"));
      args.put("input", source.getName());
      return this.builder.build(TimeWindowAO.class, args);
    } else {
      if ((window instanceof TuplebasedWindow)) {
        this.log.error("build element window");
        args.put("size", Integer.valueOf(((TuplebasedWindow)window).getSize()).toString());
        int _xifexpression_4 = (int) 0;
        int _advance_size_1 = ((TuplebasedWindow)window).getAdvance_size();
        boolean _notEquals = (_advance_size_1 != 0);
        if (_notEquals) {
          _xifexpression_4 = ((TuplebasedWindow)window).getAdvance_size();
        } else {
          _xifexpression_4 = 1;
        }
        args.put("advance", Integer.valueOf(_xifexpression_4).toString());
        String _xifexpression_5 = null;
        Attribute _partition_attribute = ((TuplebasedWindow)window).getPartition_attribute();
        boolean _tripleNotEquals_3 = (_partition_attribute != null);
        if (_tripleNotEquals_3) {
          _xifexpression_5 = ((TuplebasedWindow)window).getPartition_attribute().getName();
        } else {
          _xifexpression_5 = null;
        }
        args.put("partition", _xifexpression_5);
        args.put("input", source.getName());
        return this.builder.build(ElementWindowAO.class, args);
      } else {
        return source.getName();
      }
    }
  }
  
  private Object[] buildMapOperator(final List<SelectExpression> expressions) {
    return this.buildMapOperator(expressions, null);
  }
  
  private Object[] buildMapOperator(final List<SelectExpression> expressions, final String input) {
    String expressionArgument = "";
    List<String> expressionStrings = CollectionLiterals.<String>newArrayList();
    List<String> attributeNames = CollectionLiterals.<String>newArrayList();
    for (int i = 0; (i < expressions.size()); i++) {
      {
        String expressionName = "";
        String expressionString = this.parseSelectExpression(expressions.get(i)).toString();
        Alias _alias = expressions.get(i).getAlias();
        boolean _tripleEquals = (_alias == null);
        if (_tripleEquals) {
          expressionName = CQLGeneratorUtil.getExpressionName();
        } else {
          expressionName = expressions.get(i).getAlias().getName();
        }
        expressionStrings.add(expressionString);
        expressionStrings.add(expressionName);
        expressionStrings.add(",");
        final List<String> _converted_expressionStrings = (List<String>)expressionStrings;
        String t = this.generateKeyValueString(((String[])Conversions.unwrapArray(_converted_expressionStrings, String.class)));
        String _expressionArgument = expressionArgument;
        expressionArgument = (_expressionArgument + t);
        CQLGeneratorUtil.getRegisteredExpressions().put(expressionName, t);
        int _size = expressions.size();
        int _minus = (_size - 1);
        boolean _notEquals = (i != _minus);
        if (_notEquals) {
          String _expressionArgument_1 = expressionArgument;
          expressionArgument = (_expressionArgument_1 + ",");
        }
        expressionStrings.clear();
        attributeNames.add(expressionName);
      }
    }
    Pair<String, String> _mappedTo = Pair.<String, String>of("expressions", expressionArgument);
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("input", input);
    String _build = this.builder.build(MapAO.class, CollectionLiterals.<String, String>newLinkedHashMap(_mappedTo, _mappedTo_1));
    return new Object[] { attributeNames, _build };
  }
  
  private Object[] buildAggregateOP(final List<SelectExpression> aggAttr, final List<Attribute> orderAttr, final CharSequence input) {
    String argsstr = "";
    List<String> args = CollectionLiterals.<String>newArrayList();
    List<String> aliases = CollectionLiterals.<String>newArrayList();
    String mapName = "";
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(aggAttr, Object.class)).length); i++) {
      {
        EObject _value = aggAttr.get(i).getExpressions().get(0).getValue();
        Function aggregation = ((Function) _value);
        String attributename = "";
        String datatype = "";
        EObject _value_1 = aggregation.getValue();
        EList<ExpressionComponent> components = ((SelectExpression) _value_1).getExpressions();
        int _size = components.size();
        boolean _equals = (_size == 1);
        if (_equals) {
          EObject comp = components.get(0).getValue();
          boolean _matched = false;
          if (comp instanceof Attribute) {
            _matched=true;
            attributename = this.getAttributename(((Attribute)comp).getName());
            datatype = this.getDataTypeFrom(attributename);
          }
          if (!_matched) {
            if (comp instanceof Starthing) {
              _matched=true;
              attributename = "*";
            }
          }
        } else {
          EObject _value_2 = aggregation.getValue();
          Object[] mapOperator = this.buildMapOperator(Collections.<SelectExpression>unmodifiableList(CollectionLiterals.<SelectExpression>newArrayList(((SelectExpression) _value_2))), input.toString());
          Object _get = mapOperator[1];
          mapName = this.registerOperator(((CharSequence) _get));
          Object _get_1 = mapOperator[0];
          attributename = ((List<String>) _get_1).get(0);
          datatype = "DOUBLE";
        }
        args.add(aggregation.getName());
        args.add(attributename);
        String alias = "";
        Alias _alias = aggAttr.get(i).getAlias();
        boolean _tripleNotEquals = (_alias != null);
        if (_tripleNotEquals) {
          alias = aggAttr.get(i).getAlias().getName();
        } else {
          alias = CQLGeneratorUtil.getAggregationName(aggregation.getName());
        }
        args.add(alias);
        aliases.add(alias);
        boolean _notEquals = (!Objects.equal(datatype, ""));
        if (_notEquals) {
          args.add(datatype);
        }
        CQLGeneratorUtil.addAggregationAttribute(aggAttr.get(i), alias);
        args.add(",");
        String _argsstr = argsstr;
        final List<String> _converted_args = (List<String>)args;
        String _generateKeyValueString = this.generateKeyValueString(((String[])Conversions.unwrapArray(_converted_args, String.class)));
        argsstr = (_argsstr + _generateKeyValueString);
        int _length = ((Object[])Conversions.unwrapArray(aggAttr, Object.class)).length;
        int _minus = (_length - 1);
        boolean _notEquals_1 = (i != _minus);
        if (_notEquals_1) {
          String _argsstr_1 = argsstr;
          argsstr = (_argsstr_1 + ",");
        }
        args.clear();
      }
    }
    String groupby = "";
    boolean _isEmpty = orderAttr.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      String _groupby = groupby;
      final java.util.function.Function<Attribute, String> _function = (Attribute e) -> {
        return this.getAttributename(e.getName(), null);
      };
      String _generateListString = this.generateListString(orderAttr.stream().<String>map(_function).collect(Collectors.<String>toList()));
      groupby = (_groupby + _generateListString);
    }
    Pair<String, String> _mappedTo = Pair.<String, String>of("aggregations", argsstr);
    String _xifexpression = null;
    boolean _notEquals = (!Objects.equal(groupby, ""));
    if (_notEquals) {
      _xifexpression = groupby;
    } else {
      _xifexpression = null;
    }
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("group_by", _xifexpression);
    String _xifexpression_1 = null;
    boolean _notEquals_1 = (!Objects.equal(mapName, ""));
    if (_notEquals_1) {
      _xifexpression_1 = mapName;
    } else {
      _xifexpression_1 = input.toString();
    }
    Pair<String, String> _mappedTo_2 = Pair.<String, String>of("input", _xifexpression_1);
    String _build = this.builder.build(AggregateAO.class, 
      CollectionLiterals.<String, String>newHashMap(_mappedTo, _mappedTo_1, _mappedTo_2));
    return new Object[] { aliases, _build };
  }
  
  private Object[] buildAggregateOP(final List<SelectExpression> list, final List<Attribute> list2, final List<Source> srcs) {
    return this.buildAggregateOP(list, list2, this.buildJoin(srcs));
  }
  
  private CharSequence buildCreate1(final String type, final AccessFramework pars, final SchemaDefinition schema, final String name) {
    Class<?> t = null;
    String input = "--INPUT--";
    boolean _equals = type.equals("ACCESS");
    if (_equals) {
      t = AccessAO.class;
    } else {
      t = SenderAO.class;
    }
    boolean _contains = this.registry_StreamTo.keySet().contains(name);
    if (_contains) {
      input = this.registry_StreamTo.get(name);
    }
    Map<String, String> argss = CollectionLiterals.<String, String>newHashMap();
    boolean _equals_1 = t.equals(AccessAO.class);
    if (_equals_1) {
      argss.put("source", name);
    } else {
      argss.put("sink", name);
    }
    argss.put("wrapper", pars.getWrapper());
    argss.put("protocol", pars.getProtocol());
    argss.put("transport", pars.getTransport());
    argss.put("datahandler", pars.getDatahandler());
    String _xifexpression = null;
    boolean _equals_2 = t.equals("source");
    if (_equals_2) {
      _xifexpression = this.extractSchema(schema).toString();
    } else {
      _xifexpression = null;
    }
    argss.put("schema", _xifexpression);
    argss.put("options", this.generateKeyValueString(pars.getKeys(), pars.getValues(), ","));
    String _xifexpression_1 = null;
    boolean _equals_3 = t.equals("sink");
    if (_equals_3) {
      _xifexpression_1 = input;
    } else {
      _xifexpression_1 = null;
    }
    argss.put("input", _xifexpression_1);
    return this.builder.build(t, argss);
  }
  
  private String buildJoin(final List<Source> sources) {
    String[] sourceStrings = new String[sources.size()];
    List<String> sourcenames = CollectionLiterals.<String>newArrayList();
    for (int i = 0; (i < sources.size()); i++) {
      {
        Source source = sources.get(i);
        if ((source instanceof NestedSource)) {
          int _size = this.registry_SimpleSelect.size();
          int _minus = (_size - 1);
          SimpleSelect query = this.registry_SimpleSelect.get(_minus);
          Map<String, List<String>> queryAttributess = CQLGeneratorUtil.getQueryAttributes(query);
          SimpleSelect _select = ((NestedSource)source).getStatement().getSelect();
          SimpleSelect subQuery = ((SimpleSelect) _select);
          Map<String, List<String>> subQueryAttributes = CQLGeneratorUtil.getQueryAttributes(subQuery);
          String lastOperator = this.registry_SubQueries.get(subQuery);
          ArrayList<String> inputs = CollectionLiterals.<String>newArrayList();
          List<String> attributeAliases = CQLGeneratorUtil.getAttributeAliasesAsList();
          Set<Map.Entry<String, List<String>>> _entrySet = queryAttributess.entrySet();
          for (final Map.Entry<String, List<String>> entry : _entrySet) {
            {
              List<String> attributes = subQueryAttributes.get(entry.getKey());
              if ((attributes != null)) {
                ArrayList<String> aliasses = CollectionLiterals.<String>newArrayList();
                for (final String name : attributes) {
                  List<String> _value = entry.getValue();
                  for (final String name2 : _value) {
                    {
                      String realName = name;
                      String realName2 = name2;
                      boolean _contains = attributeAliases.contains(realName);
                      if (_contains) {
                        realName = this.getAttributenameFromAlias(realName);
                      }
                      boolean _contains_1 = attributeAliases.contains(realName2);
                      if (_contains_1) {
                        realName2 = this.getAttributenameFromAlias(realName2);
                      }
                      boolean _contains_2 = realName.contains(".");
                      if (_contains_2) {
                        realName = name.split("\\.")[1];
                      }
                      boolean _contains_3 = realName2.contains(".");
                      if (_contains_3) {
                        realName2 = realName2.split("\\.")[1];
                      }
                      boolean _equals = realName.equals(realName2);
                      if (_equals) {
                        aliasses.add(name.replace(".", "_"));
                        aliasses.add(name2);
                      }
                    }
                  }
                }
                String _generateListString = this.generateListString(aliasses);
                Pair<String, String> _mappedTo = Pair.<String, String>of("aliases", _generateListString);
                Pair<String, String> _mappedTo_1 = Pair.<String, String>of("pairs", "true");
                Pair<String, String> _mappedTo_2 = Pair.<String, String>of("input", lastOperator);
                inputs.add(
                  this.registerOperator(
                    this.builder.build(RenameAO.class, 
                      CollectionLiterals.<String, String>newHashMap(_mappedTo, _mappedTo_1, _mappedTo_2))));
              }
            }
          }
          ArrayList<String> aliasses = CollectionLiterals.<String>newArrayList();
          String subQueryAlias = ((NestedSource)source).getAlias().getName();
          List<String> _allQueryAttributes = CQLGeneratorUtil.getAllQueryAttributes(subQuery);
          for (final String name : _allQueryAttributes) {
            {
              String realName = name;
              boolean _contains = realName.contains(".");
              if (_contains) {
                int _indexOf = realName.indexOf(".");
                int _plus = (_indexOf + 1);
                realName = realName.substring(_plus, realName.length());
                aliasses.add(name.replace(".", "_"));
              } else {
                aliasses.add(name);
              }
              boolean _isAggregationAttribute = CQLGeneratorUtil.isAggregationAttribute(name);
              if (_isAggregationAttribute) {
                aliasses.add(((subQueryAlias + ".") + realName));
              } else {
                aliasses.add(((subQueryAlias + ".") + realName));
              }
            }
          }
          String _generateListString = this.generateListString(aliasses);
          Pair<String, String> _mappedTo = Pair.<String, String>of("aliases", _generateListString);
          Pair<String, String> _mappedTo_1 = Pair.<String, String>of("pairs", "true");
          Pair<String, String> _mappedTo_2 = Pair.<String, String>of("input", lastOperator);
          String op = this.builder.build(RenameAO.class, 
            CollectionLiterals.<String, String>newHashMap(_mappedTo, _mappedTo_1, _mappedTo_2));
          inputs.add(this.registerOperator(op));
          final ArrayList<String> _converted_inputs = (ArrayList<String>)inputs;
          sourceStrings[i] = this.buildJoin(((String[])Conversions.unwrapArray(_converted_inputs, String.class))).toString();
        } else {
          if ((source instanceof SimpleSource)) {
            final String sourcename = ((SimpleSource)source).getName();
            final Predicate<String> _function = (String e) -> {
              return e.equals(sourcename);
            };
            final long count = sourcenames.stream().filter(_function).count();
            sourcenames.add(sourcename);
            this.sourcesDuringRename = sources;
            sourceStrings[i] = 
              this.buildRename(
                this.buildWindowOP(((SimpleSource)source)), ((SimpleSource)source), 
                ((int) count)).toString();
          }
        }
      }
    }
    return this.buildJoin(sourceStrings);
  }
  
  private List<String> renameAliases = CollectionLiterals.<String>newArrayList();
  
  private List<String> processedSources = CollectionLiterals.<String>newArrayList();
  
  private List<Source> sourcesDuringRename;
  
  private CharSequence buildRename(final CharSequence input, final SimpleSource simpleSource, final int selfJoin) {
    SourceStruct source = CQLGeneratorUtil.getSource(simpleSource);
    String sourcealias = null;
    Alias _alias = simpleSource.getAlias();
    boolean _tripleNotEquals = (_alias != null);
    if (_tripleNotEquals) {
      sourcealias = simpleSource.getAlias().getName();
    }
    ArrayList<List<String>> listOfLists = CollectionLiterals.<List<String>>newArrayList();
    for (int j = 0; (j < source.attributes.size()); j++) {
      {
        int k = 0;
        for (final String attributealias : source.attributes.get(j).aliases) {
          {
            String sourceFromAlias = CQLGeneratorUtil.getAttributeAliases().get(attributealias);
            if ((sourceFromAlias.equals(sourcealias) || sourceFromAlias.equals(simpleSource.getName()))) {
              int _size = listOfLists.size();
              boolean b = (_size <= k);
              List<String> list = null;
              if (b) {
                list = CollectionLiterals.<String>newArrayList();
              } else {
                list = listOfLists.get(k);
              }
              list.add(source.attributes.get(j).attributename);
              list.add(attributealias);
              if (b) {
                listOfLists.add(list);
              }
              k++;
            }
          }
        }
      }
    }
    if ((((listOfLists.size() > 1) || (selfJoin > 0)) || (sourcealias != null))) {
      for (int j = 0; (j < listOfLists.size()); j++) {
        {
          List<String> list = listOfLists.get(j);
          for (int k = 0; (k < source.attributes.size()); k++) {
            boolean _contains = list.contains(source.attributes.get(k).attributename);
            boolean _not = (!_contains);
            if (_not) {
              String alias = null;
              String name = source.attributes.get(k).attributename;
              if ((sourcealias != null)) {
                if (((j > 0) && (listOfLists.size() > 1))) {
                  alias = this.generateAlias(name, source.sourcename, j);
                } else {
                  alias = ((sourcealias + ".") + name);
                }
              }
              this.renameAliases.add(name);
              this.renameAliases.add(source.sourcename);
              this.renameAliases.add(alias);
              list.add(name);
              list.add(alias);
            }
          }
        }
      }
    }
    ArrayList<String> renames = CollectionLiterals.<String>newArrayList();
    this.processedSources.add(source.sourcename);
    for (int j = 0; (j < listOfLists.size()); j++) {
      String _generateListString = this.generateListString(listOfLists.get(j));
      Pair<String, String> _mappedTo = Pair.<String, String>of("aliases", _generateListString);
      Pair<String, String> _mappedTo_1 = Pair.<String, String>of("pairs", "true");
      String _string = input.toString();
      Pair<String, String> _mappedTo_2 = Pair.<String, String>of("input", _string);
      renames.add(
        this.registerOperator(
          this.builder.build(RenameAO.class, 
            CollectionLiterals.<String, String>newLinkedHashMap(_mappedTo, _mappedTo_1, _mappedTo_2))));
    }
    int _size = renames.size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      final ArrayList<String> _converted_renames = (ArrayList<String>)renames;
      return this.buildJoin(((String[])Conversions.unwrapArray(_converted_renames, String.class)));
    }
    int _size_1 = renames.size();
    boolean _equals = (_size_1 == 1);
    if (_equals) {
      return renames.get(0);
    }
    return input;
  }
  
  private String generateAlias(final String attributename, final String sourcename, final int number) {
    String alias = ((((sourcename + ".") + attributename) + "#") + Integer.valueOf(number));
    boolean _contains = this.renameAliases.contains(alias);
    if (_contains) {
      return alias = this.generateAlias(attributename, sourcename, (number + 1));
    }
    return alias;
  }
  
  private String buildJoin(final String[] srcs) {
    String[] sourcenames = srcs;
    final String[] _converted_sourcenames = (String[])sourcenames;
    int _size = ((List<String>)Conversions.doWrapArray(_converted_sourcenames)).size();
    boolean _lessThan = (_size < 1);
    if (_lessThan) {
      throw new IllegalArgumentException("Invalid number of source elements: There has to be at least one source");
    }
    final String[] _converted_sourcenames_1 = (String[])sourcenames;
    int _size_1 = ((List<String>)Conversions.doWrapArray(_converted_sourcenames_1)).size();
    boolean _equals = (_size_1 == 1);
    if (_equals) {
      this.firstJoinInQuery = true;
      return sourcenames[0];
    }
    List<String> _asList = Arrays.<String>asList(sourcenames);
    List<String> list = new ArrayList<String>(_asList);
    int _size_2 = list.size();
    boolean _equals_1 = (_size_2 == 2);
    if (_equals_1) {
      this.firstJoinInQuery = true;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("JOIN(");
      String _get = sourcenames[0];
      _builder.append(_get);
      _builder.append(",");
      String _get_1 = sourcenames[1];
      _builder.append(_get_1);
      _builder.append(")");
      return _builder.toString();
    }
    list.remove(0);
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("JOIN(");
    String _get_2 = sourcenames[0];
    _builder_1.append(_get_2);
    _builder_1.append(",");
    final List<String> _converted_list = (List<String>)list;
    String _buildJoin = this.buildJoin(((String[])Conversions.unwrapArray(_converted_list, String.class)));
    _builder_1.append(_buildJoin);
    _builder_1.append(")");
    return _builder_1.toString();
  }
  
  private CharSequence buildProjection(final SimpleSelect select, final CharSequence operator) {
    List<String> attributes = CQLGeneratorUtil.getProjectionAttributes().get(select);
    for (int i = 0; (i < (this.renameAliases.size() - 2)); i = (i + 3)) {
      {
        String attributename = this.renameAliases.get(i);
        String sourcename = this.renameAliases.get((i + 1));
        String alias = this.renameAliases.get((i + 2));
        CQLGeneratorUtil.getSource(sourcename).findbyName(attributename).aliases.add(alias);
      }
    }
    ArrayList<String> list = CollectionLiterals.<String>newArrayList();
    for (int i = 0; (i < attributes.size()); i++) {
      {
        String attribute1 = CQLGeneratorUtil.getProjectAttribute(attributes.get(i));
        list.add(attribute1);
      }
    }
    for (int i = 0; (i < (this.renameAliases.size() - 2)); i = (i + 3)) {
      {
        String attributename = this.renameAliases.get(i);
        String sourcename = this.renameAliases.get((i + 1));
        String alias = this.renameAliases.get((i + 2));
        CQLGeneratorUtil.getSource(sourcename).findbyName(attributename).aliases.remove(alias);
      }
    }
    String argument = this.generateListString(list).replace("\'[\'", "[\'").replace("\']\'", "\']");
    Pair<String, String> _mappedTo = Pair.<String, String>of("expressions", argument);
    String _string = operator.toString();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("input", _string);
    return this.builder.build(MapAO.class, CollectionLiterals.<String, String>newLinkedHashMap(_mappedTo, _mappedTo_1));
  }
  
  public boolean checkIfSelectAll(final List<Attribute> attributes) {
    boolean _isEmpty = attributes.isEmpty();
    if (_isEmpty) {
      return true;
    } else {
      for (final Attribute attribute : attributes) {
        boolean _contains = attribute.getName().contains(".*");
        boolean _not = (!_contains);
        if (_not) {
          return false;
        }
      }
    }
    return true;
  }
  
  public String getLastOperator() {
    String _xifexpression = null;
    int _size = this.registry_OperatorNames.size();
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      int _size_1 = this.registry_OperatorNames.size();
      int _minus = (_size_1 - 1);
      _xifexpression = this.registry_OperatorNames.get(_minus);
    } else {
      _xifexpression = null;
    }
    return _xifexpression;
  }
  
  private boolean isSame(final String attribute1, final String attribute2) {
    String name1 = attribute1;
    String name2 = attribute2;
    String source1 = "";
    String source2 = "";
    boolean _contains = name1.contains(".");
    if (_contains) {
      String[] split = name1.split("\\.");
      name1 = split[1];
      source1 = split[0];
    }
    boolean _contains_1 = name2.contains(".");
    if (_contains_1) {
      String[] split_1 = name2.split("\\.");
      name2 = split_1[1];
      source2 = split_1[0];
    }
    boolean _contains_2 = CQLGeneratorUtil.getAttributeAliasesAsList().contains(name1);
    if (_contains_2) {
      name1 = this.getAttributeFromAlias(name1).attributename;
    }
    boolean _contains_3 = CQLGeneratorUtil.getAttributeAliasesAsList().contains(name2);
    if (_contains_3) {
      name2 = this.getAttributeFromAlias(name2).attributename;
    }
    boolean _contains_4 = CQLGeneratorUtil.getSourceAliasesAsList().contains(source1);
    if (_contains_4) {
      source1 = this.getSourcenameFromAlias(source1);
    }
    boolean _contains_5 = CQLGeneratorUtil.getSourceAliasesAsList().contains(source2);
    if (_contains_5) {
      source2 = this.getSourcenameFromAlias(source2);
    }
    boolean _equals = name1.equals(name2);
    if (_equals) {
      if ((Objects.equal(source1, "") || Objects.equal(source2, ""))) {
        return true;
      } else {
        boolean _equals_1 = source1.equals(source2);
        if (_equals_1) {
          return true;
        }
      }
    }
    return false;
  }
  
  public boolean containsAttribute(final List<Attribute> list, final Attribute attribute) {
    for (final Attribute element : list) {
      boolean _isSame = this.isSame(attribute.getName(), element.getName());
      if (_isSame) {
        return true;
      }
    }
    return false;
  }
  
  public boolean isSelectAll(final SimpleSelect select) {
    EList<SelectArgument> _arguments = select.getArguments();
    for (final SelectArgument a : _arguments) {
      Attribute _attribute = a.getAttribute();
      boolean _tripleNotEquals = (_attribute != null);
      if (_tripleNotEquals) {
        return false;
      }
    }
    return true;
  }
  
  public List<SelectExpression> extractAggregationsFromArgument(final List<SelectArgument> args) {
    List<SelectExpression> list = CollectionLiterals.<SelectExpression>newArrayList();
    for (final SelectArgument a : args) {
      SelectExpression _expression = a.getExpression();
      boolean _tripleNotEquals = (_expression != null);
      if (_tripleNotEquals) {
        int _size = a.getExpression().getExpressions().size();
        boolean _equals = (_size == 1);
        if (_equals) {
          ExpressionComponent aggregation = a.getExpression().getExpressions().get(0);
          EObject function = aggregation.getValue();
          if ((function instanceof Function)) {
            boolean _isAggregateFunction = CQLGeneratorUtil.isAggregateFunction(((Function)function).getName());
            if (_isAggregateFunction) {
              list.add(a.getExpression());
            }
          }
        }
      }
    }
    return list;
  }
  
  public List<SelectExpression> extractSelectExpressionsFromArgument(final List<SelectArgument> args) {
    List<SelectExpression> list = CollectionLiterals.<SelectExpression>newArrayList();
    for (final SelectArgument a : args) {
      SelectExpression _expression = a.getExpression();
      boolean _tripleNotEquals = (_expression != null);
      if (_tripleNotEquals) {
        int _size = a.getExpression().getExpressions().size();
        boolean _equals = (_size == 1);
        if (_equals) {
          ExpressionComponent aggregation = a.getExpression().getExpressions().get(0);
          EObject function = aggregation.getValue();
          if ((function instanceof Function)) {
            SelectExpression _expression_1 = a.getExpression();
            boolean _isMEPFunction = CQLGeneratorUtil.isMEPFunction(((Function)function).getName(), 
              this.parseSelectExpression(((SelectExpression) _expression_1)).toString());
            if (_isMEPFunction) {
              list.add(a.getExpression());
            }
          } else {
            list.add(a.getExpression());
          }
        } else {
          list.add(a.getExpression());
        }
      }
    }
    return list;
  }
  
  private String generateKeyValueString(final String... s) {
    String str = "[";
    int _length = s.length;
    boolean _equals = (_length == 1);
    if (_equals) {
      String _str = str;
      String _get = s[0];
      String _plus = ("\'" + _get);
      String _plus_1 = (_plus + "\']");
      return str = (_str + _plus_1);
    }
    for (int i = 0; (i < (s.length - 2)); i++) {
      String _str_1 = str;
      String _get_1 = s[i];
      String _plus_2 = ("\'" + _get_1);
      String _plus_3 = (_plus_2 + "\'");
      int _length_1 = s.length;
      int _minus = (_length_1 - 1);
      String _get_2 = s[_minus];
      String _plus_4 = (_plus_3 + _get_2);
      str = (_str_1 + _plus_4);
    }
    String _str_1 = str;
    int _length_1 = s.length;
    int _minus = (_length_1 - 2);
    String _get_1 = s[_minus];
    String _plus_2 = ("\'" + _get_1);
    String _plus_3 = (_plus_2 + "\']");
    return str = (_str_1 + _plus_3);
  }
  
  private String generateKeyValueString(final List<String> l1, final List<String> l2, final String s) {
    String str = "";
    for (int i = 0; (i < (l1.size() - 1)); i++) {
      String _str = str;
      String _generateKeyValueString = this.generateKeyValueString(l1.get(i), l2.get(i), s);
      String _plus = (_generateKeyValueString + ",");
      str = (_str + _plus);
    }
    String _str = str;
    int _size = l1.size();
    int _minus = (_size - 1);
    int _size_1 = l1.size();
    int _minus_1 = (_size_1 - 1);
    String _generateKeyValueString = this.generateKeyValueString(l1.get(_minus), l2.get(_minus_1), s);
    return str = (_str + _generateKeyValueString);
  }
  
  private String generateListString(final String s1) {
    return (("\'" + s1) + "\'");
  }
  
  private String generateListString(final List<String> l1) {
    if (((l1 != null) && (!l1.isEmpty()))) {
      String str = "";
      for (int i = 0; (i < (l1.size() - 1)); i++) {
        String _str = str;
        String _generateListString = this.generateListString(l1.get(i));
        String _plus = (_generateListString + ",");
        str = (_str + _plus);
      }
      String _str = str;
      int _size = l1.size();
      int _minus = (_size - 1);
      String _generateListString = this.generateListString(l1.get(_minus));
      return str = (_str + _generateListString);
    }
    return "";
  }
  
  private CharSequence getID() {
    this.operatorCounter++;
    return Integer.valueOf(this.operatorCounter).toString();
  }
  
  private String registerOperator(final CharSequence operator) {
    CharSequence _iD = this.getID();
    String _plus = (this.OP + _iD);
    return this.registerOperator(operator, _plus);
  }
  
  private String registerOperator(final CharSequence operator, final String definition) {
    boolean _contains = this.registry_OperatorNames.contains(definition);
    boolean _not = (!_contains);
    if (_not) {
      this.registry_OperatorNames.add(definition.toString());
      this.registry_Operators.put(definition, operator.toString());
    }
    return definition;
  }
  
  private boolean registerSourceAlias(final Source src) {
    boolean _xifexpression = false;
    Alias _alias = src.getAlias();
    boolean _tripleNotEquals = (_alias != null);
    if (_tripleNotEquals) {
      _xifexpression = CQLGeneratorUtil.getSource(src).aliases.add(src.getAlias().getName());
    }
    return _xifexpression;
  }
  
  public void setSchema(final List<SourceStruct> schemata) {
    CQLGeneratorUtil.setRegisteredSources(schemata);
  }
  
  private CharSequence formatOutputString(final String sequence) {
    String str = null;
    String replacement1 = "AXZTGHHAJJJSUEJJ23123123123";
    String replacement2 = "BNHUEOLASJJKEOOS12312309203";
    boolean _contains = sequence.contains(this.ASSIG2);
    if (_contains) {
      str = sequence.replaceFirst(this.ASSIG2, replacement1);
    } else {
      str = sequence.replaceFirst(this.ASSIG1, replacement2);
    }
    return str.replaceAll("\\s*[\\r\\n]+\\s*", "").trim().replace(" ", "").replace(replacement2, 
      ((" " + this.ASSIG1) + " ")).replace(replacement1, ((" " + this.ASSIG2) + " "));
  }
  
  public String getDataTypeFrom(final Attribute attribute) {
    return this.getDataTypeFrom(attribute.getName());
  }
  
  public String getDataTypeFrom(final String attribute) {
    String attributename = attribute;
    String sourcename = "";
    boolean _contains = attribute.contains(".");
    if (_contains) {
      String[] splitted = attribute.split("\\.");
      boolean _isAttributeAlias = CQLGeneratorUtil.isAttributeAlias(attributename);
      if (_isAttributeAlias) {
        String sourceFromAlias = CQLGeneratorUtil.getAttributeAliases().get(attribute);
        boolean _isSourceAlias = CQLGeneratorUtil.isSourceAlias(sourceFromAlias);
        if (_isSourceAlias) {
          sourceFromAlias = this.getSourcenameFromAlias(sourceFromAlias);
        }
        attributename = this.getAttributenameFromAlias(attributename);
        sourcename = sourceFromAlias;
        for (final AttributeStruct attr : CQLGeneratorUtil.getSource(sourcename).attributes) {
          boolean _equals = attr.attributename.equals(attributename);
          if (_equals) {
            return attr.datatype;
          }
        }
      }
      sourcename = splitted[0];
      attributename = splitted[1];
      boolean _isAttributeAlias_1 = CQLGeneratorUtil.isAttributeAlias(attributename);
      if (_isAttributeAlias_1) {
        attributename = this.getAttributenameFromAlias(attributename);
      }
      boolean _isSourceAlias_1 = CQLGeneratorUtil.isSourceAlias(sourcename);
      if (_isSourceAlias_1) {
        sourcename = this.getSourcenameFromAlias(sourcename);
      }
      try {
        for (final AttributeStruct attr_1 : CQLGeneratorUtil.getSource(sourcename).attributes) {
          boolean _equals_1 = attr_1.attributename.equals(attributename);
          if (_equals_1) {
            return attr_1.datatype;
          }
        }
      } catch (final Throwable _t) {
        if (_t instanceof IllegalArgumentException) {
          final IllegalArgumentException e = (IllegalArgumentException)_t;
          Set<String> _get = CQLGeneratorUtil.getSubQuerySources().get(sourcename);
          for (final String attr_2 : _get) {
            boolean _equals_2 = this.getAttributename(attr_2).equals(attributename);
            if (_equals_2) {
              return CQLGeneratorUtil.getAttribute(attr_2).datatype;
            }
          }
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
    } else {
      boolean _isAttributeAlias_2 = CQLGeneratorUtil.isAttributeAlias(attributename);
      if (_isAttributeAlias_2) {
        String sourceFromAlias_1 = CQLGeneratorUtil.getAttributeAliases().get(attribute);
        boolean _isSourceAlias_2 = CQLGeneratorUtil.isSourceAlias(sourceFromAlias_1);
        if (_isSourceAlias_2) {
          sourceFromAlias_1 = this.getSourcenameFromAlias(sourceFromAlias_1);
        }
        attributename = this.getAttributenameFromAlias(attributename);
        if ((attributename == null)) {
          attributename = attribute;
        }
        for (final AttributeStruct attr_3 : CQLGeneratorUtil.getSource(sourceFromAlias_1).attributes) {
          boolean _equals_3 = attr_3.attributename.equals(attributename);
          if (_equals_3) {
            return attr_3.datatype;
          }
        }
      }
    }
    return "Double";
  }
  
  public String getSourcenameFromAlias(final String sourcealias) {
    Set<Map.Entry<SourceStruct, List<String>>> _entrySet = CQLGeneratorUtil.getSourceAliases().entrySet();
    for (final Map.Entry<SourceStruct, List<String>> source : _entrySet) {
      boolean _contains = source.getValue().contains(sourcealias);
      if (_contains) {
        return source.getKey().sourcename;
      }
    }
    return null;
  }
  
  public AttributeStruct getAttributeFromAlias(final String alias) {
    Set<Map.Entry<AttributeStruct, List<String>>> _entrySet = CQLGeneratorUtil.getAttributeAliasesAsMap().entrySet();
    for (final Map.Entry<AttributeStruct, List<String>> entry : _entrySet) {
      boolean _contains = entry.getValue().contains(alias);
      if (_contains) {
        return entry.getKey();
      }
    }
    return null;
  }
  
  public String getAttributenameFromAlias(final String alias) {
    AttributeStruct attribute = this.getAttributeFromAlias(alias);
    if ((attribute != null)) {
      return attribute.attributename;
    }
    if ((CQLGeneratorUtil.getRegisteredAggregationAttributes().contains(alias) || 
      CQLGeneratorUtil.getRegisteredExpressions().keySet().contains(alias))) {
      return alias;
    }
    return null;
  }
  
  public String getAttributename(final String attributename, final String sourcename) {
    String attribute = null;
    String source = null;
    if (((sourcename != null) && (!sourcename.equals("")))) {
      SourceStruct tmp = null;
      attribute = attributename;
      String _xifexpression = null;
      if (((tmp = CQLGeneratorUtil.getSource(sourcename)) != null)) {
        _xifexpression = tmp.sourcename;
      } else {
        _xifexpression = null;
      }
      source = _xifexpression;
    } else {
      boolean _contains = attributename.contains(".");
      if (_contains) {
        String[] split = attributename.split("\\.");
        attribute = split[1];
        source = split[0];
      }
    }
    if ((source != null)) {
      boolean _isAggregationAttribute = CQLGeneratorUtil.isAggregationAttribute(attribute);
      if (_isAggregationAttribute) {
        return attribute;
      }
      boolean isAlias = CQLGeneratorUtil.isAttributeAlias(attribute);
      boolean _isSourceAlias = CQLGeneratorUtil.isSourceAlias(source);
      if (_isSourceAlias) {
        if (isAlias) {
          return attribute;
        } else {
          String r = ((source + ".") + attribute);
          boolean _contains_1 = CQLGeneratorUtil.getAttributeAliasesAsList().contains(r);
          if (_contains_1) {
            return r;
          } else {
            String sourcenameFromalias = this.getSourcenameFromAlias(source);
            List<String> attributeAliases = this.getAliasFromAttributename(attribute, sourcenameFromalias);
            boolean _isEmpty = attributeAliases.isEmpty();
            boolean _not = (!_isEmpty);
            if (_not) {
              return attributeAliases.get(0);
            } else {
              return ((source + ".") + attribute);
            }
          }
        }
      } else {
        if (isAlias) {
          return attribute;
        } else {
          return ((source + ".") + attribute);
        }
      }
    } else {
      attribute = attributename;
      boolean _contains_2 = CQLGeneratorUtil.getRegisteredAggregationAttributes().contains(attribute);
      if (_contains_2) {
        return attribute;
      }
      boolean _contains_3 = CQLGeneratorUtil.getRegisteredExpressions().keySet().contains(attribute);
      if (_contains_3) {
        return CQLGeneratorUtil.getRegisteredExpressions().get(attribute);
      }
      boolean _isAttributeAlias = CQLGeneratorUtil.isAttributeAlias(attribute);
      if (_isAttributeAlias) {
        return attribute;
      }
      ArrayList<SourceStruct> containedBySources = CollectionLiterals.<SourceStruct>newArrayList();
      ArrayList<String> usedNames = CollectionLiterals.<String>newArrayList();
      for (final String name : this.querySources) {
        boolean _contains_4 = usedNames.contains(name);
        boolean _not_1 = (!_contains_4);
        if (_not_1) {
          usedNames.add(name);
          SourceStruct source2 = CQLGeneratorUtil.getSource(name);
          for (final AttributeStruct attr : source2.attributes) {
            boolean _equals = attr.attributename.equals(attribute);
            if (_equals) {
              containedBySources.add(source2);
            }
          }
        }
      }
      int _size = containedBySources.size();
      boolean _equals_1 = (_size == 1);
      if (_equals_1) {
        List<String> aliases = this.getAliasFromAttributename(attribute, containedBySources.get(0).sourcename);
        boolean _isEmpty_1 = aliases.isEmpty();
        boolean _not_2 = (!_isEmpty_1);
        if (_not_2) {
          List<String> renames = this.registry_RenamedAttributes.get(attribute);
          if (((renames == null) || renames.isEmpty())) {
            return attribute;
          }
          return aliases.get(0);
        }
        SourceStruct sourceStruct = CQLGeneratorUtil.getSource(containedBySources.get(0).sourcename);
        boolean _isEmpty_2 = sourceStruct.aliases.isEmpty();
        boolean _not_3 = (!_isEmpty_2);
        if (_not_3) {
          List<String> renames_1 = this.registry_RenamedAttributes.get(attribute);
          if (((renames_1 == null) || renames_1.isEmpty())) {
            return attribute;
          }
          String _get = sourceStruct.aliases.get(0);
          String _plus = (_get + ".");
          return (_plus + attributename);
        }
        return ((containedBySources.get(0).sourcename + ".") + attribute);
      }
      boolean _contains_5 = attributename.contains("()");
      if (_contains_5) {
        String _replace = attributename.replace("(", "").replace(")", "");
        String _plus_1 = ("${" + _replace);
        return (_plus_1 + "}");
      }
      boolean _contains_6 = attributename.contains("$(");
      if (_contains_6) {
        return attributename;
      }
    }
    throw new IllegalArgumentException((("attribute " + attribute) + " could not be resolved"));
  }
  
  public String getAttributename(final Attribute attribute, final String srcname) {
    return this.getAttributename(attribute.getName(), srcname);
  }
  
  public String getAttributename(final Attribute attribute) {
    return this.getAttributename(attribute.getName());
  }
  
  public String getAttributename(final String attribute) {
    return this.getAttributename(attribute, null);
  }
  
  public List<String> getAliasFromAttributename(final String name, final String source) {
    return CQLGeneratorUtil.getSource(source).findbyName(name).aliases;
  }
  
  public FunctionStore setFunctionStore(final FunctionStore store) {
    return CQLGeneratorUtil.setFunctionStore(store);
  }
  
  public Pattern setAggregatePattern(final Pattern pattern) {
    return CQLGeneratorUtil.setAggregatePattern(pattern);
  }
  
  public MEP setMEP(final MEP mep) {
    return CQLGeneratorUtil.setMEP(mep);
  }
  
  public Map<String, String> setDatabaseConnections(final Map<String, String> connections) {
    return this.databaseConnections = connections;
  }
}
