/*
 * generated by Xtext 2.12.0
 */
package de.uniol.inf.is.odysseus.parser.cql2.serializer;

import com.google.inject.Inject;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.AccessFramework;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Alias;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.AndPredicate;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Attribute;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.AttributeRef;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.BoolConstant;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Bracket;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CQLPackage;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Command;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Comparision;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ComplexPredicate;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ComplexPredicateRef;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ComplexSelect;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ContextStoreType;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Create;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateAccessFramework;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateChannelFormatViaFile;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateChannelFrameworkViaPort;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateContextStore;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateDataBaseConnectionGeneric;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateDataBaseConnectionJDBC;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateDatabaseSink;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateDatabaseStream;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.CreateView;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.DropContextStore;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.DropDatabaseConnection;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.DropStream;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Equality;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ExistPredicate;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ExpressionComponent;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ExpressionComponentAsAttribute;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.ExpressionsModel;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.FloatConstant;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Function;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.InPredicate;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.InnerSelect;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.InnerSelect2;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.IntConstant;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Matrix;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Minus;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Model;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.MulOrDiv;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.NOT;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.NestedSource;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.OrPredicate;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Plus;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.QuantificationPredicate;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Query;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.RightsManagement;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.RoleManagement;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SchemaDefinition;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SelectArgument;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SelectExpression;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SimpleSelect;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.SimpleSource;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Star;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.StarExpression;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Starthing;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.StreamTo;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.StringConstant;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.TimebasedWindow;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.TuplebasedWindow;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.UndboundedWindow;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.UserManagement;
import de.uniol.inf.is.odysseus.parser.cql2.cQL.Vector;
import de.uniol.inf.is.odysseus.parser.cql2.services.CQLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CQLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CQLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CQLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CQLPackage.ACCESS_FRAMEWORK:
				sequence_AccessFramework(context, (AccessFramework) semanticObject); 
				return; 
			case CQLPackage.ALIAS:
				sequence_Alias(context, (Alias) semanticObject); 
				return; 
			case CQLPackage.AND_PREDICATE:
				sequence_AndPredicate(context, (AndPredicate) semanticObject); 
				return; 
			case CQLPackage.ATTRIBUTE:
				if (rule == grammarAccess.getAttributeForSelectExpressionRule()) {
					sequence_AttributeForSelectExpression(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributeWithoutAliasDefinitionRule()) {
					sequence_AttributeWithoutAliasDefinition(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributeRule()) {
					sequence_Attribute(context, (Attribute) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.ATTRIBUTE_REF:
				sequence_Atomic(context, (AttributeRef) semanticObject); 
				return; 
			case CQLPackage.BOOL_CONSTANT:
				if (rule == grammarAccess.getAtomicWithoutAttributeRefRule()) {
					sequence_AtomicWithoutAttributeRef(context, (BoolConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrPredicateRule()
						|| action == grammarAccess.getOrPredicateAccess().getOrPredicateLeftAction_1_0()
						|| rule == grammarAccess.getAndPredicateRule()
						|| action == grammarAccess.getAndPredicateAccess().getAndPredicateLeftAction_1_0()
						|| rule == grammarAccess.getEqualitiyRule()
						|| action == grammarAccess.getEqualitiyAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisionLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (BoolConstant) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.BRACKET:
				sequence_Primary(context, (Bracket) semanticObject); 
				return; 
			case CQLPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case CQLPackage.COMPARISION:
				sequence_Comparison(context, (Comparision) semanticObject); 
				return; 
			case CQLPackage.COMPLEX_PREDICATE:
				sequence_ComplexPredicate(context, (ComplexPredicate) semanticObject); 
				return; 
			case CQLPackage.COMPLEX_PREDICATE_REF:
				sequence_Atomic(context, (ComplexPredicateRef) semanticObject); 
				return; 
			case CQLPackage.COMPLEX_SELECT:
				sequence_ComplexSelect(context, (ComplexSelect) semanticObject); 
				return; 
			case CQLPackage.CONTEXT_STORE_TYPE:
				sequence_ContextStoreType(context, (ContextStoreType) semanticObject); 
				return; 
			case CQLPackage.CREATE:
				sequence_Create(context, (Create) semanticObject); 
				return; 
			case CQLPackage.CREATE_ACCESS_FRAMEWORK:
				sequence_CreateAccessFramework(context, (CreateAccessFramework) semanticObject); 
				return; 
			case CQLPackage.CREATE_CHANNEL_FORMAT_VIA_FILE:
				sequence_CreateChannelFormatViaFile(context, (CreateChannelFormatViaFile) semanticObject); 
				return; 
			case CQLPackage.CREATE_CHANNEL_FRAMEWORK_VIA_PORT:
				sequence_CreateChannelFrameworkViaPort(context, (CreateChannelFrameworkViaPort) semanticObject); 
				return; 
			case CQLPackage.CREATE_CONTEXT_STORE:
				sequence_CreateContextStore(context, (CreateContextStore) semanticObject); 
				return; 
			case CQLPackage.CREATE_DATA_BASE_CONNECTION_GENERIC:
				sequence_CreateDataBaseGenericConnection(context, (CreateDataBaseConnectionGeneric) semanticObject); 
				return; 
			case CQLPackage.CREATE_DATA_BASE_CONNECTION_JDBC:
				sequence_CreateDataBaseJDBCConnection(context, (CreateDataBaseConnectionJDBC) semanticObject); 
				return; 
			case CQLPackage.CREATE_DATABASE_SINK:
				sequence_CreateDatabaseSink(context, (CreateDatabaseSink) semanticObject); 
				return; 
			case CQLPackage.CREATE_DATABASE_STREAM:
				sequence_CreateDatabaseStream(context, (CreateDatabaseStream) semanticObject); 
				return; 
			case CQLPackage.CREATE_VIEW:
				sequence_CreateView(context, (CreateView) semanticObject); 
				return; 
			case CQLPackage.DROP_CONTEXT_STORE:
				sequence_DropContextStore(context, (DropContextStore) semanticObject); 
				return; 
			case CQLPackage.DROP_DATABASE_CONNECTION:
				sequence_DropDatabaseConnection(context, (DropDatabaseConnection) semanticObject); 
				return; 
			case CQLPackage.DROP_STREAM:
				sequence_DropStream(context, (DropStream) semanticObject); 
				return; 
			case CQLPackage.EQUALITY:
				sequence_Equalitiy(context, (Equality) semanticObject); 
				return; 
			case CQLPackage.EXIST_PREDICATE:
				sequence_ExistPredicate(context, (ExistPredicate) semanticObject); 
				return; 
			case CQLPackage.EXPRESSION_COMPONENT:
				sequence_ExpressionComponent(context, (ExpressionComponent) semanticObject); 
				return; 
			case CQLPackage.EXPRESSION_COMPONENT_AS_ATTRIBUTE:
				sequence_ExpressionComponentAsAttribute(context, (ExpressionComponentAsAttribute) semanticObject); 
				return; 
			case CQLPackage.EXPRESSIONS_MODEL:
				sequence_ExpressionsModel(context, (ExpressionsModel) semanticObject); 
				return; 
			case CQLPackage.FLOAT_CONSTANT:
				if (rule == grammarAccess.getAtomicWithoutAttributeRefRule()) {
					sequence_AtomicWithoutAttributeRef(context, (FloatConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrPredicateRule()
						|| action == grammarAccess.getOrPredicateAccess().getOrPredicateLeftAction_1_0()
						|| rule == grammarAccess.getAndPredicateRule()
						|| action == grammarAccess.getAndPredicateAccess().getAndPredicateLeftAction_1_0()
						|| rule == grammarAccess.getEqualitiyRule()
						|| action == grammarAccess.getEqualitiyAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisionLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (FloatConstant) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case CQLPackage.IN_PREDICATE:
				sequence_InPredicate(context, (InPredicate) semanticObject); 
				return; 
			case CQLPackage.INNER_SELECT:
				sequence_InnerSelect(context, (InnerSelect) semanticObject); 
				return; 
			case CQLPackage.INNER_SELECT2:
				sequence_InnerSelect2(context, (InnerSelect2) semanticObject); 
				return; 
			case CQLPackage.INT_CONSTANT:
				if (rule == grammarAccess.getAtomicWithoutAttributeRefRule()) {
					sequence_AtomicWithoutAttributeRef(context, (IntConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrPredicateRule()
						|| action == grammarAccess.getOrPredicateAccess().getOrPredicateLeftAction_1_0()
						|| rule == grammarAccess.getAndPredicateRule()
						|| action == grammarAccess.getAndPredicateAccess().getAndPredicateLeftAction_1_0()
						|| rule == grammarAccess.getEqualitiyRule()
						|| action == grammarAccess.getEqualitiyAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisionLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (IntConstant) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.MATRIX:
				sequence_AtomicWithoutAttributeRef(context, (Matrix) semanticObject); 
				return; 
			case CQLPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case CQLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case CQLPackage.MUL_OR_DIV:
				sequence_MulOrDiv(context, (MulOrDiv) semanticObject); 
				return; 
			case CQLPackage.NOT:
				sequence_Primary(context, (NOT) semanticObject); 
				return; 
			case CQLPackage.NESTED_SOURCE:
				sequence_NestedSource(context, (NestedSource) semanticObject); 
				return; 
			case CQLPackage.OR_PREDICATE:
				sequence_OrPredicate(context, (OrPredicate) semanticObject); 
				return; 
			case CQLPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case CQLPackage.QUANTIFICATION_PREDICATE:
				sequence_QuantificationPredicate(context, (QuantificationPredicate) semanticObject); 
				return; 
			case CQLPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case CQLPackage.RIGHTS_MANAGEMENT:
				sequence_RightsManagement(context, (RightsManagement) semanticObject); 
				return; 
			case CQLPackage.ROLE_MANAGEMENT:
				sequence_RoleManagement(context, (RoleManagement) semanticObject); 
				return; 
			case CQLPackage.SCHEMA_DEFINITION:
				sequence_SchemaDefinition(context, (SchemaDefinition) semanticObject); 
				return; 
			case CQLPackage.SELECT_ARGUMENT:
				sequence_SelectArgument(context, (SelectArgument) semanticObject); 
				return; 
			case CQLPackage.SELECT_EXPRESSION:
				if (rule == grammarAccess.getSelectExpressionOnlyWithAttributeRule()) {
					sequence_SelectExpressionOnlyWithAttribute(context, (SelectExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSelectExpressionRule()) {
					sequence_SelectExpression(context, (SelectExpression) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.SIMPLE_SELECT:
				sequence_SimpleSelect(context, (SimpleSelect) semanticObject); 
				return; 
			case CQLPackage.SIMPLE_SOURCE:
				sequence_SimpleSource(context, (SimpleSource) semanticObject); 
				return; 
			case CQLPackage.STAR:
				sequence_Star(context, (Star) semanticObject); 
				return; 
			case CQLPackage.STAR_EXPRESSION:
				sequence_StarExpression(context, (StarExpression) semanticObject); 
				return; 
			case CQLPackage.STARTHING:
				sequence_Starthing(context, (Starthing) semanticObject); 
				return; 
			case CQLPackage.STREAM_TO:
				sequence_StreamTo(context, (StreamTo) semanticObject); 
				return; 
			case CQLPackage.STRING_CONSTANT:
				if (rule == grammarAccess.getAtomicWithoutAttributeRefRule()) {
					sequence_AtomicWithoutAttributeRef(context, (StringConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrPredicateRule()
						|| action == grammarAccess.getOrPredicateAccess().getOrPredicateLeftAction_1_0()
						|| rule == grammarAccess.getAndPredicateRule()
						|| action == grammarAccess.getAndPredicateAccess().getAndPredicateLeftAction_1_0()
						|| rule == grammarAccess.getEqualitiyRule()
						|| action == grammarAccess.getEqualitiyAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisionLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (StringConstant) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.TIMEBASED_WINDOW:
				sequence_TimebasedWindow(context, (TimebasedWindow) semanticObject); 
				return; 
			case CQLPackage.TUPLEBASED_WINDOW:
				sequence_TuplebasedWindow(context, (TuplebasedWindow) semanticObject); 
				return; 
			case CQLPackage.UNDBOUNDED_WINDOW:
				sequence_UnboundedWindow(context, (UndboundedWindow) semanticObject); 
				return; 
			case CQLPackage.USER_MANAGEMENT:
				sequence_UserManagement(context, (UserManagement) semanticObject); 
				return; 
			case CQLPackage.VECTOR:
				sequence_AtomicWithoutAttributeRef(context, (Vector) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AccessFramework returns AccessFramework
	 *
	 * Constraint:
	 *     (
	 *         wrapper=STRING 
	 *         protocol=STRING 
	 *         transport=STRING 
	 *         datahandler=STRING 
	 *         (keys+=STRING (values+=STRING | values+=PATH))+ 
	 *         (keys+=STRING (values+=STRING | values+=PATH))*
	 *     )
	 */
	protected void sequence_AccessFramework(ISerializationContext context, AccessFramework semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Alias returns Alias
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Alias(ISerializationContext context, Alias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.ALIAS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.ALIAS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAliasAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndPredicate
	 *     OrPredicate returns AndPredicate
	 *     OrPredicate.OrPredicate_1_0 returns AndPredicate
	 *     AndPredicate returns AndPredicate
	 *     AndPredicate.AndPredicate_1_0 returns AndPredicate
	 *
	 * Constraint:
	 *     (left=AndPredicate_AndPredicate_1_0 right=Equalitiy)
	 */
	protected void sequence_AndPredicate(ISerializationContext context, AndPredicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.AND_PREDICATE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.AND_PREDICATE__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.AND_PREDICATE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.AND_PREDICATE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndPredicateAccess().getAndPredicateLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndPredicateAccess().getRightEqualitiyParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicWithoutAttributeRef returns BoolConstant
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_AtomicWithoutAttributeRef(ISerializationContext context, BoolConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.BOOL_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.BOOL_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicWithoutAttributeRefAccess().getValueBOOLEANParserRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicWithoutAttributeRef returns FloatConstant
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_AtomicWithoutAttributeRef(ISerializationContext context, FloatConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.FLOAT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.FLOAT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicWithoutAttributeRefAccess().getValueFLOATTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicWithoutAttributeRef returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_AtomicWithoutAttributeRef(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicWithoutAttributeRefAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicWithoutAttributeRef returns Matrix
	 *
	 * Constraint:
	 *     value=MATRIX_FLOAT
	 */
	protected void sequence_AtomicWithoutAttributeRef(ISerializationContext context, Matrix semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.MATRIX__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.MATRIX__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicWithoutAttributeRefAccess().getValueMATRIX_FLOATTerminalRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicWithoutAttributeRef returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AtomicWithoutAttributeRef(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicWithoutAttributeRefAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicWithoutAttributeRef returns Vector
	 *
	 * Constraint:
	 *     value=VECTOR_FLOAT
	 */
	protected void sequence_AtomicWithoutAttributeRef(ISerializationContext context, Vector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.VECTOR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.VECTOR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicWithoutAttributeRefAccess().getValueVECTOR_FLOATTerminalRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AttributeRef
	 *     OrPredicate returns AttributeRef
	 *     OrPredicate.OrPredicate_1_0 returns AttributeRef
	 *     AndPredicate returns AttributeRef
	 *     AndPredicate.AndPredicate_1_0 returns AttributeRef
	 *     Equalitiy returns AttributeRef
	 *     Equalitiy.Equality_1_0 returns AttributeRef
	 *     Comparison returns AttributeRef
	 *     Comparison.Comparision_1_0 returns AttributeRef
	 *     PlusOrMinus returns AttributeRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns AttributeRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns AttributeRef
	 *     MulOrDiv returns AttributeRef
	 *     MulOrDiv.MulOrDiv_1_0 returns AttributeRef
	 *     Primary returns AttributeRef
	 *     Atomic returns AttributeRef
	 *
	 * Constraint:
	 *     value=AttributeWithoutAliasDefinition
	 */
	protected void sequence_Atomic(ISerializationContext context, AttributeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.ATTRIBUTE_REF__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.ATTRIBUTE_REF__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueAttributeWithoutAliasDefinitionParserRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolConstant
	 *     OrPredicate returns BoolConstant
	 *     OrPredicate.OrPredicate_1_0 returns BoolConstant
	 *     AndPredicate returns BoolConstant
	 *     AndPredicate.AndPredicate_1_0 returns BoolConstant
	 *     Equalitiy returns BoolConstant
	 *     Equalitiy.Equality_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.Comparision_1_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     Atomic returns BoolConstant
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_Atomic(ISerializationContext context, BoolConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.BOOL_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.BOOL_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueBOOLEANParserRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ComplexPredicateRef
	 *     OrPredicate returns ComplexPredicateRef
	 *     OrPredicate.OrPredicate_1_0 returns ComplexPredicateRef
	 *     AndPredicate returns ComplexPredicateRef
	 *     AndPredicate.AndPredicate_1_0 returns ComplexPredicateRef
	 *     Equalitiy returns ComplexPredicateRef
	 *     Equalitiy.Equality_1_0 returns ComplexPredicateRef
	 *     Comparison returns ComplexPredicateRef
	 *     Comparison.Comparision_1_0 returns ComplexPredicateRef
	 *     PlusOrMinus returns ComplexPredicateRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns ComplexPredicateRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns ComplexPredicateRef
	 *     MulOrDiv returns ComplexPredicateRef
	 *     MulOrDiv.MulOrDiv_1_0 returns ComplexPredicateRef
	 *     Primary returns ComplexPredicateRef
	 *     Atomic returns ComplexPredicateRef
	 *
	 * Constraint:
	 *     value=ComplexPredicate
	 */
	protected void sequence_Atomic(ISerializationContext context, ComplexPredicateRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.COMPLEX_PREDICATE_REF__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.COMPLEX_PREDICATE_REF__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueComplexPredicateParserRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FloatConstant
	 *     OrPredicate returns FloatConstant
	 *     OrPredicate.OrPredicate_1_0 returns FloatConstant
	 *     AndPredicate returns FloatConstant
	 *     AndPredicate.AndPredicate_1_0 returns FloatConstant
	 *     Equalitiy returns FloatConstant
	 *     Equalitiy.Equality_1_0 returns FloatConstant
	 *     Comparison returns FloatConstant
	 *     Comparison.Comparision_1_0 returns FloatConstant
	 *     PlusOrMinus returns FloatConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns FloatConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns FloatConstant
	 *     MulOrDiv returns FloatConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns FloatConstant
	 *     Primary returns FloatConstant
	 *     Atomic returns FloatConstant
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_Atomic(ISerializationContext context, FloatConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.FLOAT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.FLOAT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueFLOATTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntConstant
	 *     OrPredicate returns IntConstant
	 *     OrPredicate.OrPredicate_1_0 returns IntConstant
	 *     AndPredicate returns IntConstant
	 *     AndPredicate.AndPredicate_1_0 returns IntConstant
	 *     Equalitiy returns IntConstant
	 *     Equalitiy.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparision_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     Atomic returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringConstant
	 *     OrPredicate returns StringConstant
	 *     OrPredicate.OrPredicate_1_0 returns StringConstant
	 *     AndPredicate returns StringConstant
	 *     AndPredicate.AndPredicate_1_0 returns StringConstant
	 *     Equalitiy returns StringConstant
	 *     Equalitiy.Equality_1_0 returns StringConstant
	 *     Comparison returns StringConstant
	 *     Comparison.Comparision_1_0 returns StringConstant
	 *     PlusOrMinus returns StringConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns StringConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns StringConstant
	 *     MulOrDiv returns StringConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns StringConstant
	 *     Primary returns StringConstant
	 *     Atomic returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeForSelectExpression returns Attribute
	 *
	 * Constraint:
	 *     name=QualifiedAttributenameWithoutSpecialChars
	 */
	protected void sequence_AttributeForSelectExpression(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.ATTRIBUTE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeForSelectExpressionAccess().getNameQualifiedAttributenameWithoutSpecialCharsParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeWithoutAliasDefinition returns Attribute
	 *
	 * Constraint:
	 *     name=QualifiedAttributename
	 */
	protected void sequence_AttributeWithoutAliasDefinition(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.ATTRIBUTE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeWithoutAliasDefinitionAccess().getNameQualifiedAttributenameParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=QualifiedAttributename alias=Alias?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     (
	 *         type=DropStream | 
	 *         type=UserManagement | 
	 *         type=RightsManagement | 
	 *         type=RoleManagement | 
	 *         type=CreateDataBaseGenericConnection | 
	 *         type=CreateDataBaseJDBCConnection | 
	 *         type=DropDatabaseConnection | 
	 *         type=CreateContextStore | 
	 *         type=DropContextStore
	 *     )
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparision
	 *     OrPredicate returns Comparision
	 *     OrPredicate.OrPredicate_1_0 returns Comparision
	 *     AndPredicate returns Comparision
	 *     AndPredicate.AndPredicate_1_0 returns Comparision
	 *     Equalitiy returns Comparision
	 *     Equalitiy.Equality_1_0 returns Comparision
	 *     Comparison returns Comparision
	 *     Comparison.Comparision_1_0 returns Comparision
	 *
	 * Constraint:
	 *     (left=Comparison_Comparision_1_0 op=COMPARE_OPERATOR right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparision semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.COMPARISION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.COMPARISION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.COMPARISION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.COMPARISION__OP));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.COMPARISION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.COMPARISION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getComparisionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getOpCOMPARE_OPERATORParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComplexPredicate returns ComplexPredicate
	 *
	 * Constraint:
	 *     ((quantification=QuantificationPredicate | exists=ExistPredicate | in=InPredicate) select=InnerSelect)
	 */
	protected void sequence_ComplexPredicate(ISerializationContext context, ComplexPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexSelect returns ComplexSelect
	 *
	 * Constraint:
	 *     (left=SimpleSelect ((operation='UNION' | operation='DIFFERENCE' | operation='INTERSECTION') right=SimpleSelect)?)
	 */
	protected void sequence_ComplexSelect(ISerializationContext context, ComplexSelect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextStoreType returns ContextStoreType
	 *
	 * Constraint:
	 *     (type='SINGLE' | (type='MULTI' size=INT partition=INT?))
	 */
	protected void sequence_ContextStoreType(ISerializationContext context, ContextStoreType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CreateAccessFramework returns CreateAccessFramework
	 *
	 * Constraint:
	 *     (attributes=SchemaDefinition pars=AccessFramework)
	 */
	protected void sequence_CreateAccessFramework(ISerializationContext context, CreateAccessFramework semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_ACCESS_FRAMEWORK__ATTRIBUTES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_ACCESS_FRAMEWORK__ATTRIBUTES));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_ACCESS_FRAMEWORK__PARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_ACCESS_FRAMEWORK__PARS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateAccessFrameworkAccess().getAttributesSchemaDefinitionParserRuleCall_0_0(), semanticObject.getAttributes());
		feeder.accept(grammarAccess.getCreateAccessFrameworkAccess().getParsAccessFrameworkParserRuleCall_1_0(), semanticObject.getPars());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CreateChannelFormatViaFile returns CreateChannelFormatViaFile
	 *
	 * Constraint:
	 *     (attributes=SchemaDefinition filename=STRING type=ID)
	 */
	protected void sequence_CreateChannelFormatViaFile(ISerializationContext context, CreateChannelFormatViaFile semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FORMAT_VIA_FILE__ATTRIBUTES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FORMAT_VIA_FILE__ATTRIBUTES));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FORMAT_VIA_FILE__FILENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FORMAT_VIA_FILE__FILENAME));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FORMAT_VIA_FILE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FORMAT_VIA_FILE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateChannelFormatViaFileAccess().getAttributesSchemaDefinitionParserRuleCall_0_0(), semanticObject.getAttributes());
		feeder.accept(grammarAccess.getCreateChannelFormatViaFileAccess().getFilenameSTRINGTerminalRuleCall_2_0(), semanticObject.getFilename());
		feeder.accept(grammarAccess.getCreateChannelFormatViaFileAccess().getTypeIDTerminalRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CreateChannelFrameworkViaPort returns CreateChannelFrameworkViaPort
	 *
	 * Constraint:
	 *     (attributes=SchemaDefinition host=ID port=INT)
	 */
	protected void sequence_CreateChannelFrameworkViaPort(ISerializationContext context, CreateChannelFrameworkViaPort semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FRAMEWORK_VIA_PORT__ATTRIBUTES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FRAMEWORK_VIA_PORT__ATTRIBUTES));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FRAMEWORK_VIA_PORT__HOST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FRAMEWORK_VIA_PORT__HOST));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FRAMEWORK_VIA_PORT__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_CHANNEL_FRAMEWORK_VIA_PORT__PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateChannelFrameworkViaPortAccess().getAttributesSchemaDefinitionParserRuleCall_0_0(), semanticObject.getAttributes());
		feeder.accept(grammarAccess.getCreateChannelFrameworkViaPortAccess().getHostIDTerminalRuleCall_2_0(), semanticObject.getHost());
		feeder.accept(grammarAccess.getCreateChannelFrameworkViaPortAccess().getPortINTTerminalRuleCall_4_0(), semanticObject.getPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CreateContextStore returns CreateContextStore
	 *
	 * Constraint:
	 *     (attributes=SchemaDefinition contextType=ContextStoreType)
	 */
	protected void sequence_CreateContextStore(ISerializationContext context, CreateContextStore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_CONTEXT_STORE__ATTRIBUTES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_CONTEXT_STORE__ATTRIBUTES));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_CONTEXT_STORE__CONTEXT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_CONTEXT_STORE__CONTEXT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateContextStoreAccess().getAttributesSchemaDefinitionParserRuleCall_4_0(), semanticObject.getAttributes());
		feeder.accept(grammarAccess.getCreateContextStoreAccess().getContextTypeContextStoreTypeParserRuleCall_6_0(), semanticObject.getContextType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CreateDataBaseGenericConnection returns CreateDataBaseConnectionGeneric
	 *
	 * Constraint:
	 *     (name=ID driver=ID source=ID (host=ID port=INT)? (user=ID password=ID lazy='NO_LAZY_CONNECTION_CHECK'?)?)
	 */
	protected void sequence_CreateDataBaseGenericConnection(ISerializationContext context, CreateDataBaseConnectionGeneric semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CreateDataBaseJDBCConnection returns CreateDataBaseConnectionJDBC
	 *
	 * Constraint:
	 *     (name=ID server=ID (user=ID password=ID lazy='NO_LAZY_CONNECTION_CHECK'?)?)
	 */
	protected void sequence_CreateDataBaseJDBCConnection(ISerializationContext context, CreateDataBaseConnectionJDBC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CreateDatabaseSink returns CreateDatabaseSink
	 *
	 * Constraint:
	 *     (name=ID database=ID table=ID (option='DROP' | option='TRUNCATE')?)
	 */
	protected void sequence_CreateDatabaseSink(ISerializationContext context, CreateDatabaseSink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CreateDatabaseStream returns CreateDatabaseStream
	 *
	 * Constraint:
	 *     (attributes=SchemaDefinition database=ID table=ID (size=INT unit=Time)?)
	 */
	protected void sequence_CreateDatabaseStream(ISerializationContext context, CreateDatabaseStream semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CreateView returns CreateView
	 *
	 * Constraint:
	 *     (name=ID select=InnerSelect)
	 */
	protected void sequence_CreateView(ISerializationContext context, CreateView semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_VIEW__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_VIEW__NAME));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_VIEW__SELECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_VIEW__SELECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateViewAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCreateViewAccess().getSelectInnerSelectParserRuleCall_2_0(), semanticObject.getSelect());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Create returns Create
	 *
	 * Constraint:
	 *     (
	 *         (type='STREAM' | type='SINK' | type='VIEW') 
	 *         (
	 *             create=CreateAccessFramework | 
	 *             create=CreateChannelFrameworkViaPort | 
	 *             create=CreateChannelFormatViaFile | 
	 *             create=CreateDatabaseStream | 
	 *             create=CreateDatabaseSink | 
	 *             create=CreateView
	 *         )
	 *     )
	 */
	protected void sequence_Create(ISerializationContext context, Create semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DropContextStore returns DropContextStore
	 *
	 * Constraint:
	 *     (name=ID exists='EXISTS'?)
	 */
	protected void sequence_DropContextStore(ISerializationContext context, DropContextStore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DropDatabaseConnection returns DropDatabaseConnection
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DropDatabaseConnection(ISerializationContext context, DropDatabaseConnection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.DROP_DATABASE_CONNECTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.DROP_DATABASE_CONNECTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropDatabaseConnectionAccess().getNameIDTerminalRuleCall_4_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DropStream returns DropStream
	 *
	 * Constraint:
	 *     ((name='SINK' | name='STREAM' | name='VIEW') stream=ID exists='IF'?)
	 */
	protected void sequence_DropStream(ISerializationContext context, DropStream semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     OrPredicate returns Equality
	 *     OrPredicate.OrPredicate_1_0 returns Equality
	 *     AndPredicate returns Equality
	 *     AndPredicate.AndPredicate_1_0 returns Equality
	 *     Equalitiy returns Equality
	 *     Equalitiy.Equality_1_0 returns Equality
	 *
	 * Constraint:
	 *     (left=Equalitiy_Equality_1_0 op=EQUALITIY_OPERATOR right=Comparison)
	 */
	protected void sequence_Equalitiy(ISerializationContext context, Equality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.EQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.EQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.EQUALITY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.EQUALITY__OP));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.EQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.EQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualitiyAccess().getEqualityLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualitiyAccess().getOpEQUALITIY_OPERATORParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getEqualitiyAccess().getRightComparisonParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExistPredicate returns ExistPredicate
	 *
	 * Constraint:
	 *     predicate='EXISTS'
	 */
	protected void sequence_ExistPredicate(ISerializationContext context, ExistPredicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.EXIST_PREDICATE__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.EXIST_PREDICATE__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistPredicateAccess().getPredicateEXISTSKeyword_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionComponentAsAttribute returns ExpressionComponentAsAttribute
	 *
	 * Constraint:
	 *     value=AttributeForSelectExpression
	 */
	protected void sequence_ExpressionComponentAsAttribute(ISerializationContext context, ExpressionComponentAsAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionComponentAsAttributeAccess().getValueAttributeForSelectExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionComponent returns ExpressionComponent
	 *
	 * Constraint:
	 *     (value=Function | value=AtomicWithoutAttributeRef)
	 */
	protected void sequence_ExpressionComponent(ISerializationContext context, ExpressionComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionsModel returns ExpressionsModel
	 *
	 * Constraint:
	 *     elements+=Expression
	 */
	protected void sequence_ExpressionsModel(ISerializationContext context, ExpressionsModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID (value=SelectExpression | value=SelectExpressionOnlyWithAttribute | value=StarExpression))
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InPredicate returns InPredicate
	 *
	 * Constraint:
	 *     (attribute=AttributeWithoutAliasDefinition predicate='IN')
	 */
	protected void sequence_InPredicate(ISerializationContext context, InPredicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.IN_PREDICATE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.IN_PREDICATE__ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.IN_PREDICATE__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.IN_PREDICATE__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInPredicateAccess().getAttributeAttributeWithoutAliasDefinitionParserRuleCall_0_0(), semanticObject.getAttribute());
		feeder.accept(grammarAccess.getInPredicateAccess().getPredicateINKeyword_1_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InnerSelect2 returns InnerSelect2
	 *
	 * Constraint:
	 *     select=SimpleSelect
	 */
	protected void sequence_InnerSelect2(ISerializationContext context, InnerSelect2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.INNER_SELECT2__SELECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.INNER_SELECT2__SELECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInnerSelect2Access().getSelectSimpleSelectParserRuleCall_0(), semanticObject.getSelect());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InnerSelect returns InnerSelect
	 *
	 * Constraint:
	 *     select=SimpleSelect
	 */
	protected void sequence_InnerSelect(ISerializationContext context, InnerSelect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.INNER_SELECT__SELECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.INNER_SELECT__SELECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInnerSelectAccess().getSelectSimpleSelectParserRuleCall_1_0(), semanticObject.getSelect());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (components+=Query | components+=Command)+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulOrDiv
	 *     OrPredicate returns MulOrDiv
	 *     OrPredicate.OrPredicate_1_0 returns MulOrDiv
	 *     AndPredicate returns MulOrDiv
	 *     AndPredicate.AndPredicate_1_0 returns MulOrDiv
	 *     Equalitiy returns MulOrDiv
	 *     Equalitiy.Equality_1_0 returns MulOrDiv
	 *     Comparison returns MulOrDiv
	 *     Comparison.Comparision_1_0 returns MulOrDiv
	 *     PlusOrMinus returns MulOrDiv
	 *     PlusOrMinus.Plus_1_0_0_0 returns MulOrDiv
	 *     PlusOrMinus.Minus_1_0_1_0 returns MulOrDiv
	 *     MulOrDiv returns MulOrDiv
	 *     MulOrDiv.MulOrDiv_1_0 returns MulOrDiv
	 *
	 * Constraint:
	 *     (left=MulOrDiv_MulOrDiv_1_0 (op='/' | op='*') right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, MulOrDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Source returns NestedSource
	 *     NestedSource returns NestedSource
	 *
	 * Constraint:
	 *     (statement=InnerSelect alias=Alias)
	 */
	protected void sequence_NestedSource(ISerializationContext context, NestedSource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.NESTED_SOURCE__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.NESTED_SOURCE__STATEMENT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.SOURCE__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.SOURCE__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNestedSourceAccess().getStatementInnerSelectParserRuleCall_1_0(), semanticObject.getStatement());
		feeder.accept(grammarAccess.getNestedSourceAccess().getAliasAliasParserRuleCall_3_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrPredicate
	 *     OrPredicate returns OrPredicate
	 *     OrPredicate.OrPredicate_1_0 returns OrPredicate
	 *
	 * Constraint:
	 *     (left=OrPredicate_OrPredicate_1_0 right=AndPredicate)
	 */
	protected void sequence_OrPredicate(ISerializationContext context, OrPredicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.OR_PREDICATE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.OR_PREDICATE__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.OR_PREDICATE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.OR_PREDICATE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrPredicateAccess().getOrPredicateLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrPredicateAccess().getRightAndPredicateParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     OrPredicate returns Minus
	 *     OrPredicate.OrPredicate_1_0 returns Minus
	 *     AndPredicate returns Minus
	 *     AndPredicate.AndPredicate_1_0 returns Minus
	 *     Equalitiy returns Minus
	 *     Equalitiy.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparision_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     OrPredicate returns Plus
	 *     OrPredicate.OrPredicate_1_0 returns Plus
	 *     AndPredicate returns Plus
	 *     AndPredicate.AndPredicate_1_0 returns Plus
	 *     Equalitiy returns Plus
	 *     Equalitiy.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparision_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Bracket
	 *     OrPredicate returns Bracket
	 *     OrPredicate.OrPredicate_1_0 returns Bracket
	 *     AndPredicate returns Bracket
	 *     AndPredicate.AndPredicate_1_0 returns Bracket
	 *     Equalitiy returns Bracket
	 *     Equalitiy.Equality_1_0 returns Bracket
	 *     Comparison returns Bracket
	 *     Comparison.Comparision_1_0 returns Bracket
	 *     PlusOrMinus returns Bracket
	 *     PlusOrMinus.Plus_1_0_0_0 returns Bracket
	 *     PlusOrMinus.Minus_1_0_1_0 returns Bracket
	 *     MulOrDiv returns Bracket
	 *     MulOrDiv.MulOrDiv_1_0 returns Bracket
	 *     Primary returns Bracket
	 *
	 * Constraint:
	 *     inner=Expression
	 */
	protected void sequence_Primary(ISerializationContext context, Bracket semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.BRACKET__INNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.BRACKET__INNER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getInnerExpressionParserRuleCall_0_2_0(), semanticObject.getInner());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NOT
	 *     OrPredicate returns NOT
	 *     OrPredicate.OrPredicate_1_0 returns NOT
	 *     AndPredicate returns NOT
	 *     AndPredicate.AndPredicate_1_0 returns NOT
	 *     Equalitiy returns NOT
	 *     Equalitiy.Equality_1_0 returns NOT
	 *     Comparison returns NOT
	 *     Comparison.Comparision_1_0 returns NOT
	 *     PlusOrMinus returns NOT
	 *     PlusOrMinus.Plus_1_0_0_0 returns NOT
	 *     PlusOrMinus.Minus_1_0_1_0 returns NOT
	 *     MulOrDiv returns NOT
	 *     MulOrDiv.MulOrDiv_1_0 returns NOT
	 *     Primary returns NOT
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, NOT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     QuantificationPredicate returns QuantificationPredicate
	 *
	 * Constraint:
	 *     (attribute=AttributeWithoutAliasDefinition operator=COMPARE_OPERATOR (predicate='ALL' | predicate='ANY' | predicate='SOME'))
	 */
	protected void sequence_QuantificationPredicate(ISerializationContext context, QuantificationPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Query returns Query
	 *
	 * Constraint:
	 *     (type=Create | type=StreamTo | type=ComplexSelect)
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RightsManagement returns RightsManagement
	 *
	 * Constraint:
	 *     (
	 *         (name='GRANT' operations+=ID operations+=ID* (operations2+=ID operations2+=ID*)? user=ID) | 
	 *         (name='REVOKE' operations+=ID operations+=ID* (operations2+=ID operations2+=ID*)? user=ID)
	 *     )
	 */
	protected void sequence_RightsManagement(ISerializationContext context, RightsManagement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RoleManagement returns RoleManagement
	 *
	 * Constraint:
	 *     ((name='GRANT' operations+=ID operations+=ID* user=ID) | (name='REVOKE' operations+=ID operations+=ID* user=ID))
	 */
	protected void sequence_RoleManagement(ISerializationContext context, RoleManagement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SchemaDefinition returns SchemaDefinition
	 *
	 * Constraint:
	 *     (name=ID arguments+=ID arguments+=ID (arguments+=ID arguments+=ID)*)
	 */
	protected void sequence_SchemaDefinition(ISerializationContext context, SchemaDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectArgument returns SelectArgument
	 *
	 * Constraint:
	 *     (attribute=Attribute | expression=SelectExpression)
	 */
	protected void sequence_SelectArgument(ISerializationContext context, SelectArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectExpressionOnlyWithAttribute returns SelectExpression
	 *
	 * Constraint:
	 *     expressions+=ExpressionComponentAsAttribute
	 */
	protected void sequence_SelectExpressionOnlyWithAttribute(ISerializationContext context, SelectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectExpression returns SelectExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 expressions+=ExpressionComponent 
	 *                 (operators+=ARITHMETIC_OPERATOR (expressions+=ExpressionComponent | expressions+=ExpressionComponentAsAttribute))*
	 *             ) | 
	 *             (
	 *                 expressions+=ExpressionComponentAsAttribute 
	 *                 operators+=ARITHMETIC_OPERATOR 
	 *                 (expressions+=ExpressionComponent | expressions+=ExpressionComponentAsAttribute)
	 *             )
	 *         ) 
	 *         alias=Alias?
	 *     )
	 */
	protected void sequence_SelectExpression(ISerializationContext context, SelectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleSelect returns SimpleSelect
	 *
	 * Constraint:
	 *     (
	 *         distinct='DISTINCT'? 
	 *         (arguments+=SelectArgument+ arguments+=SelectArgument*)? 
	 *         sources+=Source+ 
	 *         sources+=Source* 
	 *         predicates=ExpressionsModel? 
	 *         (order+=Attribute+ order+=Attribute*)? 
	 *         having=ExpressionsModel?
	 *     )
	 */
	protected void sequence_SimpleSelect(ISerializationContext context, SimpleSelect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Source returns SimpleSource
	 *     SimpleSource returns SimpleSource
	 *
	 * Constraint:
	 *     (name=QualifiedSourcename window=WindowOperator? alias=Alias?)
	 */
	protected void sequence_SimpleSource(ISerializationContext context, SimpleSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StarExpression returns StarExpression
	 *
	 * Constraint:
	 *     expressions+=Star
	 */
	protected void sequence_StarExpression(ISerializationContext context, StarExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Star returns Star
	 *
	 * Constraint:
	 *     value=Starthing
	 */
	protected void sequence_Star(ISerializationContext context, Star semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStarAccess().getValueStarthingParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Starthing returns Starthing
	 *
	 * Constraint:
	 *     {Starthing}
	 */
	protected void sequence_Starthing(ISerializationContext context, Starthing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StreamTo returns StreamTo
	 *
	 * Constraint:
	 *     (name=ID (statement=InnerSelect2 | inputname=ID))
	 */
	protected void sequence_StreamTo(ISerializationContext context, StreamTo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WindowOperator returns TimebasedWindow
	 *     TimebasedWindow returns TimebasedWindow
	 *
	 * Constraint:
	 *     (size=INT unit=Time? (advance_size=INT advance_unit=Time?)?)
	 */
	protected void sequence_TimebasedWindow(ISerializationContext context, TimebasedWindow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WindowOperator returns TuplebasedWindow
	 *     TuplebasedWindow returns TuplebasedWindow
	 *
	 * Constraint:
	 *     (size=INT advance_size=INT? partition_attribute=Attribute?)
	 */
	protected void sequence_TuplebasedWindow(ISerializationContext context, TuplebasedWindow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WindowOperator returns UndboundedWindow
	 *     UnboundedWindow returns UndboundedWindow
	 *
	 * Constraint:
	 *     {UndboundedWindow}
	 */
	protected void sequence_UnboundedWindow(ISerializationContext context, UndboundedWindow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UserManagement returns UserManagement
	 *
	 * Constraint:
	 *     ((name='CREATE' | name='ALTER' | name='DROP') (subject='USER' | subject='ROLE' | subject='TENANT') subjectName=ID password=STRING?)
	 */
	protected void sequence_UserManagement(ISerializationContext context, UserManagement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
