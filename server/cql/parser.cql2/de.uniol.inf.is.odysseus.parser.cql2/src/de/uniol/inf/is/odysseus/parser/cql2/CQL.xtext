grammar de.uniol.inf.is.odysseus.parser.cql2.CQL with org.eclipse.xtext.common.Terminals

generate cQL "http://www.uniol.de/inf/is/odysseus/parser/cql2/CQL"

Model:
	((components+=(Query | Command)) (';')?)*;

@Override 
terminal ID:
	(LETTER | SPECIAL_CHARS) (LETTER | SPECIAL_CHARS | INT)*;

terminal LETTER:
	('a'..'z' | 'A'..'Z');

terminal SPECIAL_CHARS:
	(':' | '_' | '{' | '}' | '$');

terminal FLOAT:
	INT '.' INT;

terminal BIT:
	('0' | '1');

terminal BYTE:
	BIT BIT BIT BIT BIT BIT BIT BIT;

BOOLEAN:
	('FALSE' | 'TRUE');

terminal VECTOR_FLOAT:
	'[' (FLOAT)+ (',' FLOAT)* ']';

terminal MATRIX_FLOAT:
	'[' (FLOAT)+ (',' FLOAT)* (';' (FLOAT)+ (',' FLOAT)*)* ']';

SystemVariable:
	('$' '{' ID '}')| /// 
	(ID '()')
;

enum Time:
	NULL
	| NANOSECOND
	| NANOSECONDS
	| MILLISECOND
	| SECOND
	| MINUTE
	| HOUR
	| WEEK
	| MILLISECONDS
	| SECONDS
	| MINUTES
	| HOURS
	| WEEKS;

QualifiedAttributename:
	(ID
	| (QualifiedSourcename '.' ID)
	| (QualifiedSourcename '.' '*')
	| SystemVariable);

QualifiedAttributenameWithoutSpecialChars:
	(ID | (QualifiedSourcename '.' ID));

QualifiedSourcename:
	ID;

Query:
	type=(Create
	| StreamTo
	| ComplexSelect);

Command:
	type=(DropStream
	| UserManagement
	| RightsManagement
	| RoleManagement
	| CreateDataBaseGenericConnection
	| CreateDataBaseJDBCConnection
	| DropDatabaseConnection
	| CreateContextStore
	| DropContextStore);

SimpleSelect:
	{SimpleSelect}
	('SELECT' (distinct='DISTINCT')?
	('*' | (arguments+=SelectArgument+ (',' arguments+=SelectArgument)*))
	('FROM' sources+=Source+ (',' sources+=Source)*)
	('WHERE' predicates=ExpressionsModel)?
	('GROUP' 'BY' order+=Attribute+ (',' order+=Attribute)*)?
	('HAVING' having=ExpressionsModel)?);

ComplexSelect:
	{ComplexSelect}
	left=SimpleSelect
	(operation=('UNION' | 'DIFFERENCE' | 'INTERSECTION') right=SimpleSelect)?;

InnerSelect:
	'(' select=SimpleSelect ')';

InnerSelect2:
	select=SimpleSelect;

SelectArgument:
	(attribute=Attribute | expression=SelectExpression);

Source:
	(SimpleSource | NestedSource);

SimpleSource returns Source:
	{SimpleSource}
	name=QualifiedSourcename (window=WindowOperator)? ('AS' alias=Alias)?;

NestedSource returns Source:
	{NestedSource}
	statement=InnerSelect 'AS' alias=Alias;

Attribute:
	name=QualifiedAttributename
	('AS' alias=Alias)?;

AttributeWithoutAliasDefinition returns Attribute:
	name=QualifiedAttributename;

AttributeForSelectExpression returns Attribute:
	(name=QualifiedAttributenameWithoutSpecialChars);

ComplexPredicate:
	((quantification=QuantificationPredicate)
	| (exists=ExistPredicate)
	| (in=InPredicate))
	select=InnerSelect;

QuantificationPredicate:
	attribute=AttributeWithoutAliasDefinition
	operator=COMPARE_OPERATOR
	predicate=('ALL' | 'ANY' | 'SOME');

ExistPredicate:
	predicate=('EXISTS');

InPredicate:
	attribute=AttributeWithoutAliasDefinition
	predicate=('IN');

AndOperator:
	'AND';

OrOperator:
	'OR';

EQUALITIY_OPERATOR:
	('=' | '!=');

COMPARE_OPERATOR:
	('>=' | '<=' | '<' | '>');

ARITHMETIC_OPERATOR:
	ADD_OPERATOR
	| MINUS_OPERATOR
	| MUL_OR_DIV_OPERATOR
	| EXPONENT_OPERATOR;

EXPONENT_OPERATOR:
	'^';

MUL_OR_DIV_OPERATOR:
	('/' | '*');

ADD_OPERATOR:
	'+';

MINUS_OPERATOR:
	'-';

SelectExpression:
	((expressions+=ExpressionComponent
	(operators+=ARITHMETIC_OPERATOR
	expressions+=(ExpressionComponent | ExpressionComponentAsAttribute))*)
	| (expressions+=ExpressionComponentAsAttribute
	(operators+=ARITHMETIC_OPERATOR
	expressions+=(ExpressionComponent | ExpressionComponentAsAttribute))))
	('AS' alias=Alias)? //TODO Add SelectExpression without an alias
;

SelectExpressionOnlyWithAttribute returns SelectExpression:
	expressions+=ExpressionComponentAsAttribute;

	//Is either a map function or an aggregation function. This depends 
//on the given name and is decided by the generator on runtime. Also
//checked is that an aggregation is no part of a select expression like
//SELECT attr1 + 10 - SUM(attr1) FROM.., but a select expression can be 
//a part of an aggregation like AVG(attr1 + DolToEur(attr2)).//TODO Not working currently
Function returns ExpressionComponent:
	{Function}
	name=ID
	'('
	value=(SelectExpression | SelectExpressionOnlyWithAttribute | StarExpression)
	')';
	//Determines the structure of a component of a select expression
ExpressionComponent:
	value=(Function | AtomicWithoutAttributeRef);

StarExpression returns SelectExpression:
	{StarExpression} expressions+=Star;

Star returns ExpressionComponent:
	{Star}
	value=Starthing;

Starthing:
	{Starthing}
	'*';

ExpressionComponentAsAttribute returns ExpressionComponent:
	{ExpressionComponentAsAttribute}
	value=AttributeForSelectExpression;

Alias:
	name=ID;

AccessFramework:
	'WRAPPER' wrapper=STRING
	'PROTOCOL' protocol=STRING
	'TRANSPORT' transport=STRING
	'DATAHANDLER' datahandler=STRING
	'OPTIONS' '(' (keys+=STRING values+=(STRING | PATH))+ (',' keys+=STRING values+=(STRING | PATH))* ')';

terminal PATH:
	"'" (("\' \\ \'") .) (("\' \\ \'") .)* "'" |
	'"' (("\' \\ \'") .) (("\' \\ \'") .)* '"';

SchemaDefinition:
	name=ID
	'('
	arguments+=ID arguments+=ID
	(',' arguments+=ID arguments+=ID)*
	')';

Create:
	{Create}
	('CREATE' | 'ATTACH')
	type=('STREAM' | 'SINK' | 'VIEW')
	create=(CreateAccessFramework
	| CreateChannelFrameworkViaPort
	| CreateChannelFormatViaFile
	| CreateDatabaseStream
	| CreateDatabaseSink
	| CreateView);

CreateAccessFramework:
	attributes=SchemaDefinition
	pars=AccessFramework;

CreateChannelFrameworkViaPort:
	attributes=SchemaDefinition
	'CHANNEL' host=ID ':' port=INT;

CreateChannelFormatViaFile:
	attributes=SchemaDefinition
	'FILE' filename=STRING 'AS' type=ID;

CreateDatabaseStream:
	attributes=SchemaDefinition
	'DATABASE'
	database=ID
	'TABLE'
	table=ID
	('EACH'
	size=INT
	unit=Time)?;

CreateDatabaseSink:
	name=ID
	'AS'
	'DATABASE'
	database=ID
	'TABLE'
	table=ID
	('AND' option=('DROP' | 'TRUNCATE'))?;

CreateView:
	name=ID
	'FROM'
	select=InnerSelect;

CreateDataBaseJDBCConnection returns Command:
	{CreateDataBaseConnectionJDBC}
	'CREATE'
	'DATABASE'
	'CONNECTION'
	name=ID
	'JDBC'
	server=ID
	('WITH'
	'USER'
	user=ID
	'PASSWORD'
	password=ID
	(lazy='NO_LAZY_CONNECTION_CHECK')?)?;

CreateDataBaseGenericConnection returns Command:
	{CreateDataBaseConnectionGeneric}
	'CREATE'
	'DATABASE'
	'CONNECTION'
	name=ID
	'AS'
	driver=ID
	'TO'
	source=ID
	('AT'
	host=ID
	':'
	port=INT)?
	('WITH'
	'USER'
	user=ID
	'PASSWORD'
	password=ID
	(lazy='NO_LAZY_CONNECTION_CHECK')?)?;

DropDatabaseConnection returns Command:
	{DropDatabaseConnection}
	'DROP'
	'DATABASE'
	'CONNECTION'
	name=ID;

ContextStoreType:
	(type='SINGLE')
	| (type='MULTI'
	size=INT
	('PARTITION'
	'BY'
	partition=INT)?);

CreateContextStore returns Command:
	{CreateContextStore}
	'CREATE'
	'CONTEXT'
	'STORE'
	attributes=SchemaDefinition
	'AS'
	contextType=ContextStoreType;

DropContextStore returns Command:
	{DropContextStore}
	'DROP'
	'CONTEXT'
	'STORE'
	name=ID
	('IF' exists='EXISTS')?;

StreamTo:
	{StreamTo}
	'STREAM'
	'TO'
	name=ID
	(statement=InnerSelect2 | inputname=ID);

DropStream returns Command:
	{DropStream}
	'DROP'
	name=('SINK' | 'STREAM' | 'VIEW')
	stream=ID
	(exists='IF' 'EXISTS')?;

UserManagement returns Command:
	{UserManagement}
	name=('CREATE' | 'ALTER' | 'DROP')
	subject=('USER' | 'ROLE' | 'TENANT')
	subjectName=ID
	('IDENTIFIED' 'BY' password=STRING)?;

RightsManagement returns Command:
	({RightsManagement} name='GRANT'
	operations+=ID (',' operations+=ID)* ('ON' operations2+=ID (',' operations2+=ID)*)?
	'TO' user=ID)
	| ({RightsManagement} name='REVOKE'
	operations+=ID (',' operations+=ID)* ('ON' operations2+=ID (',' operations2+=ID)*)?
	'FROM' user=ID);

RoleManagement returns Command:
	({RoleManagement} name='GRANT'
	'ROLE' operations+=ID (',' operations+=ID)*
	'TO' user=ID)
	| ({RoleManagement} name='REVOKE'
	'ROLE' operations+=ID (',' operations+=ID)*
	'FROM' user=ID);

WindowOperator:
	'['
	(UnboundedWindow
	| TimebasedWindow
	| TuplebasedWindow)
	']';

UnboundedWindow returns WindowOperator:
	{UndboundedWindow}
	'UNBOUNDED';

TimebasedWindow returns WindowOperator:
	{TimebasedWindow}
	'SIZE' size=INT 
	(unit=Time)?
	('ADVANCE' advance_size=INT (advance_unit=Time)?)?
	'TIME';

TuplebasedWindow returns WindowOperator:
	{TuplebasedWindow} 
	'SIZE' size=INT
	('ADVANCE' advance_size=INT)?
	'TUPLE'
	('PARTITION' 'BY' partition_attribute=Attribute)?;

	// Expression DSL ///////////////////////////////////////////////////////
ExpressionsModel:
	{ExpressionsModel} elements+=Expression;

Expression:
	OrPredicate;

OrPredicate returns Expression:
	AndPredicate ({OrPredicate.left=current} OrOperator right=AndPredicate)*;

AndPredicate returns Expression:
	Equalitiy ({AndPredicate.left=current} AndOperator right=Equalitiy)*;

Equalitiy returns Expression:
	Comparison ({Equality.left=current} op=EQUALITIY_OPERATOR
	right=Comparison)*;

Comparison returns Expression:
	PlusOrMinus ({Comparision.left=current} op=COMPARE_OPERATOR
	right=PlusOrMinus)*;

PlusOrMinus returns Expression:
	MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-')
	right=MulOrDiv)*;

MulOrDiv returns Expression:
	Primary ({MulOrDiv.left=current} op=('/' | '*')
	right=Primary)*;

Primary returns Expression:
	({Bracket} '(' inner=Expression ')') |
	{NOT} 'NOT' expression=Primary |
	Atomic;

Atomic returns Expression:
	{IntConstant} value=INT
	| {FloatConstant} value=FLOAT
	| {StringConstant} value=STRING
	| {BoolConstant} value=BOOLEAN
	| {AttributeRef} value=AttributeWithoutAliasDefinition
	| {ComplexPredicateRef} value=ComplexPredicate;

	//TODO Rename
AtomicWithoutAttributeRef returns Expression:
	{IntConstant} value=INT
	| {FloatConstant} value=FLOAT
	| {StringConstant} value=STRING
	| {BoolConstant} value=BOOLEAN
	| {Matrix} value=(MATRIX_FLOAT)
	| {Vector} value=(VECTOR_FLOAT);
