/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.tests

import com.google.inject.Inject
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Model
import de.uniol.inf.is.odysseus.parser.novel.cql.generator.CQLGenerator
import java.util.Set
import org.eclipse.xtext.generator.InMemoryFileSystemAccess
import org.eclipse.xtext.junit4.InjectWith
import org.eclipse.xtext.junit4.XtextRunner
import org.eclipse.xtext.junit4.util.ParseHelper
import org.eclipse.xtext.junit4.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith

import static extension org.junit.Assert.*

@RunWith(XtextRunner)
@InjectWith(CQLInjectorProvider)
class CQLParserTest
{

	@Inject extension ValidationTestHelper
	@Inject extension CQLGenerator
	@Inject extension ParseHelper<Model>
	
	@Test def void SelectAllTest1() 
	{ 
		assertCorrectGenerated
		(
			"SELECT * FROM stream1;" 
			,
			"ACCESS
			(
				{
					source      = 'Source'
					wrapper     = 'GenericPush'
					transport   = 'TCPClient'
					dataHandler = 'Tuple'
					schema = 
					[
						['attr1', 'Integer'],
						['attr2', 'String']
					]
				}
			)"
		, new CQLDictionaryDummy())
	}

	@Test def void SelectAllTest2() 
	{ 
		assertCorrectGenerated
		(
			"SELECT * FROM stream1 WHERE (attr1 < 125);" 
			,
			"SELECT
			(
				{ predicate=(attr1 < 125) }, 
			
				ACCESS
				(
					{ 
						source      = 'Source'
						wrapper     = 'GenericPush'
						transport   = 'TCPClient'
						dataHandler = 'Tuple'
						schema = 
						[
							['attr1', 'Integer'],
							['attr2', 'String']	
						]
					}
				)
 			)"
		, new CQLDictionaryDummy)
	}
	
	@Test def void SelectAttr1Attr2() 
	{ 
		assertCorrectGenerated
		(
			"SELECT attr1, attr2 FROM stream1 WHERE (attr1 < 125);" 
			,
			"SELECT
			(
				{ predicate=(attr1 < 125) }, 
			
				ACCESS
				(
					{ 
						source      = 'Source'
						wrapper     = 'GenericPush'
						transport   = 'TCPClient'
						dataHandler = 'Tuple'
						schema = 
						[
							['attr1', 'Integer'],
							['attr2', 'String']	
						]
					}
				)
 			)"
		, new CQLDictionaryDummy)
	}
	
	@Test def void CreateStream1()
	{
		assertCorrectGenerated
		(
			"CREATE STREAM stream1 (attr1 INTEGER) CHANNEL localhost : 54321;"
			,
			"stream1 := ACCESS
			(
				{ Source = 'stream1', 
				  Wrapper = 'GenericPush',
				  Schema = [['attr1', 'INTEGER']],
				transport = 'NonBlockingTcp',
				protocol = 'SizeByteBuffer',
				dataHandler ='Tuple',
				Options =[['port', '54321'],['host', 'localhost']]
				}
			)"
		, null)
	}
	
	@Test def void CreateStream2()
	{
		assertCorrectGenerated
		(
			"CREATE STREAM stream1 (attr1 INTEGER, attr2 STRING, attr3 BOOLEAN) CHANNEL localhost : 54321;"
			,
			"stream1 := ACCESS
			(
				{ Source = 'stream1', 
				  Wrapper = 'GenericPush',
				  Schema = [['attr1', 'INTEGER'],
							['attr2', 'STRING'],
							['attr3', 'BOOLEAN']],
				transport = 'NonBlockingTcp',
				protocol = 'SizeByteBuffer',
				dataHandler ='Tuple',
				Options =[['port', '54321'],['host', 'localhost']]
				}
			)"
		, null)
	}
	
	def void assertCorrectGenerated(String s, String t, CQLDictionaryDummy dictionary) 
	{
		
		s.parse.assertNoErrors
		var model = s.parse 
		val fsa = new InMemoryFileSystemAccess()
		if(dictionary != null)
			schema = dictionary.schema as Set<SDFSchema>
        doGenerate(model.eResource(), fsa, null)
        var query = ''
		for(e : fsa.textFiles.entrySet)
		{
			query += e.value
		}
//		println("result: " + query)
		format(t).assertEquals(format(query))
	} 
	
	//TODO \t should also be removed
	//TODO ecspace symbols should retrived with System.getProperties(linesperator)
	def String format(String s) { s.replaceAll("\\s*[\\r\\n]+\\s*", "").trim().replace(" ","") }
	
}
