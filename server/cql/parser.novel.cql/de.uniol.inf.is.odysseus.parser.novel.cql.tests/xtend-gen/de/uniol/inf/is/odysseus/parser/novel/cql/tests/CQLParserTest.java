/**
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.tests;

import com.google.inject.Inject;
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Model;
import de.uniol.inf.is.odysseus.parser.novel.cql.generator.CQLGenerator;
import de.uniol.inf.is.odysseus.parser.novel.cql.tests.CQLDictionaryDummy;
import de.uniol.inf.is.odysseus.parser.novel.cql.tests.CQLInjectorProvider;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.InMemoryFileSystemAccess;
import org.eclipse.xtext.junit4.InjectWith;
import org.eclipse.xtext.junit4.XtextRunner;
import org.eclipse.xtext.junit4.util.ParseHelper;
import org.eclipse.xtext.junit4.validation.ValidationTestHelper;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(XtextRunner.class)
@InjectWith(CQLInjectorProvider.class)
@SuppressWarnings("all")
public class CQLParserTest {
  @Inject
  @Extension
  private ValidationTestHelper _validationTestHelper;
  
  @Inject
  @Extension
  private CQLGenerator _cQLGenerator;
  
  @Inject
  @Extension
  private ParseHelper<Model> _parseHelper;
  
  @Inject
  private CQLDictionaryDummy dictionary;
  
  @Test
  public void SelectAllTest1() {
    this.assertCorrectGenerated(
      "SELECT * FROM stream1;", 
      "ACCESS\r\n\t\t\t(\r\n\t\t\t\t{\r\n\t\t\t\t\tsource      = \'Source\'\r\n\t\t\t\t\twrapper     = \'GenericPush\'\r\n\t\t\t\t\ttransport   = \'TCPClient\'\r\n\t\t\t\t\tdataHandler = \'Tuple\'\r\n\t\t\t\t\tschema = \r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t[\'attr1\', \'Integer\'],\r\n\t\t\t\t\t\t[\'attr2\', \'String\']\r\n\t\t\t\t\t]\r\n\t\t\t\t}\r\n\t\t\t)");
  }
  
  @Test
  public void SelectAllTest2() {
    this.assertCorrectGenerated(
      "SELECT * FROM stream1 WHERE (attr1 < 125);", 
      "SELECT\r\n\t\t\t(\r\n\t\t\t\t{ predicate=(attr1 < 125) }, \r\n\t\t\t\r\n\t\t\t\tACCESS\r\n\t\t\t\t(\r\n\t\t\t\t\t{ \r\n\t\t\t\t\t\tsource      = \'Source\'\r\n\t\t\t\t\t\twrapper     = \'GenericPush\'\r\n\t\t\t\t\t\ttransport   = \'TCPClient\'\r\n\t\t\t\t\t\tdataHandler = \'Tuple\'\r\n\t\t\t\t\t\tschema = \r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t[\'attr1\', \'Integer\'],\r\n\t\t\t\t\t\t\t[\'attr2\', \'String\']\t\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n \t\t\t)");
  }
  
  @Test
  public void SelectAttr1Attr2() {
    this.assertCorrectGenerated(
      "SELECT attr1, attr2 FROM stream1 WHERE (attr1 < 125);", 
      "SELECT\r\n\t\t\t(\r\n\t\t\t\t{ predicate=(attr1 < 125) }, \r\n\t\t\t\r\n\t\t\t\tACCESS\r\n\t\t\t\t(\r\n\t\t\t\t\t{ \r\n\t\t\t\t\t\tsource      = \'Source\'\r\n\t\t\t\t\t\twrapper     = \'GenericPush\'\r\n\t\t\t\t\t\ttransport   = \'TCPClient\'\r\n\t\t\t\t\t\tdataHandler = \'Tuple\'\r\n\t\t\t\t\t\tschema = \r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t[\'attr1\', \'Integer\'],\r\n\t\t\t\t\t\t\t[\'attr2\', \'String\']\t\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n \t\t\t)");
  }
  
  public void assertCorrectGenerated(final String s, final String t) {
    try {
      Model _parse = this._parseHelper.parse(s);
      this._validationTestHelper.assertNoErrors(_parse);
      Model model = this._parseHelper.parse(s);
      final InMemoryFileSystemAccess fsa = new InMemoryFileSystemAccess();
      Collection<SDFSchema> _schema = this.dictionary.getSchema();
      this._cQLGenerator.setSchema(((Set<SDFSchema>) _schema));
      Resource _eResource = model.eResource();
      this._cQLGenerator.doGenerate(_eResource, fsa, null);
      String query = "";
      Map<String, CharSequence> _textFiles = fsa.getTextFiles();
      Set<Map.Entry<String, CharSequence>> _entrySet = _textFiles.entrySet();
      for (final Map.Entry<String, CharSequence> e : _entrySet) {
        String _query = query;
        CharSequence _value = e.getValue();
        query = (_query + _value);
      }
      String _format = this.format(t);
      String _format_1 = this.format(query);
      Assert.assertEquals(_format, _format_1);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public String format(final String s) {
    String _replaceAll = s.replaceAll("\\s*[\\r\\n]+\\s*", "");
    String _trim = _replaceAll.trim();
    return _trim.replace(" ", "");
  }
}
