/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.generator

import de.uniol.inf.is.odysseus.core.sdf.schema.SDFAttribute
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Aggregation
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Alias
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.And
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeRef
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeWithNestedStatement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateParameters
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateSink1
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStream1
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStreamChannel
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStreamFile
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateView
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.DataType
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Expression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionsModel
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Or
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Select
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StreamTo
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.util.CQLUtil
import java.util.ArrayList
import java.util.Arrays
import java.util.Collection
import java.util.HashMap
import java.util.HashSet
import java.util.List
import java.util.Map
import java.util.Map.Entry
import java.util.Set
import java.util.stream.Collectors
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGenerator2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.emf.ecore.EObject

//import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Create

//TODO Documentation
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CQLGenerator implements IGenerator2
{

	var Set<SDFAttribute> outerattributes = new HashSet
	var Set<SDFAttribute> innerattributes = new HashSet
	var Set<SDFAttribute> attributes = newHashSet
	var Map<String, String> sinks = new HashMap	
	var Map<String, String> streamto = new HashMap	
	var count_ID = 0
	var predicate = ''
	var List<String> definitions = newArrayList
	var Map<String, String> operators = newHashMap
	var Map<String, List<String>> sAliases = newHashMap
	var Map<String, List<String>> aAliases = newHashMap

	override afterGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context)  {}
	override beforeGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		var i = 0 ;
		for(e : resource.allContents.toIterable.filter(typeof(Statement)))
		{
			fsa.generateFile(
				""+ i++,	
				e.parseStatement()
			)
		}
	}
	
	def CharSequence parseStatement(Statement stmt)
	{
		switch stmt.type
		{
			CreateView			: parseCreateView(stmt.type as CreateView)
			CreateStream1  		: parseCreateStream1(stmt.type as CreateStream1)
			CreateSink1         : parseCreateSink1(stmt.type as CreateSink1)
			CreateStreamChannel : parseCreateStreamChannel(stmt.type as CreateStreamChannel)
			CreateStreamFile    : parseCreateStreamFile(stmt.type as CreateStreamFile)
			StreamTo		 	: parseStreamtoStatement(stmt.type as StreamTo)
			Select 		   		: parseSelect(stmt.type as Select)
		}
		
		//Build model
		var model = ''
		for(Entry<String, List<String>> entry : sAliases.entrySet)
		{
			for(String alias : entry.value)
				 model += alias + ASSIG1 + entry.key + '\n'
		}
		for(var i = 0; i < definitions.size; i++)
		{
			if(!definitions.get(i).contains(OP))
				model +=  definitions.get(i) + ASSIG2 + operators.get(definitions.get(i)) + '\n'
			else
				model +=  definitions.get(i) + ASSIG1 + operators.get(definitions.get(i)) + '\n'
			for(Entry<String, List<String>> entry : nSelect.entrySet)
			{
				if(entry.key.equals(definitions.get(i)))
				{
					var l = entry.value
					for(String alias : l)
						model += alias + ASSIG1 + entry.key + '\n'
				} 	
			}
		}

		if(!aAliases.empty)
		{
			var String[] lines = model.split(System.getProperty("line.separator"));
			var lastline = lines.get(lines.length - 1)
			var String[] parts 
			if(lastline.contains(ASSIG1))
				parts = lastline.split(ASSIG1)
			else
				parts = lastline.split(ASSIG2)
			model += buildRenameOperator(parts.get(0))
		}		
		
		return model
	}
	
	val String OP     = "operator_"
	val String VIEW   = "view_" 
	val String ASSIG1 = " = "
	val String ASSIG2 = " := "
	
	def String registerOperator(String operator)
	{
		return registerOperator(operator, OP + getID())
	}
	
	def String registerOperator(String operator, String definition)
	{
		definitions.add(definition.toString)
		operators.put(definition, operator)
		return definition
	}
	
	//TODO refactore
	def registerAlias(Source src)
	{
		var name  = src.name
		var alias = src.alias
		if(alias != null && name != null)
		{
			var aliasname = alias.name
			if(sAliases.containsKey(name))
			{
				if(!sAliases.containsValue(aliasname))
				{
					var aliases = sAliases.get(name)
					aliases.add(aliasname)
					sAliases.put(name, aliases)
				}
			}
			else
			{
				var aliases = newArrayList
				aliases.add(aliasname)
				sAliases.put(name, aliases)
			}
		}
	}
	
	//TODO refactore
	def registerAlias(Attribute attr)
	{
		if(attr != null)
		{
			var name  = attr.name
			var alias = attr.alias
			if(alias != null && name != null)
			{
				var aliasname = alias.name
				if(aAliases.containsKey(name))
				{
					if(!aAliases.containsValue(aliasname))
					{
						var aliases = aAliases.get(name)
						aliases.add(aliasname)
						aAliases.put(name, aliases)
					}
				}
				else
				{
					var aliases = newArrayList
					aliases.add(aliasname)
					aAliases.put(name, aliases)
				}
			}
		}
	}
	
	def parseSelect(Select stmt)
	{
		// Add source aliases
		for(Source source : stmt.sources)
			registerAlias(source)
			
		// Add attribute aliases
		for(Attribute attribute : stmt.attributes)
			registerAlias(attribute)	
		
				
		// Parse select	and register operators
		var CharSequence result = ''
		if(null == stmt.predicates)
			result = parseSelectWithoutPredicate(stmt)
		else
			result = parseSelectWithPredicate(stmt)
	}
	
	private def CharSequence parseSelectWithoutPredicate(Select stmt)
	{
		if(!stmt.attributes.empty)//SELECT attr1, ...
			{
			    var String operator = null
			    var attributes = stmt.attributes.stream.map(e|e.name).collect(Collectors.toList)
				if(!stmt.aggregations.empty)
				{
					var result = buildAggregateOP(stmt.aggregations, stmt.order, stmt.sources)
					attributes = result.get(0) as List<String>
				    operator   = registerOperator(result.get(1).toString)
				
					//FIXME Not necessary, it has been done before!
					attributes.addAll(
						stmt.attributes.stream.map(e|e.name).collect(Collectors.toList)
					)
				}												
				var prj =  '''«buildProjectOP(attributes, buildJoin(null, stmt.sources, operator))»'''
//				generateAlias(stmt.sources)
				return prj
			}
			else//SELECT * ..
			{
				if(stmt.aggregations.empty)
				{
					if(stmt.sources.size == 1)
					{
						var prj = '''«buildProjectOP(stmt.sources.get(0))»'''
//						generateAlias(stmt.sources)
						return prj
					}
					return registerOperator('''«buildJoin(stmt.sources)»''')
				}
				var operator = buildAggregateOP(stmt.aggregations, stmt.order, stmt.sources)
//				generateAlias(stmt.sources)
				return registerOperator('''«operator.get(1).toString»''')
			}
	}
	
	private def CharSequence parseSelectWithPredicate(Select stmt)
	{
		predicate = ''
	    var String operator = null
	    var List<String>     attributes = stmt.attributes.stream.map(e|e.name).collect(Collectors.toList)
		var List<Expression> predicates = newArrayList
		var List<Source>        sources = newArrayList
		
		////WOKRING PROGRESS remove duplicates!!
		predicates.add(0, stmt.predicates.elements.get(0))
		if(stmt.having != null)
			predicates.add(0, stmt.having.elements.get(0))
		sources.addAll(stmt.sources)
		if(!stmt.aggregations.empty)
		{
			var result = buildAggregateOP(stmt.aggregations, stmt.order, sources)
			attributes.addAll(result.get(0) as List<String>)
		    operator   = registerOperator(result.get(1).toString)
			//FIXME
			//Not necessary, it has been done before!
//			attributes.addAll(
//				stmt.attributes.stream.map(e|e.name).collect(Collectors.toList)
//			)
		}
		
		var nested = EcoreUtil2.eAllOfType(stmt, AttributeWithNestedStatement)
		if(!nested.empty)
		{//FIXME 
			for(var i = 0; i < nested.size; i++)
			{
				var a = nested.get(i).nested.attributes.stream.map(e|e.name).collect(Collectors.toSet)
				for(String s : a)
					if(!attributes.contains(s))
						attributes.add(s)
				var s = nested.get(i).nested.sources
				var names = newArrayList
				for(Source s1 : sources)
				{
					names.add(s1.name)
				}
				for(Source s2 : s)
				{
					if(!names.contains(s2.name))
						sources.add(s2)
				}	
//				for(Source c : s)
//					if(!sources.contains(c))
//						sources.add(c)
			}
		}
		
//		println(sources)
//		var obj = searchForNestedSourcesAndAttributes(stmt) as Object[]
//		var a = obj.get(0) as List<String>
//		var s = obj.get(1) as List<Source>
//		attributes = CQLUtil.merge(attributes, a) as List<String>
//		sources    = CQLUtil.merge(sources, s) as List<Source>	
		var result = ''
		if(stmt.sources.size > 1 && !stmt.attributes.empty)// SELECT * FROM src1 / src1, .. src2 WHERE ...;
		{
			var prj =  buildProjectOP(attributes, buildJoin(null, sources, operator))
//			generateAlias(sources)
			result = '''«buildSelectOP(predicates, prj)»'''	
			return result
		}// SELECT * FROM src1, src2, ... WHERE ...; | SELECT attr1, ... FROM src1 / src1, ... WHERE ...;
		if(stmt.attributes.empty)
		{
			result = '''«buildSelectOP(predicates, buildJoin(null, sources, operator))»'''
//			generateAlias(sources)
			return result
		}
		var prj = buildProjectOP(attributes, buildJoin(null, sources, operator))
//		generateAlias(sources)
		result = '''«buildSelectOP(predicates, prj)»'''
		return result
	}
	
	
	def CharSequence buildRenameOperator(CharSequence operator)
	{

		var list = newArrayList
		for(Entry<String, List<String>> l : aAliases.entrySet)
		{
			list.add(l.key)
			list.add(l.value.get(0))
		}
		
		var rename = '''renamed_«getID()» = RENAME({aliases=[«generateListString(list)»], pairs='true'}, «operator»)'''
//		                 aliases = ['auction_id', 'auction', 'bidder_id', 'bidder'],
//                 pairs = 'true'
                 
		return rename
	}
	
	def registerSourceAlias(Source source)
	{
		if(source.alias != null && source.nested == null)
			registerOperator(source.name, source.alias.name)
	}
	
	def Object[] buildAggregateOP(List<Aggregation> list, List<Attribute> list2, List<Source> srcs)
	{
		return buildAggregateOP(list, list2, buildJoin(srcs))
	}
	
	def Object[] buildAggregateOP(List<Aggregation> list, List<Attribute> list2, Source src)
	{
		return buildAggregateOP(list, list2, checkForNestedStatement(src))
	}
	
	var List<String> aggregationAttributes = newArrayList
	
	def Object[] buildAggregateOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, CharSequence input)
	{
		var argsstr 				 = ''
		var List<String> args    = newArrayList()
		var List<String> aliases = newArrayList()
		for(var i = 0; i < aggAttr.length; i++)
		{
			args.add(aggAttr.get(i).name)
			args.add(getAttributename(aggAttr.get(i).attribute.name))
			var alias = ''
			if(aggAttr.get(i).alias != null)
				alias= aggAttr.get(i).alias.name
			else
				alias = aggAttr.get(i).name + '_' + aggAttr.get(i).attribute.name
			args.add(alias)
			aliases.add(alias)
			args.add(getDataTypeFrom(aggAttr.get(i).attribute))
			aggregationAttributes.add(alias)
			args.add(',')
			argsstr += generateKeyValueString(args)
			if(i != aggAttr.length - 1) argsstr += ','
			args.clear
		}
		//Generates the group by argument that is formed like ['attr1', attr2', ...]
		var groupby = ''
		if(!orderAttr.empty)
		{
			groupby += ',GROUP_BY=['
			groupby += generateListString(
				orderAttr.stream.map(e|getAttributename(e.name)).collect(Collectors.toList)
			) + ']'
		}
		return #[aliases, '''AGGREGATE({AGGREGATIONS=[«argsstr»]«groupby»}, «input»)''']
	}
		
	def CharSequence parseCreateStream1(CreateStream1 create)
	{
		return registerOperator(buildCreate1("ACCESS", create.pars, create.attributes.attributes, create.attributes.datatypes, create.attributes.name).toString, create.attributes.name)
	}	
		
	def CharSequence parseCreateSink1(CreateSink1 sink) 
	{
		return registerOperator(buildCreate1("SENDER", sink.pars, sink.attributes.attributes, sink.attributes.datatypes, sink.attributes.name).toString, sink.attributes.name)
	}	
			
	def CharSequence buildCreate1(String type, CreateParameters pars, List<Attribute> attrs, List<DataType> dtypes, String name)
	{	
		var wrapper     = pars.wrapper
		var protocol    = pars.protocol
		var transport   = pars.transport
		var dataHandler = pars.datahandler
		var args 		= generateKeyValueString(
							attrs.map[e|e.name],
							dtypes.map[e|e.value],
							','
						  )
		var options 	= generateKeyValueString(
							pars.keys,
							pars.values,
							','
						  )		
		var t = ''
		var s = ''
		var b = false
		if(type.equals("ACCESS"))
		{
			t = 'source'
			s = '''schema = [«args»],'''	
		}
		else
		{
			b = true
			t = 'sink'	
		}				  
						  
		var sink = '''«type»
				  (
					{	  
						«t»      = '«name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						«s»
						options =[«options»]
					 }
					 «IF b»,__INPUT__«ENDIF»
				   )'''
	    if(b)
	    {
	     	sinks.put(name, sink);
	     	return''	
	    }
		return sink
	}	
		
	def CharSequence parseCreateStreamFile(CreateStreamFile file)
	{
		var schema = generateKeyValueString(
					file.attributes.attributes.map[e|e.name],
					file.attributes.datatypes.map[e|e.value],
					','
				  )
		
		var options = '''['filename','«file.filename»']'''		  
		return registerOperator(buildCreate2('GenericPush', file.type, 'File', 'Tuple', schema, options, file.attributes.name).toString, file.attributes.name)
	}
	
	def CharSequence parseCreateStreamChannel(CreateStreamChannel channel) 
	{
		var schema = generateKeyValueString(
			channel.attributes.attributes.map[e|e.name],
			channel.attributes.datatypes.map[e|e.value],
			','
		  )
		
		var options = '''['port','«channel.port»'],['host', '«channel.host»']'''		  
		return registerOperator(buildCreate2('GenericPush', 'SizeByteBuffer', 'NonBlockingTcp', 'Tuple', schema, options, channel.attributes.name).toString, channel.attributes.name)
	}	
	
	def CharSequence buildCreate2(String wrapper, String protocol, String transport, String dataHandler, String schema, String options, String name)
	{						  
		return '''ACCESS
				  (
					{	  
						source      = '«name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						schema = [«schema»],
						options =[«options»]
					 }
				   )'''
	}
		
	def CharSequence parseCreateView(CreateView view)
	{
		return registerOperator(parseSelect(view.select).toString, VIEW + getID())
	}
		
	def parseStreamtoStatement(StreamTo to)
	{
		if(to.statement != null)
		{
			streamto.put(to.name, parseSelect(to.statement).toString)
			
		}		
		else
		{
			streamto.put(to.name, to.inputname)
		}

		if(sinks.keySet.contains(to.name))
			return '''«sinks.get(to.name).replace("__INPUT__", streamto.get(to.name))»'''
		return ''
	}

//	/**
//	 * Builds a join operator with a given {@link ExpressionsModel} and list of {@link Source}
//	 * elements. If the predicate is null, there will be no join predicate in the operation.
//	 * If the list contains only one source, an {@link IllegalArgumentException} will be thrown.
//	 */
	def CharSequence buildJoin(ExpressionsModel predicate, Collection<Source> srcs, CharSequence input2)
	{
		var args = srcs.stream.map(
			e|checkForNestedStatement(e).toString
		).collect(Collectors.toList)
		
		if(input2 != null)
			args.add(input2.toString)
		var join = buildJoin(predicate, args)
		return join
	}

	def CharSequence buildJoin(ExpressionsModel predicate, String[] srcs)
	{
		
		if(srcs.size < 1)
		{ 
			throw new IllegalArgumentException(
				"Invalid number of source elements: There have to be at least two sources"
			)
		}
		if(srcs.size == 1)//Will only be considered if the first call of this method provides a single source
		{
			return srcs.get(0)
		}
		var List<String> list = new ArrayList(Arrays.asList(srcs))
		var src = list.get(0)
		if(list.size == 2)
		{
			return '''JOIN(«list.get(0)»,«list.get(1)»)'''
		}
		list.remove(0)
		if(predicate != null)
		{
			var predicateString = '''{predicate='«parsePredicate(predicate.elements.get(0))»'}'''
			return '''JOIN(«predicateString»,«src»,«buildJoin(null, list)»)'''
		}
		else 
		{ 
			return '''JOIN(«src»,«buildJoin(null, list)»)'''
		} 

	}

	def CharSequence buildJoin(ExpressionsModel predicate, Collection<Source> scrs)
	{
		return buildJoin(predicate, scrs, null) 	
	}

	def buildJoin(Collection<Source> scrs)
	{
		
		var args = scrs.stream.map(
			e|checkForNestedStatement(e).toString
		).collect(Collectors.toList)

		return buildJoin(null, args)
	}

	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a char sequence to define the input operator. 
	 */
	def CharSequence buildSelectOP(Expression predicate, CharSequence operator)
	{
		predicate = ''
		var result = '''SELECT({predicate='«parsePredicate(predicate)»'},«operator»)'''
		return registerOperator(result)
	}
	
	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a char sequence to define the input operator. 
	 */
	def CharSequence buildSelectOP(List<Expression> predicate, CharSequence operator)
	{
		predicate = ''
		return registerOperator('''SELECT({predicate='«parsePredicate(predicate)»'},«operator»)''')
	}
	
	def CharSequence buildProjectOP(String[] attributes, CharSequence operator)
	{
		return registerOperator('''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|getAttributename(e)).collect(Collectors.toList))»]
				  	},«operator»)''')
	}
	
	def CharSequence buildProjectOP(Source src)
	{
		return buildProjectOP(#[] as String[], src)
	}
	
	def CharSequence buildProjectOP(String[] attributes, Source src)
	{
		if(src == null) { throw new NullPointerException("Given source was null") }
		
		if(attributes.empty)
		{
			return registerOperator('''PROJECT(
						{
							attributes=[«generateListString(getAttributeNamesFrom(src.name))»]
						},«checkForNestedStatement(src)»)''')
		}
		return registerOperator('''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|getAttributename(e)).collect(Collectors.toList))»]
				  	},«checkForNestedStatement(src)»)''')
	}
	
	//TODO String have to be encupseld between '
	/**Builds a predicate string from a given {@link Expression}. */
	def CharSequence parsePredicate(Expression e)
	{
		if(!e.eContents.empty)
		{
			switch e
			{
				Or:
				{
					parsePredicate(e.left)
					predicate += '||'
					parsePredicate(e.right)
				}
				And:
				{
					parsePredicate(e.left)
					predicate += '&&'
					parsePredicate(e.right)
				}  
				Equality:
				{
					parsePredicate(e.left)
					predicate += e.op
					parsePredicate(e.right)
				}
				Comparision:
				{
					parsePredicate(e.left)
					predicate += e.op
					parsePredicate(e.right)	
				}
				Plus:
				{
					parsePredicate(e.left)
					predicate += '+'
					parsePredicate(e.right)
				}
				Minus:
				{
					parsePredicate(e.left)
					predicate += '-'
					parsePredicate(e.right)					
				}
				MulOrDiv:
				{
					parsePredicate(e.left)
					predicate += e.op
					parsePredicate(e.right)
				}
				NOT:
				{
					predicate += '!'
					parsePredicate(e.expression)
				}
				Bracket:
				{
					predicate += '(' 
					parsePredicate(e.inner)
					predicate += ')' 
				}
				AttributeRef:
				{
					/*
					 * 
					 * attr1 > 10 AND attr1 IN (SELECT attr1 FROM s1 WHERE attr1 != 10) AND attr2 IN (... )
					 * 
					 * AttributeRef := (attr1 IN (SELECT attr1 FROM s1 WHERE attr1 != 10))
					 * 
					 * 
					 */
					if(e.value instanceof AttributeWithNestedStatement)
					{
						parseNestedPredicate((e.value as AttributeWithNestedStatement).nested)
//						for(Source source : (e.value as AttributeWithNestedStatement).nested.sources)
//						{
//							
//						}
					} 
					else
					{
						if(e.value instanceof Attribute)
							predicate += getAttributename(e.value as Attribute)
					}
				}  	 
			}
		} 
		else
		{
			var str = ''
			switch e
			{
				IntConstant: 	str = e.value + ''
				FloatConstant:  str = e.value
				StringConstant: str = "'" + e.value + "'"
				BoolConstant: 	str = e.value
	
			}
			predicate += str
		}
//		println(predicate)
		return predicate
	}
	
	def private CharSequence parseNestedPredicate(Select select)
	{
		var pred = select.predicates
		if(pred == null)
		{
			for(Source s : checkForNestedStatement(select.sources))
			{
				var p = s.nested.predicates
				if(p != null)
				{				
					predicate += parsePredicate(s.nested.predicates.elements.get(0))
				}
			 }
			return predicate
		}
		else
		{
			return parsePredicate(pred.elements.get(0))
		}
	}
	
	def CharSequence parsePredicate(List<Expression> expressions)
	{
		var s = ''
		for(var i = 0 ; i < expressions.size - 1; i++)
		{
			if(expressions.get(i) instanceof AttributeRef)
			{
				if((expressions.get(i) as AttributeRef).value instanceof AttributeWithNestedStatement)
				{
					// ignore it!
				}
			}
			else
			{
				predicate = ''
				var result = parsePredicate(expressions.get(i))
//				if(result.equals(''))
//					s+= result
//				else
					s +=  result + '&&'
			}
		}
		predicate = ''
		s += parsePredicate(expressions.get(expressions.size - 1))
		return s
	}
		
	//TODO Register nested queries	
	def CharSequence checkForNestedStatement(Source src)
	{
		
		if(src.nested != null)
		{
			var nested = parseSelect(src.nested)
			var alias = src.alias.name
			registerNestedSelect(nested.toString, alias)
//			registerOperator(alias, nested.toString)			
			return alias
		}
		else
		{
//			registerAlias(src)
//			if(src.alias != null)
//			{
//				registerOperator(src.alias.name, src.name)
//				definitions.add(src.alias.name.toString)
//				operators.put(src.alias.name, src.name)	
//			}
			return buildWindowOP(src)
		}
	}

	def List<Source> checkForNestedStatement(List<Source> srcs)
	{
		var List<Source> l = newArrayList
		for(Source s : srcs)
			if(s.nested != null)
				l.add(s)
				
		return l
	}

	def CharSequence buildWindowOP(Source src)
	{
		if(src.time != null)
		{
			var var1 = if(src.time.advance_size != 0) src.time.advance_size else 1
			var var2 = if(src.time.advance_size != 0) src.time.advance_unit else src.time.unit
			return '''TIMEWINDOW
					  (
					  	{
					  		size = [«src.time.size»,'«src.time.unit»'],
					  		advance = [«var1»,'«var2»']
						},
						«src.name»
					 )'''			 
		}
		else if(src.tuple != null)
		{
			var var1 = if(src.tuple.advance_size != 0) src.tuple.advance_size else 1
			if(src.tuple.partition_attribute == null)
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»
						   	},
						   	«src.name»
						   )'''

			}
			else
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»,
								partition = '«src.tuple.partition_attribute.name»'
						   	},
						   	«src.name»
						   )'''
			}			
		}
		else 
		{ 
			return src.name
		}
		
	}

	def String generateKeyValueString(String ... s)
	{
		var str = "["
		if(s.length == 1) 
			return str += "'" + s.get(0) + "']"
		for(var i = 0; i < s.length - 2; i++)
			str += "'" + s.get(i) + "'" + s.get(s.length - 1)			
		return str += "'" + s.get(s.length - 2) + "']"
	}
		
	def String generateKeyValueString(List<String> l1, List<String> l2, String s)
	{
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)// OUT of bounds...
		{
			str += generateKeyValueString(l1.get(i), l2.get(i), s) + ","
		}
		return (str += generateKeyValueString(l1.get(l1.size - 1), l2.get(l1.size - 1), s))
	}
	
	def String generateKeyValueString(String s1, List<String> l2, String s2)
	{
		var str = ''
		for(var i = 0; i < l2.size - 1; i++)
		{
			str += generateKeyValueString(s1, l2.get(i), s2) + ","
		}
		return (str += generateKeyValueString(s1, l2.get(l2.size - 1), s2))
	}
	
	def String generateListString(String s1)
	{
		return "'" + s1 + "'"
	}
		
	def String generateListString(List<String> l1)
	{
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)
		{
			str += generateListString(l1.get(i)) + ","
		}
		return (str += generateListString(l1.get(l1.size - 1)))
	}
	
	@Deprecated	
	def CharSequence buildSchema(List<Attribute> attr, Source src)
	{
		var str = ''
		for(a : innerattributes)
			if(a.sourceName.equals(src.name))
				str += generateKeyValueString(a.attributeName, a.datatype.toString, ',') + ","
		return (str = str.substring(0, str.length - 2))
	}
	
	def CharSequence getID()
	{
		count_ID++
		return count_ID.toString
	}
	
	def void clear()
	{
		outerattributes.clear()
		innerattributes.clear()
		count_ID = 0
		sinks.clear()
		streamto.clear()
		nSelect.clear()
		attributeAliases.clear()
		operators.clear()
		definitions.clear()
		sourcenames.clear()
		aAliases.clear()
		sAliases.clear()
		aggregationAttributes.clear()
//		model = ''
	}

	var List<String> sourcenames = newArrayList

	def void setOuterschema(Set<SDFSchema> s)
	{
		for(SDFSchema t : s)
			for(SDFAttribute a : t.attributes)
			{
				if(!sourcenames.contains(a.sourceName))		
					sourcenames.add(a.sourceName)		
				outerattributes.add(a)
			}			
	}

	def void setInnerschema(Set<SDFSchema> s)
	{
		for(SDFSchema t : s)
			for(SDFAttribute a : t.attributes)
			{
				if(!sourcenames.contains(a.sourceName))		
					sourcenames.add(a.sourceName)		
				innerattributes.add(a)
			}		
	}
	
	var Map<String, List<String>> nSelect = newHashMap
	var Map<String, List<String>> attributeAliases = newHashMap

	def registerNestedSelect(String name, String alias)
	{
		if(nSelect.containsKey(name))
		{
			if(!nSelect.containsValue(alias))
			{
				var aliases = nSelect.get(name)
				aliases.add(alias)
				nSelect.put(name, aliases)
			}
		}
		else
		{
			var aliases = newArrayList
			aliases.add(alias)
			nSelect.put(name, aliases)
		}
	}
	
	def String getDataTypeFrom(Attribute attribute) 
	{
		if(attribute == null) throw new NullPointerException("given attribute was null")
		for(SDFAttribute a : innerattributes)
			if(a.attributeName.equals(attribute.name))
				return a.datatype.toString
		//TODO Is this still in use? ...
		for(SDFAttribute a : outerattributes)
			if(a.attributeName.equals(attribute.name))
				return a.datatype.toString
		throw new IllegalArgumentException("given attribute " + attribute.name + "unknown")		
	}
	
	def String getSourcenameFromAlias(String sourcealias)
	{
		//println("XCX " + sAliases)
		for(Entry<String, List<String>> entry : sAliases.entrySet)
			for(String alias : entry.value)
				if(alias.equals(sourcealias))
					return entry.key
					
		throw new IllegalArgumentException("given alias " + sourcealias + " is invalid: no corresponding source found")									
	}
	
	def String getAttributenameFromAlias(String attributealias)
	{
		//println("XCXSS " + aAliases)
		for(Entry<String, List<String>> entry : aAliases.entrySet)
			for(String alias : entry.value)
				if(alias.equals(attributealias))
					return entry.key
					
		throw new IllegalArgumentException("given alias " + attributealias + " is invalid: no corresponding attribute found")									
	}
	
	def String getAttributename(String attribute)
	{
		if(attribute.contains("."))
		{
			/*
			 * Hint a simple . as regex won't work, because 
			 * it's the metacharacter for 'match all'. Hence
			 * \\. is used instead.
			 */
			var String[] name = attribute.split('\\.')
			if(name != null && name.length == 2)
			{
				if(sAliases.keySet.contains(name.get(0)))
					if(aAliases.keySet.contains(name.get(1)))
						return attribute
					else
						return name.get(0) + '.' + getAttributenameFromAlias(name.get(1))
				else
					if(aAliases.keySet.contains(name.get(1)))
						return getSourcenameFromAlias(name.get(0)) + '.' + name.get(1)
					else	
						return getSourcenameFromAlias(name.get(0)) + '.' + getAttributenameFromAlias(name.get(1))
			}
			throw new IllegalArgumentException("attribute " + attribute + " could not be resolved" )
		}
		
		//TODO refactore
		var String name = attribute
		for(List<String> l : aAliases.values)
			if(l.contains(attribute))
				name = getAttributenameFromAlias(attribute)
		for(SDFAttribute a : innerattributes)
			if(a.attributeName.equals(name))
				return a.sourceName + '.' + a.attributeName
		for(SDFAttribute a : outerattributes)
			if(a.attributeName.equals(name))
				return a.sourceName + '.' + a.attributeName

		if(aggregationAttributes.contains(attribute))
			return attribute		
				
		throw new IllegalArgumentException("attribute " + attribute + " could not be resolved" )		
	}
	
	def String getAttributename(Attribute attribute)
	{
		return getAttributename(attribute.name)
	}
	
	/** Returns all {@link Attribute} elements to the corresponding source. */
	def getAttributeNamesFrom(String srcname) 
	{
		/*
		 * A source is either from outerattributes» or from innerattributes.
		 * Hence, there should be no duplicated entries while iterating 
		 * through both lists.
		 */
		 
		 //FIXME srcname can be an alias, therefore no attributes will be found!
		var List<String> l = new ArrayList 
		 
//		 attributes.addAll(outerattributes)
//		 attributes.addAll(innerattributes)
//		for(SDFAttribute attr : attributes)
//			if(attr.sourceName.equals(srcname))
//				l.add(attr.attributeName)
		
		for(SDFAttribute a : outerattributes)
			if(a.sourceName.equals(srcname))
				l.add(getAttributename(a.attributeName))
				
		for(SDFAttribute a : innerattributes)
			if(a.sourceName.equals(srcname))
				l.add(getAttributename(a.attributeName))
		return l
	}
	
	
	/* Builds an AggregationOP -> was replaced by buildAggregateOP(..)
	def Object[] buildAggregationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, CharSequence input) 
	{
		//Produces a string array with strings like 'FUNCTION' = 'COUNT' 
		var functions = generateKeyValueString(
			'FUNCTION',
			aggAttr.stream.map(e|e.name).collect(Collectors.toList),
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		//Produces a string array with strings like 'INPUT_ATTRIBUTES' = 'attr1'
		var input_attr = generateKeyValueString(
			'INPUT_ATTRIBUTES',
			aggAttr.stream.map(e|e.attribute.name).collect(Collectors.toList),
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		
		//Creates a list with aliases from the given argument and adds missing aliases
		var List<String> aliases = newArrayList()
		for(var i = 0; i < aggAttr.length; i++)
		{
			if(aggAttr.get(i).alias != null)
				aliases.add(aggAttr.get(i).alias.name)
			else
				aliases.add(aggAttr.get(i).name + '_' + aggAttr.get(i).attribute.name)
		}
		//Produces a string array with strings like 'OUTPUT_ATTRIBUTES' = 'COUNT_attr1'
		//or with a corresponding alias for the attribute
		var output_attr = generateKeyValueString(
			'OUTPUT_ATTRIBUTES',
			aliases,
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		
		var List<String> lll = newArrayList()
		for(var i = 0; i < functions.size; i++)
		{
			lll.add(functions.get(i) + ',' + input_attr.get(i))
		}
		//Generates the finally argument string that is formed like 
		// ['FUNCTION' = 'COUNT', 'INPUT_ATTRIBUTES' = 'attr1', 'OUTPUT_ATTRIBUTES' = 'COUNT_attr1'] , [...]
		var args = generateKeyValueString(
			lll,
			output_attr,
			','
		).replace("[''", "['")
		.replace("'']", "']")
		.replace("'',''", "','")

		//Generates the group by argument that is formed like ['attr1', attr2', ...]
		var groupby = ''
		if(!orderAttr.empty)
		{
			groupby += ',GROUP_BY=['
			groupby += generateListString(
				orderAttr.stream.map(e|e.name).collect(Collectors.toList)
			) + ']'
		}
		return (#[aliases, '''AGGREGATION({AGGREGATIONS=[«args»]«groupby»}, «input»)'''])
	}
	
	def Object[] buildAggregationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, Source src) 
	{
		return buildAggregationOP(aggAttr, orderAttr, buildWindowOP(src))
	}

	def Object[] buildAggregationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, List<Source> src) 
	{
		return buildAggregationOP(aggAttr, orderAttr, buildJoin(null, src))
	}
	 */
}