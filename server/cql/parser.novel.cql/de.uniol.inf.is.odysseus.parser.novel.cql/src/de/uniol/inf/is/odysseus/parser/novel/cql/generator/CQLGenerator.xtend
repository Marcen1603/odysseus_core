/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.generator

import de.uniol.inf.is.odysseus.core.sdf.schema.SDFAttribute
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFDatatype
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AccessFramework
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.And
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeRef
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ChannelFormat
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Create_Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Expression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionsModel
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Or
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Select_Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StreamTo
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.List
import java.util.Map
import java.util.Set
import java.util.stream.Collectors
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGenerator2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CQLGenerator implements IGenerator2
{

	var Set<SDFAttribute> outerattributes = new HashSet
	var Set<SDFAttribute> innerattributes = new HashSet
	var Set<SDFSchema>    innerschema;
	var Set<SDFSchema>    outerschema;
	var Map<String, String> sinks = new HashMap	
	var Map<String, String> streamto = new HashMap	
	var count_ID = 0
	var predicate = ''

	override afterGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context)  {}
	override beforeGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		var i = 0 ;
		for(e : resource.allContents.toIterable.filter(typeof(Statement)))
		{
			fsa.generateFile(
				""+ i++,	
				e.parseStatement()
			)
		}
	}
	
	def CharSequence parseStatement(Statement stmt)
	{
		switch stmt.type 
		{
			Select_Statement : parseSelectStatement(stmt.type as Select_Statement, false)
			Create_Statement : parseCreateStatement(stmt.type as Create_Statement, false)
			StreamTo		 : parseStreamtoStatement(stmt.type as StreamTo)
		}
		
	}
	
	def CharSequence parseSelectStatement(Select_Statement stmt, boolean isView)
	{
		predicate = ''
		var symbol1 = if(isView) ' := ' else ' = '
		if(stmt.predicates == null)//SELECT attr1, ... / * FROM ...;
		{
			if(!stmt.attributes.empty)//SELECT attr1, ...
			{
				if(stmt.sources.size == 1)//.. FROM src1;
				{
					return '''project_«getID() + symbol1»«buildProjectOP(stmt.attributes, stmt.sources.get(0))»'''										
				}
				else//.. FROM src1, src2, ...;
				{
					return '''project_«getID() + symbol1»«buildProjectOP(stmt.attributes, buildJoin(null, stmt.sources))»'''	
				}
			}
			else//SELECT * ..
			{
				if(stmt.sources.size == 1)//.. FROM src1;
				{
					return '''project_«getID() + symbol1»«buildProjectOP(null, stmt.sources.get(0))»'''												
				}
				else//.. FROM src1, src2, ...;
				{
					return '''join_«getID() + symbol1»«buildJoin(null, stmt.sources)»'''
				}				
			}
		}
		else
		{ 
			if(stmt.sources.size > 1 && !stmt.attributes.empty)// SELECT * FROM src1 / src1, .. src2 WHERE ...;
			{
				return '''select_«getID() + symbol1»«buildSelectOP(stmt.predicates, buildProjectOP(stmt.attributes, buildJoin(null, stmt.sources)))»'''	
			}// SELECT * FROM src1, src2, ... WHERE ...; | SELECT attr1, ... FROM src1 / src1, ... WHERE ...;
			return '''select_«getID() + symbol1»«buildSelectOP(stmt.predicates, stmt.sources)»'''// are the same!!
		}
	}
	
	def CharSequence parseCreateStatement(Create_Statement stmt, boolean isView)
	{
		var symbol1 = if(isView) ' := ' else ' = '
		var ch = stmt.channelformat
		if(ch!= null)
		{
			if(ch.stream != null)
			{
				return '''«ch.stream.name + symbol1»«buildAccessOP(ch)»'''
			}
			if(ch.view.select != null) 
			{
				var str = parseSelectStatement(ch.view.select, true).toString
				return str.replace(str.substring(0, str.indexOf(":")), ch.view.name + " ")
			}
			var str = parseCreateStatement(ch.view.create, true).toString
			return str.replace(str.substring(0, str.indexOf(":")), ch.view.name + " ")
		}
		else
		{
			var af = stmt.accessframework
			if(af.type.equals("STREAM"))
			{
				return '''«af.name + symbol1»«buildAccessOP(af)»'''
			}
			buildSenderOP(af)
			return ''''''
		}
	}
		
	def parseStreamtoStatement(StreamTo stmt)
	{
		if(stmt.statement != null)
		{
			var s = parseSelectStatement(stmt.statement, false).toString
			streamto.put(stmt.name, s.subSequence(s.indexOf('=') + 1, s.length).toString)		
		}
		else
		{
			streamto.put(stmt.name, stmt.inputname)
		}
		if(!sinks.keySet.contains(stmt.name)) 
		{ 
			return ''
		}
		return '''output«getID() + " = " + sinks.get(stmt.name).replace("_INPUT_", streamto.get(stmt.name))»'''			
	}
		
	def CharSequence buildAccessOP(ChannelFormat channel)
	{
		var wrapper     = 'GenericPush'
		var protocol    = 'SizeByteBuffer'
		var transport   = 'NonBlockingTcp'
		var dataHandler = 'Tuple'		
		var args 		= generateKeyValueString(
							channel.stream.attributes.map[e|e.name],
							channel.stream.datatypes.map[e|e.value]
						  )
						  
		return '''ACCESS
				  (
					{	  
						source      = '«getKeyword(0) +  channel.stream.name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						schema = [«args»],
						options =[['port', '«channel.stream.port»'],
								  ['host', '«channel.stream.host»']]
					 }
				   )'''
	}	
		
	def CharSequence buildAccessOP(AccessFramework access)
	{
		var wrapper     = access.wrapper
		var protocol    = access.protocol
		var transport   = access.transport
		var dataHandler = access.datahandler
		var args 		= generateKeyValueString(
							access.attributes.map[e|e.name],
							access.datatypes.map[e|e.value]
						  )
						  
		var options 	= generateKeyValueString(
							access.keys,
							access.values
						  )						  
						  
		return '''ACCESS
				  (
					{	  
						source      = '«getKeyword(0) +  access.name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						schema = [«args»],
						options =[«options»]
					 }
				   )'''
	}		
	
	def buildSenderOP(AccessFramework access) 
	{
		var wrapper     = access.wrapper
		var protocol    = access.protocol
		var transport   = access.transport
		var dataHandler = access.datahandler
						  
		var options 	= generateKeyValueString(
							access.keys,
							access.values
						  )						  
						  
		var str = '''SENDER
				  (
					{	  
						sink        = '«getKeyword(0) +  access.name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						options =[«options»]
					 }, _INPUT_
				   )'''	

		if(streamto.keySet.contains(access.name))
		{
			return str.replace("_INPUT_", streamto.get(access.name))
		}
		sinks.put(access.name, str);
		return ''
	}

	/**
	 * Builds a join operator with a given {@link ExpressionsModel} and list of {@link Source}
	 * elements. If the predicate is null, there will be no join predicate in the operation.
	 * If the list contains only one source, an {@link IllegalArgumentException} will be thrown.
	 */
	def CharSequence buildJoin(ExpressionsModel predicate, List<Source> srcs)
	{
		if(srcs.size < 2)
		{ 
			throw new IllegalArgumentException(
				"Invalid number of source elements: There have to be at least two elements"
			)
		}
		var List<Source> list = srcs
		var src = list.get(0)
		if(list.size == 2)
		{
			return '''JOIN(«buildWindowOP(list.get(0))»,«buildWindowOP(list.get(1))»)'''
		}
		list.remove(0)
		if(predicate != null)
		{
			var predicateString = '''{predicate='«buildPredicate(predicate.elements.get(0))»'}'''
			return '''JOIN(«predicateString»,«buildWindowOP(src)»,«buildJoin(null, list)»)'''
		}
		else { return '''JOIN(«buildWindowOP(src)»,«buildJoin(null, list)»)''' } 	
	}

	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a list of {@link Source} elements. If the list contains more then one element,
	 * the {@link CQLGenerator#buildJoin(..)} method will be called to define the input
	 * operator.
	 */
	def CharSequence buildSelectOP(ExpressionsModel predicate, List<Source> srcs)
	{
		if(srcs.size == 1)
			return '''SELECT({predicate='«buildPredicate(predicate.elements.get(0))»'},«srcs.get(0).name»)'''
		return '''SELECT({predicate='«buildPredicate(predicate.elements.get(0))»'},«buildJoin(null, srcs)»)'''
	}

	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a char sequence to define the input operator. 
	 */
	def CharSequence buildSelectOP(ExpressionsModel predicate, CharSequence operator)
	{
		return '''SELECT({predicate='«buildPredicate(predicate.elements.get(0))»'},«operator»)'''
	}

	/**
	 * Builds a project operator with a list of {@link Attribute} and {@link Source}
	 * element. If the list is null, all attributes to the corresponding source will be
	 * added to the attributes parameter.
	 */
	def CharSequence buildProjectOP(List<Attribute> attributes, Source src)
	{
		if(src == null) { throw new NullPointerException("Given source was null") }
		
		if(attributes == null)
		{
			return '''PROJECT(
						{
							attributes=[«generateListString(getAttributeNamesFrom(src.name))»]
						},«buildWindowOP(src)»)'''
		}
		return '''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|e.name).collect(Collectors.toList))»]
				  	},«buildWindowOP(src)»)'''
	}
	
	/**
	 * Builds a project operator with a list of {@link Attribute} and char sequence
	 * to define the input operator.
	 */
	def CharSequence buildProjectOP(List<Attribute> attributes, CharSequence operator)
	{
		return '''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|e.name).collect(Collectors.toList))»]
				  	},«operator»)'''
	}
	
	//TODO String have to be encupseld between '
	/**Builds a predicate string from a given {@link Expression}. */
	def CharSequence buildPredicate(Expression e)
	{
		if(!e.eContents.empty)
		{
			switch e
			{
				Or:
				{
					buildPredicate(e.left)
					predicate += '||'
					buildPredicate(e.right)
				}
				And:
				{
					buildPredicate(e.left)
					predicate += '&&'
					buildPredicate(e.right)
				}  
				Equality:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)
				}
				Comparision:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)	
				}
				Plus:
				{
					buildPredicate(e.left)
					predicate += '+'
					buildPredicate(e.right)
				}
				Minus:
				{
					buildPredicate(e.left)
					predicate += '-'
					buildPredicate(e.right)					
				}
				MulOrDiv:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)
				}
				NOT:
				{
					predicate += '!'
					buildPredicate(e.expression)
				}
				Bracket:
				{
					predicate += '(' 
					buildPredicate(e.inner)
					predicate += ')' 
				}
				AttributeRef:
				{
					predicate += e.value.name
				}  	 
			}
		} 
		else
		{
			var str = ''
			switch e
			{
				IntConstant: 	str = e.value + ''
				FloatConstant:  str = e.value
				StringConstant: str = "'" + e.value + "'"
				BoolConstant: 	str = e.value
	
			}
			predicate += str
		}
	}
	
	def CharSequence buildWindowOP(Source src)
	{
		if(src.time != null)
		{
			return '''TIMEWINDOW
					  (
					  	{
					  		size = [«src.time.size»,'«src.time.unit»']
						},
						«src.name»
					 )'''
		}
		else if(src.tuple != null)
		{
			var var1 = if(src.tuple.advance_size != 0) src.tuple.advance_size else 1
			if(src.tuple.partition_attribute == null)
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»
						   	},
						   	«src.name»
						   )'''

			}
			else
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»,
								partition = '«src.tuple.partition_attribute.name»'
						   	},
						   	«src.name»
						   )'''
			}			
		}
		else { return src.name }
	}
		
	def String generateKeyValueString(String s1, String s2)
	{
		return "['" + s1 + "','" + s2 + "']"
	}	
		
	def String generateKeyValueString(List<String> l1, List<String> l2)
	{
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)
		{
			str += generateKeyValueString(l1.get(i), l2.get(i)) + ","
		}
		return (str += generateKeyValueString(l1.get(l1.size - 1), l2.get(l1.size - 1)))
	}
	
	def String generateListString(String s1)
	{
		return "'" + s1 + "'"
	}
		
	def String generateListString(List<String> l1)
	{
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)
		{
			str += generateListString(l1.get(i)) + ","
		}
		return (str += generateListString(l1.get(l1.size - 1)))
	}
		
	def CharSequence buildSchema(List<Attribute> attr, Source src)
	{
		var str = ''
		for(a : innerattributes)
			if(a.sourceName.equals(src.name))
				str += generateKeyValueString(a.attributeName, a.datatype.toString) + ","
		return (str = str.substring(0, str.length - 2))
	}
	
	def CharSequence getID()
	{
		count_ID++
		return count_ID.toString
	}
	
	def void clear()
	{
		outerattributes.clear()
		innerattributes.clear()
		count_ID = 0
		sinks.clear()
		streamto.clear()
	}

	def void setOuterschema(Set<SDFSchema> s)
	{
		outerschema = s
		for(SDFSchema t : s)
		{
			outerattributes.addAll(t.attributes)
		}
	}

	def void setInnerschema(Set<SDFSchema> s)
	{
		innerschema = s
		for(SDFSchema t : s)
		{
			innerattributes.addAll(t.attributes)
		}
	}
	
	val static CharSequence[] keywords = #['input_', 'window_', 'output_', 'select_']
	def static CharSequence getKeyword(int i)
	{
		if(i >= keywords.length || i < 0)
			return 'WRONG_INDEX_NO_KEYWORD'
		return keywords.get(i);
	}
	
	/** Returns all {@link Attribute} elements to the corresponding source. */
	def getAttributeNamesFrom(String src) 
	{
		/*
		 * A source is either from outerattributes» or from innerattributes.
		 * Hence, there should be no duplicated entries while iterating 
		 * through both lists.
		 */
		var List<String> l = new ArrayList 
		for(SDFAttribute a : outerattributes)
			if(a.sourceName.equals(src))
				l.add(a.attributeName)
		for(SDFAttribute a : innerattributes)
			if(a.sourceName.equals(src))
				l.add(a.attributeName)
		return l
	}
	
}