/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.generator

import de.uniol.inf.is.odysseus.core.sdf.schema.SDFAttribute
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Aggregation
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.And
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeRef
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeWithNestedStatement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateParameters
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateSink1
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStream1
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStreamChannel
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStreamFile
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateView
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.DataType
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Expression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionsModel
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Or
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Select
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StreamTo
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant
import java.util.ArrayList
import java.util.Arrays
import java.util.Collection
import java.util.Collections
import java.util.HashMap
import java.util.List
import java.util.Map
import java.util.Map.Entry
import java.util.stream.Collectors
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGenerator2
import org.eclipse.xtext.generator.IGeneratorContext
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.SelectExpression
import de.uniol.inf.is.odysseus.parser.novel.cql.services.CQLGrammarAccess.AtomicWithoutAttributeRefElements
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionComponent
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Mapper

//import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Create

//TODO Documentation
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CQLGenerator implements IGenerator2
{

	var private Map<String, String> sinks = new HashMap	
	var private Map<String, String> streamto = new HashMap	
	var private operatorCounter = 0
	var private expressionCounter = 0
	var private String predicateString = null
	var private List<String> definitions = newArrayList
	var private Map<String, String> operators = newHashMap
	var private Map<String, List<String>> nSelect = newHashMap
	var private List<SourceStruct> sources = newArrayList
	var private List<String> expressions = newArrayList
	var private List<String> aggregations = newArrayList
	var private joinCounter = 1
	var private firstJoinInQuery = true
	var private String expressionString = null
	var private Map<String, List<String>> renamedAttributes = newHashMap
	
	val private String OP     = "operator_"
	val private String VIEW   = "view_" 
	val private String ASSIG1 = " = "
	val private String ASSIG2 = " := "

	def void clear()
	{
		sinks.clear()
		streamto.clear()
		operatorCounter = 0
		expressionCounter = 0
		predicateString = null
		definitions.clear()
		operators.clear()
		nSelect.clear()
		attributeAliases.clear()
		sources.clear()
		expressions.clear()
		aggregations.clear()
		joinCounter = 1
		firstJoinInQuery = true
		expressionString = null
		renamedAttributes.clear()
//		outerattributes.clear()
//		innerattributes.clear()
//		aAliases.clear()
//		sAliases.clear()
//		attributes.clear()
//		model = ''
	}
	
	def public List<AttributeStruct> getAttributes()
	{
		var list = newArrayList
		for(SourceStruct source : sources)
			list.addAll(source.attributes)
		return list
	}

	def public Map<AttributeStruct, List<String>> getAttributeAliases()
	{
		var map = newHashMap
		for(SourceStruct source : sources)
			for(AttributeStruct attribute : source.attributes)
				if(!attribute.aliases.empty)
					map.put(attribute, attribute.aliases)
		return map
	} 

	def public List<String> getAttributeAliasesAsList()
	{
		var list = newArrayList
		for(SourceStruct source : sources)
			for(AttributeStruct attribute : source.attributes)
				list.addAll(attribute.aliases)
		return list
	} 

	def public Map<SourceStruct, List<String>> getSourceAliases()
	{
		var map = newHashMap
		for(SourceStruct source : sources)
				map.put(source, source.aliases)
		return map
	} 

	override afterGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context)  
	{
		clear()
	}
	override beforeGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		clear()
	}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		var i = 0 ;
		for(e : resource.allContents.toIterable.filter(typeof(Statement)))
		{
			fsa.generateFile(
				""+ i++,	
				e.parseStatement()
			)
		}
	}
	
	def private CharSequence formatOutputString(String sequence)
	{
		return sequence.replaceAll("\\s*[\\r\\n]+\\s*", "").trim().replace(" ","")
	}	
	
	def CharSequence parseStatement(Statement stmt)
	{
		switch stmt.type
		{
			CreateView			: parseCreateView(stmt.type as CreateView)
			CreateStream1  		: parseCreateStream1(stmt.type as CreateStream1)
			CreateSink1         : parseCreateSink1(stmt.type as CreateSink1)
			CreateStreamChannel : parseCreateStreamChannel(stmt.type as CreateStreamChannel)
			CreateStreamFile    : parseCreateStreamFile(stmt.type as CreateStreamFile)
			StreamTo		 	: parseStreamtoStatement(stmt.type as StreamTo)
			Select 		   		: parseSelect(stmt.type as Select)
		}
		
		//Build model
		var model = ''
		for(Entry<SourceStruct, List<String>> entry : getSourceAliases.entrySet)
		{
			for(String alias : entry.value)
				 model += formatOutputString(alias + ASSIG1 + entry.key.sourcename) + System.getProperty("line.separator")
		}
		for(var i = 0; i < definitions.size; i++)
		{
			if(!definitions.get(i).contains(OP))
				model += formatOutputString(definitions.get(i) + ASSIG2 + operators.get(definitions.get(i))) + System.getProperty("line.separator")
			else
				model += formatOutputString(definitions.get(i) + ASSIG1 + operators.get(definitions.get(i))) + System.getProperty("line.separator")
			for(Entry<String, List<String>> entry : nSelect.entrySet)
			{
				if(entry.key.equals(definitions.get(i)))
				{
					var l = entry.value
					for(String alias : l)
						model += formatOutputString(alias + ASSIG1 + entry.key) + System.getProperty("line.separator")
				} 	
			}
		}

		if(!getAttributeAliases.empty)
		{
			var String[] lines = model.split(System.getProperty("line.separator"));
			var lastline = lines.get(lines.length - 1)
			var String[] parts 
			if(lastline.contains(ASSIG1))
				parts = lastline.split(ASSIG1)
			else
				parts = lastline.split(ASSIG2)
			if(parts != null)
				model += formatOutputString(buildRenameOperator(parts.get(0)).toString)
		}		
		
		return model
	}
	
	def private String registerOperator(CharSequence operator)
	{
		return registerOperator(operator, OP + getID())
	}
	
	def private String registerOperator(CharSequence operator, String definition)
	{
		definitions.add(definition.toString)
		operators.put(definition, operator.toString)
		return definition
	}
	
	//TODO refactore
	def private registerAlias(Source src)
	{
		var name  = src.name
		var alias = src.alias
		if(alias != null && name != null)
		{
			for(SourceStruct source : sources)
			{
				if(source.sourcename.equals(name))
				{
					source.aliases.add(alias.name)
				}
			}
		}
	}
	
	//TODO refactore
	def private registerAlias(Attribute attr)
	{
		if(attr != null)
		{
			var name  = attr.name
			var alias = attr.alias
			if(alias != null && name != null)
			{
				for(SourceStruct source : sources)
					for(AttributeStruct attribute : source.attributes)
						if(attribute.attributename.equals(attr.name))
							attribute.aliases.add(alias.name)
			}
		}
	}
	
	def private checkForAmbiguousAttributes(List<Source> srcs, List<Attribute> attrs)
	{
//		var list1 = newArrayList
//		var list2 = newArrayList
//		for(SourceStruct src1 : sources)
//			for(Source src2 : srcs)
//				if(src1.sourcename.equals(src2.name))
//					if(!list2.contains(src2.name))
//					{
//						var attributenames1 = src1.attributes.stream.map(
//							e|getSimpleAttributename(e.attributename)
//						).collect(Collectors.toList)
//						var attributenames2 = src1.attributes.stream.map(
//							e|e.attributename
//						).collect(Collectors.toList)
//						
//						for(String name1 : attributenames1)
//							for(String name2 : attributenames2)
//								if(name1.equals(name2))
//									list1.add(name1)
//						
//						var Set<String> set = newHashSet(list1)
//						if(set.size() < list1.size())
//						{
//							throw new AmbiguousAttributeException(
//								"ambiguous attribute definition: rename attributes in source "+ src2.name
//							)
//						}
//					}	
						///
//						list2.add(src2.name)
//						for(String name1 : attrs.stream.map(e|e.attributename).collect(Collectors.toList))
//							for(String name2 : src1.attributes.stream.map(e|e.attributename).collect(Collectors.toList))
//							{
//								var str = getAttributename(name1).split("\\.").get(1)// ..
//								if(str.equals(name2))
//									list1.add(name2)
//							}							
//						var Set<String> set = newHashSet(list1)
//						if(set.size() < list1.size())
//						{
//							throw new AmbiguousAttributeException(
//								"ambiguous attribute definition: rename attributes in source "+ src2.name
//							)
//						}
//					}
	}
	
	def private checkExistingSources(List<Source> sources)
	{
//		var list1 =  sources.stream.map(e|e.name).collect(Collectors.toList)
//		var list2 =  this.sources.stream.map(e|e.sourcename).collect(Collectors.toList)
//		for(String name : list1)
//			if(!list2.contains(name))
//				throw new IllegalArgumentException(
//					"given source " + name + " is not contained by a known schema"
//				)
	}
	
	def private getAllSourceFromSelect(Select select)
	{
//		var list1 = EcoreUtil2.getAllContentsOfType(select, Source)
//		var iter = list1.iterator
//		while(iter.hasNext())
//		{
//			var source = iter.next()
//			if(source.name == null)
//			{
//				iter.remove()
//				getAllSourceNames(source.nested)
//			}
//			
//		}
		
	}
	
	def parseSelect(Select stmt)
	{

		// Add source aliases
		for(Source source : stmt.sources)
			registerAlias(source)
			
		// Add attribute aliases
		for(Attribute attribute : stmt.attributes)
			registerAlias(attribute)	
		
		checkExistingSources(stmt.sources)//TODO Implement
		checkForAmbiguousAttributes(stmt.sources, stmt.attributes)//TODO Implement
		
		// Parse select	and register operators
		firstJoinInQuery = true
		expressionCounter = 0
		expressionString = null
		renamedAttributes.clear()
		if(null == stmt.predicates)
			return parseSelectWithoutPredicate(stmt)
		else
			return parseSelectWithPredicate(stmt)
	}
	
	
	/** Returns all attributes that were renamed after a self join operation. **/
	def private List<String> getRenamedAttributesFromSelfJoin()
	{
		var attributes = newArrayList
		if(!renamedAttributes.empty)//TODO Refactoring and documentation
		{
			for(Entry<String, List<String>> e : renamedAttributes.entrySet)
				for(SourceStruct source : this.sources)
					if(source.sourcename.equals(e.key))
					{
						source.addRenamedAttributes(e.value)
						for(var i = 1; i < e.value.size; i++)
							if(i % 2 == 1)
								attributes.add(e.value.get(i))
					}
		}
		return attributes
	}
	
	def private CharSequence parseSelectWithoutPredicate(Select stmt)
	{
		if(!stmt.attributes.empty)//SELECT attr1, ...
		{
			var String operator1 = null
			var String operator2 = null
		    var attributes = stmt.attributes.stream.map(e|e.name).collect(Collectors.toList)
			if(!stmt.expressions.empty)//Contains expressions like SELECT DolToEuro(attr1) * 20.05 AS alias1 FROM ..
			{
				var result1 = buildMapOperator(stmt.expressions, stmt.sources)
			 	operator1 = registerOperator(result1.get(1).toString)
				attributes.addAll(
					(result1.get(0) as List<String>)
				)
			}
			if(!stmt.aggregations.empty)//Contains aggregations like SELECT AVG(attr1), MAX(attr2) AS maxAttr2s FROM ..
			{
				var result2 = buildAggregateOP(stmt.aggregations, stmt.order, stmt.sources)
			    operator2   = registerOperator(result2.get(1).toString)
				attributes.addAll(
					(result2.get(0) as List<String>)
				)
			}
			
			var String join2 = null
			if(operator1 !=null && operator2 != null)
			{
				join2 = buildJoin(stmt.sources, buildJoin(#[operator1, operator2])).toString
			}
			else if(operator1 != null)
				join2 = buildJoin(stmt.sources, operator1).toString
			else if (operator2 != null)
				join2 = buildJoin(stmt.sources, operator2).toString
			else
				join2 = buildJoin(stmt.sources).toString
				
			attributes.addAll(getRenamedAttributesFromSelfJoin())
			return '''«buildProjectOP(attributes, join2)»'''
		}
		else
		{
			if(stmt.aggregations.empty && stmt.expressions.empty)//Simple SELECT * Query
			{
				if(stmt.sources.size == 1)
					return '''«buildProjectOP(stmt.sources.get(0))»'''
				return registerOperator('''«buildJoin(stmt.sources)»''')
			}
			else 
			{
				var String operator1 = null
				var String operator2 = null
				if(!stmt.expressions.empty)//Contains expressions like SELECT DolToEuro(attr1) * 20.05 AS alias1 FROM ..
				{
					var result1 = buildMapOperator(stmt.expressions, stmt.sources)
				 	operator1 = result1.get(1).toString
				}
				
				if(!stmt.aggregations.empty)
				{
				 	var result2 = buildAggregateOP(stmt.aggregations, stmt.order, stmt.sources)
					operator2 = result2.get(1).toString
				}
				
				if(operator1 != null && operator2 != null)
				{
					return registerOperator(buildJoin(#[operator1, operator2]))
				}
				else if(operator1 != null)
					return registerOperator(operator1)
				else if(operator2 != null)
					return registerOperator(operator2)
				
			}
		}
	}
	
	def private CharSequence parseSelectWithPredicate(Select stmt)
	{
		predicateString = ''
	    var String operator1 = null
	    var String operator2 = null
	    var List<String>     attributes = stmt.attributes.stream.map(e|e.name).collect(Collectors.toList)
		var List<Expression> predicates = newArrayList
		var List<Source>        sources = newArrayList
		
		predicates.add(0, stmt.predicates.elements.get(0))
		if(stmt.having != null)
			predicates.add(0, stmt.having.elements.get(0))
		sources.addAll(stmt.sources)
		
		if(!stmt.expressions.empty)//Contains expressions like SELECT DolToEuro(attr1) * 20.05 AS alias1 FROM ..
		{
			var result1 = buildMapOperator(stmt.expressions, stmt.sources)
		 	operator1 = registerOperator(result1.get(1).toString)
			attributes.addAll((result1.get(0) as List<String>))
		}
		if(!stmt.aggregations.empty)
		{
			var result = buildAggregateOP(stmt.aggregations, stmt.order, sources)
		    operator2   = registerOperator(result.get(1).toString)
			attributes.addAll(result.get(0) as List<String>)
		}
		
		var nested = EcoreUtil2.eAllOfType(stmt, AttributeWithNestedStatement)
		if(!nested.empty)
		{//FIXME 
			for(var i = 0; i < nested.size; i++)
			{
				var a = nested.get(i).nested.attributes.stream.map(e|e.name).collect(Collectors.toSet)
				for(String s : a)
					if(!attributes.contains(s))
						attributes.add(s)
				var s = nested.get(i).nested.sources
				var names = newArrayList
				for(Source s1 : sources)
				{
					names.add(s1.name)
				}
				for(Source s2 : s)
				{
					if(!names.contains(s2.name))
						sources.add(s2)
				}	
//				for(Source c : s)
//					if(!sources.contains(c))
//						sources.add(c)
			}
		}
		
		var String join2 = null
		if(operator1 != null && operator2 != null)
			join2 = buildJoin(sources, buildJoin(#[operator1, operator2])).toString
		else if(operator1 != null)
			join2 = buildJoin(sources, operator1).toString
		else if(operator2 != null)
			join2 = buildJoin(sources, operator2).toString
		else 
			join2 = buildJoin(sources).toString
				
		attributes.addAll(getRenamedAttributesFromSelfJoin())					
		if(stmt.sources.size > 1 && !stmt.attributes.empty)// SELECT * FROM src1 / src1, .. src2 WHERE ...;
			return '''«buildSelectOP(predicates, buildProjectOP(attributes, join2))»'''
		// SELECT * FROM src1, src2, ... WHERE ...; | SELECT attr1, ... FROM src1 / src1, ... WHERE ...;
		if(stmt.attributes.empty)
			return '''«buildSelectOP(predicates, join2)»'''
		return '''«buildSelectOP(predicates, buildProjectOP(attributes, join2))»'''
	}
	
	def private Object[] buildMapOperator(List<SelectExpression> expressions, CharSequence sources)
	{
		var expressionArgument = ''
		var List<String> expressionStrings = newArrayList()
		var List<String> attributeNames = newArrayList()
		for(var i = 0; i < expressions.size; i++)
		{
			var expressionName  = ''
			var expressionString = parseSelectExpression(expressions.get(i)).toString
			if(expressions.get(i).alias ==  null)
			{
				expressionName = "expression_" + expressionCounter
				expressionCounter++
			}
			else
				expressionName = expressions.get(i).alias.name	
			expressionStrings.add(expressionString)
			expressionStrings.add(expressionName)
			expressionStrings.add(',')
			expressionArgument += generateKeyValueString(expressionStrings)
			if(i != expressions.size - 1) expressionArgument += ','
			expressionStrings.clear
			attributeNames.add(expressionName)
			this.expressions.add(expressionName)
		}
		return #[attributeNames, '''MAP({expressions = [«expressionArgument»]},«sources»)''']
	}
	
	def private Object[] buildMapOperator(List<SelectExpression> expression, List<Source> sources)
	{
		return buildMapOperator(expression, buildJoin(sources))
	}

	def private CharSequence parseSelectExpression(SelectExpression e)
	{
		var str = ''
		for(var i = 0; i < e.expressions.size; i++)
		{
			var component = (e.expressions.get(i) as ExpressionComponent).value
			switch(component)
			{
				Mapper: str += component.name + '(' + parseSelectExpression((component.value as SelectExpression)) + ')'
				Attribute: str += getAttributename(component.name)
				IntConstant: 	str += component.value + ''
				FloatConstant:  str += component.value + ''
				StringConstant: str += '\"' + component.value + '\"'
				BoolConstant: 	str += component.value + ''
			}
			if(i != e.expressions.size - 1)
			str += e.operators.get(i)
		}
		return str
	}
	
	def private Object[] buildAggregateOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, CharSequence input)
	{
		var argsstr 			 = ''
		var List<String> args    = newArrayList()
		var List<String> aliases = newArrayList()
		for(var i = 0; i < aggAttr.length; i++)
		{
			args.add(aggAttr.get(i).name.toString)
			//TODO Add expressions
			args.add(getAttributename(aggAttr.get(i).attribute.name, null))
			var alias = ''
			if(aggAttr.get(i).alias != null)
				alias = aggAttr.get(i).alias.name
			else
				alias = aggAttr.get(i).name + '_' + aggAttr.get(i).attribute.name
			args.add(alias)
			aliases.add(alias)
			args.add(getDataTypeFrom(aggAttr.get(i).attribute))
			
			////
			aggregations.add(alias)
			
			args.add(',')
			argsstr += generateKeyValueString(args)
			if(i != aggAttr.length - 1) argsstr += ','
			args.clear
		}
		//Generates the group by argument that is formed like ['attr1', attr2', ...]
		var groupby = ''
		if(!orderAttr.empty)
		{
			groupby += ',GROUP_BY=['
			groupby += generateListString(
				orderAttr.stream.map(e|getAttributename(e.name, null)).collect(Collectors.toList)
			) + ']'
		}
		return #[aliases, '''AGGREGATE({AGGREGATIONS=[«argsstr»]«groupby»}, «input»)''']
	}
	
	def private Object[] buildAggregateOP(List<Aggregation> list, List<Attribute> list2, List<Source> srcs)
	{
		return buildAggregateOP(list, list2, buildJoin(srcs))
	}
	
	def private Object[] buildAggregateOP(List<Aggregation> list, List<Attribute> list2, Source src)
	{
		return buildAggregateOP(list, list2, checkForNestedStatement(src))
	}
	
	def private CharSequence buildRenameOperator(CharSequence operator)//TODO Documentation
	{
		var list = newArrayList
		for(Entry<AttributeStruct, List<String>> l : getAttributeAliases.entrySet)
		{
			list.add(l.key.attributename)
			list.add(l.value.get(0))
		}
		return '''renamed_«getID()» = RENAME({aliases=[«generateListString(list)»], pairs='true'}, «operator»)'''
	}
	
	def private CharSequence buildRenameOperator2(List<String> paired, String source)//TODO rename method
	{
		return '''RENAME({aliases=[«generateListString(paired)»], pairs='true'}, «source»)'''
	}
	
	def private registerSourceAlias(Source source)
	{
		if(source.alias != null && source.nested == null)
			registerOperator(source.name, source.alias.name)
	}
	
	def private CharSequence parseCreateStream1(CreateStream1 create)
	{
		return registerOperator(buildCreate1("ACCESS", create.pars, create.attributes.attributes, create.attributes.datatypes, create.attributes.name).toString, create.attributes.name)
	}	
		
	def private CharSequence parseCreateSink1(CreateSink1 sink) 
	{
		return registerOperator(buildCreate1("SENDER", sink.pars, sink.attributes.attributes, sink.attributes.datatypes, sink.attributes.name).toString, sink.attributes.name)
	}	
			
	def private CharSequence buildCreate1(String type, CreateParameters pars, List<Attribute> attrs, List<DataType> dtypes, String name)
	{	
		var wrapper     = pars.wrapper
		var protocol    = pars.protocol
		var transport   = pars.transport
		var dataHandler = pars.datahandler
		var args 		= generateKeyValueString(
							attrs.map[e|e.name],
							dtypes.map[e|e.value],
							','
						  )
		var options 	= generateKeyValueString(
							pars.keys,
							pars.values,
							','
						  )		
		var t = ''
		var s = ''
		var b = false
		if(type.equals("ACCESS"))
		{
			t = 'source'
			s = '''schema = [«args»],'''	
		}
		else
		{
			b = true
			t = 'sink'	
		}				  
						  
		var sink = '''«type»
				  (
					{	  
						«t»      = '«name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						«s»
						options =[«options»]
					 }
					 «IF b»,__INPUT__«ENDIF»
				   )'''
	    if(b)
	    {
	     	sinks.put(name, sink);
	     	return''	
	    }
		return sink
	}	
		
	def private CharSequence parseCreateStreamFile(CreateStreamFile file)
	{
		var schema = generateKeyValueString(
					file.attributes.attributes.map[e|e.name],
					file.attributes.datatypes.map[e|e.value],
					','
				  )
		
		var options = '''['filename','«file.filename»'],['delimiter',';'],['textDelimiter',"'"],['readfirstline','true']'''		  
		return registerOperator(buildCreate2('GenericPull', file.type, 'File', 'Tuple', schema, options, file.attributes.name).toString, file.attributes.name)
	}
	
	def private CharSequence parseCreateStreamChannel(CreateStreamChannel channel) 
	{
		var schema = generateKeyValueString(
			channel.attributes.attributes.map[e|e.name],
			channel.attributes.datatypes.map[e|e.value],
			','
		  )
		
		var options = '''['port','«channel.port»'],['host', '«channel.host»']'''		  
		return registerOperator(buildCreate2('GenericPush', 'SizeByteBuffer', 'NonBlockingTcp', 'Tuple', schema, options, channel.attributes.name).toString, channel.attributes.name)
	}	
	
	def private CharSequence buildCreate2(String wrapper, String protocol, String transport, String dataHandler, String schema, String options, String name)
	{						  
		return '''ACCESS
				  (
					{	  
						source      = '«name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						schema = [«schema»],
						options =[«options»]
					 }
				   )'''
	}
		
	def private CharSequence parseCreateView(CreateView view)
	{
		return registerOperator(parseSelect(view.select).toString, VIEW + getID())
	}
		
	def private parseStreamtoStatement(StreamTo to)
	{
		if(to.statement != null)
		{
			streamto.put(to.name, parseSelect(to.statement).toString)
			
		}		
		else
		{
			streamto.put(to.name, to.inputname)
		}

		if(sinks.keySet.contains(to.name))
			return '''«sinks.get(to.name).replace("__INPUT__", streamto.get(to.name))»'''
		return ''
	}

	def private String selfJoin(String scr1, String src2)
	{
		var source1 = scr1
		if(source1.equals(src2))
		{
			var paired = newArrayList
			var attributes = newArrayList
			for(String name : getAttributeNamesFrom(source1))
			{
				var attributename = source1 + "." + name + "_" + joinCounter.toString
				paired.add(name)
				paired.add(attributename)
				attributes.add(attributename)
			}
			renamedAttributes.put(source1, paired)			
			source1 = buildRenameOperator2(paired, source1).toString
			joinCounter++
		}
		return source1
	}
	
	def private CharSequence buildJoin(String[] srcs)
	{
		var sourcenames = srcs
		if(firstJoinInQuery)
			Collections.sort(sourcenames)
		firstJoinInQuery = false
				
		if(sourcenames.size < 1)
		{ 
			throw new IllegalArgumentException(
				"Invalid number of source elements: There have to be at least two sources"
			)
		}
		if(sourcenames.size == 1)//Will only be considered if the first call of this method provides a single source
		{
			firstJoinInQuery = true
			return sourcenames.get(0)
		}
		var List<String> list = new ArrayList(Arrays.asList(sourcenames))
		var source1 = list.get(0)
		var source2 = list.get(1)
		source1 = selfJoin(source1, source2)
		
		if(list.size == 2)
		{
			firstJoinInQuery = true
			return '''JOIN(«source1»,«source2»)'''
		}
		list.remove(0)
		return '''JOIN(«source1»,«buildJoin(list)»)'''
	}

	def private buildJoin(List<Source> scrs)
	{
		
		var args = scrs.stream.map(
			e|checkForNestedStatement(e).toString
		).collect(Collectors.toList)

		return buildJoin(args)
	}

	def private CharSequence buildJoin(List<Source> srcs, CharSequence input2)
	{
		var args = srcs.stream.map(
			e|checkForNestedStatement(e).toString
		).collect(Collectors.toList)
		
		if(input2 != null)
			args.add(input2.toString)
		return buildJoin(args)
	}

	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a char sequence to define the input operator. 
	 */
	def private CharSequence buildSelectOP(Expression predicate, CharSequence operator)
	{
		predicateString = ''
		var result = '''SELECT({predicate='«parsePredicate(predicate)»'},«operator»)'''
		return registerOperator(result)
	}
	
	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a char sequence to define the input operator. 
	 */
	def private CharSequence buildSelectOP(List<Expression> predicate, CharSequence operator)
	{
		predicateString = ''
		return registerOperator('''SELECT({predicate='«parsePredicate(predicate)»'},«operator»)''')
	}
	
	def private CharSequence buildProjectOP(String[] attributes, CharSequence operator)
	{
		return registerOperator('''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|getAttributename(e, null)).collect(Collectors.toList))»]
				  	},«operator»)''')
	}
	
	def private CharSequence buildProjectOP(Source src)
	{
		return buildProjectOP(#[] as String[], src)
	}
	
	def private CharSequence buildProjectOP(String[] attributes, Source src)
	{
		if(src == null) { throw new NullPointerException("Given source was null") }
		
		if(attributes.empty)
		{
			return registerOperator('''PROJECT(
						{
							attributes=[«generateListString(getAttributeNamesFrom(src.name).stream.map(e|getAttributename(e,src.name)).collect(Collectors.toList))»]
						},«checkForNestedStatement(src)»)''')
		}
		return registerOperator('''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|getAttributename(e,src.name)).collect(Collectors.toList))»]
				  	},«checkForNestedStatement(src)»)''')
	}
	
	//TODO String have to be encupseld between '
	/**Builds a predicate string from a given {@link Expression}. */
	def CharSequence parsePredicate(Expression e)
	{
		if(!e.eContents.empty)
		{
			switch e
			{
				Or:
				{
					parsePredicate(e.left)
					predicateString += '||'
					parsePredicate(e.right)
				}
				And:
				{
					parsePredicate(e.left)
					predicateString += '&&'
					parsePredicate(e.right)
				}  
				Equality:
				{
					parsePredicate(e.left)
					if(e.op.equals("="))
						predicateString += '=='
					else
						predicateString += e.op
					parsePredicate(e.right)
				}
				Comparision:
				{
					parsePredicate(e.left)
					predicateString += e.op	  
					parsePredicate(e.right)	
				}
				Plus:
				{
					parsePredicate(e.left)
					predicateString += '+'
					parsePredicate(e.right)
				}
				Minus:
				{
					parsePredicate(e.left)
					predicateString += '-'
					parsePredicate(e.right)					
				}
				MulOrDiv:
				{
					parsePredicate(e.left)
					predicateString += e.op
					parsePredicate(e.right)
				}
				NOT:
				{
					predicateString += '!'
					parsePredicate(e.expression)
				}
				Bracket:
				{
					predicateString += '(' 
					parsePredicate(e.inner)
					predicateString += ')' 
				}
				AttributeRef:
				{
					/* attr1 > 10 AND attr1 IN (SELECT attr1 FROM s1 WHERE attr1 != 10) AND attr2 IN (... )
					 * AttributeRef := (attr1 IN (SELECT attr1 FROM s1 WHERE attr1 != 10))
					 */
					if(e.value instanceof AttributeWithNestedStatement)
					{
						parseNestedPredicate((e.value as AttributeWithNestedStatement).nested)
//						for(Source source : (e.value as AttributeWithNestedStatement).nested.sources)
//						{
//							
//						}
					} 
					else
					{
						if(e.value instanceof Attribute)
							predicateString += getAttributename(e.value as Attribute, null)
					}
				}  	 
			}
		} 
		else
		{
			var str = ''
			switch e
			{
				IntConstant: 	str = e.value + ''
				FloatConstant:  str = e.value + ''
				StringConstant: str = "'" + e.value + "'"
				BoolConstant: 	str = e.value + ''
	
			}
			predicateString += str
		}
//		println(predicate)
		return predicateString
	}
	
	def private CharSequence parseNestedPredicate(Select select)
	{
		var pred = select.predicates
		if(pred == null)
		{
			for(Source s : checkForNestedStatement(select.sources))
			{
				var p = s.nested.predicates
				if(p != null)
				{				
					predicateString += parsePredicate(s.nested.predicates.elements.get(0))
				}
			 }
			return predicateString
		}
		else
		{
			return parsePredicate(pred.elements.get(0))
		}
	}
	
	def CharSequence parsePredicate(List<Expression> expressions)
	{
		var s = ''
		for(var i = 0 ; i < expressions.size - 1; i++)
		{
			if(expressions.get(i) instanceof AttributeRef)
			{
				if((expressions.get(i) as AttributeRef).value instanceof AttributeWithNestedStatement)
				{
					// ignore it!
				}
			}
			else
			{
				predicateString = ''
				var result = parsePredicate(expressions.get(i))
				s +=  result + '&&'
			}
		}
		predicateString = ''
		s += parsePredicate(expressions.get(expressions.size - 1))
		return s
	}
		
	def private CharSequence checkForNestedStatement(Source src)
	{
		if(src.nested != null)
		{
			var nested = parseSelect(src.nested)
			var alias = src.alias.name
			registerNestedSelect(nested.toString, alias)
			return alias
		}
		else
			return buildWindowOP(src)
	}

	def private List<Source> checkForNestedStatement(List<Source> srcs)
	{
		var List<Source> l = newArrayList
		for(Source s : srcs)
			if(s.nested != null)
				l.add(s)
				
		return l
	}

	def private CharSequence buildWindowOP(Source src)
	{
		if(src.time != null)
		{
			var var1 = if(src.time.advance_size != 0) src.time.advance_size else 1
			var var2 = if(src.time.advance_size != 0) src.time.advance_unit else src.time.unit
			return '''TIMEWINDOW
					  (
					  	{
					  		size = [«src.time.size»,'«src.time.unit»'],
					  		advance = [«var1»,'«var2»']
						},
						«src.name»
					 )'''			 
		}
		else if(src.tuple != null)
		{
			var var1 = if(src.tuple.advance_size != 0) src.tuple.advance_size else 1
			if(src.tuple.partition_attribute == null)
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»
						   	},
						   	«src.name»
						   )'''

			}
			else
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»,
								partition = '«src.tuple.partition_attribute.name»'
						   	},
						   	«src.name»
						   )'''
			}			
		}
		else 
		{ 
			return src.name
		}
		
	}

	def private String generateKeyValueString(String ... s)
	{
		var str = "["
		if(s.length == 1) 
			return str += "'" + s.get(0) + "']"
		for(var i = 0; i < s.length - 2; i++)
			str += "'" + s.get(i) + "'" + s.get(s.length - 1)			
		return str += "'" + s.get(s.length - 2) + "']"
	}
		
	def private String generateKeyValueString(List<String> l1, List<String> l2, String s)
	{
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)// OUT of bounds...
		{
			str += generateKeyValueString(l1.get(i), l2.get(i), s) + ","
		}
		return (str += generateKeyValueString(l1.get(l1.size - 1), l2.get(l1.size - 1), s))
	}
	
	def private String generateKeyValueString(String s1, List<String> l2, String s2)
	{
		var str = ''
		for(var i = 0; i < l2.size - 1; i++)
		{
			str += generateKeyValueString(s1, l2.get(i), s2) + ","
		}
		return (str += generateKeyValueString(s1, l2.get(l2.size - 1), s2))
	}
	
	def private String generateListString(String s1)
	{
		return "'" + s1 + "'"
	}
		
	def private String generateListString(List<String> l1)
	{
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)
		{
			str += generateListString(l1.get(i)) + ","
		}
		return (str += generateListString(l1.get(l1.size - 1)))
	}
	
	def private CharSequence getID()
	{
		operatorCounter++
		return operatorCounter.toString
	}

	def private void registerSources(Collection<SDFSchema> schema, boolean internal)
	{
		for(SDFSchema s : schema)
		{
			for(String sourcename : s.baseSourceNames)
			{
				var source = new SourceStruct()
				source.internal = false
				source.sourcename = sourcename
				source.attributes = newArrayList()
				source.aliases = newArrayList()
				for(SDFAttribute attributename : s.attributes)
					if(sourcename.equals(attributename.sourceName))
					{
						var attribute = new AttributeStruct()
						attribute.attributename = attributename.attributeName 
						attribute.sourcename = sourcename
						attribute.datatype = attributename.datatype.toString	
						attribute.aliases = newArrayList()		
						source.attributes.add(attribute)
					}						
				sources.add(source)
			}
		}
	}

	def void setOuterschema(Collection<SDFSchema> schema)
	{
		registerSources(schema, false)
	}

	def void setInnerschema(Collection<SDFSchema> schema)
	{
		registerSources(schema, true)
	}

	def private registerNestedSelect(String name, String alias)
	{
		if(nSelect.containsKey(name))
		{
			if(!nSelect.containsValue(alias))
			{
				var aliases = nSelect.get(name)
				aliases.add(alias)
				nSelect.put(name, aliases)
			}
		}
		else
		{
			var aliases = newArrayList
			aliases.add(alias)
			nSelect.put(name, aliases)
		}
	}
	
	def public String getDataTypeFrom(Attribute attribute) 
	{
		if(attribute == null) throw new NullPointerException("given attribute was null")
		
		var attributename = attribute.name
		if(attribute.name.contains("."))
		{
			var String[] name = attribute.name.split("\\.")
			if(attributeAliasesAsList.contains(name.get(1)))
				attributename = getAttributenameFromAlias(name.get(1))	
			else 
				attributename = name.get(1)
		}
		else
			if(attributeAliasesAsList.contains(attribute.name))
				attributename = getAttributenameFromAlias(attribute.name)
		
//		println(getAttributes().stream.map(e|e.attributename).collect(Collectors.toList))
		for(AttributeStruct attr : getAttributes())
			if(attr.attributename.equals(attributename))
				return attr.datatype		
				
		throw new IllegalArgumentException("given attribute " + attribute.name + "unknown")		
	}
	
	def public String getSourcenameFromAlias(String sourcealias)
	{
		for(Entry<SourceStruct, List<String>> source : getSourceAliases().entrySet)
			if(source.value.contains(sourcealias))
				return source.key.sourcename

		throw new IllegalArgumentException("given alias " + sourcealias + " is invalid: no corresponding source found")									
	}
	
	def public String getAttributenameFromAlias(String attributealias)
	{
		if(attributealias == null || attributealias.equals(""))
			throw new IllegalArgumentException("given alias was null or an empty string")
		
		for(Entry<AttributeStruct, List<String>> entry : getAttributeAliases.entrySet)
			for(String alias : entry.value)
				if(alias.equals(attributealias))
					return entry.key.attributename
		
		if(this.aggregations.contains(attributealias) || this.expressions.contains(attributealias))
			return attributealias			
					
		throw new IllegalArgumentException("given alias " + attributealias + " is invalid: no corresponding attribute found")									
	}
	
	def public String getAttributename(String attribute, String srcname)
	{
		if(srcname != null && !srcname.equals(""))
		{
			for(SourceStruct struct : sources)
				if(struct.sourcename.equals(srcname))
					return srcname + "." + struct.findbyName(attribute).attributename
		}
		
		if(attribute.contains("."))
		{
			/*
			 * Hint a simple . as regex won't work, because 
			 * it's the metacharacter for 'match all'. Hence
			 * \\. is used instead.
			 */
			var String[] name = attribute.split('\\.')
			if(name != null && name.length == 2)
			{
				var attributes = getAttributes().stream.map(e|e.attributename).collect(Collectors.toList)
				var sources = getAttributes().stream.map(e|e.sourcename).collect(Collectors.toList)
				if(sources.contains(name.get(0)))
					if(attributes.contains(name.get(1)))
						return attribute
					else
						return name.get(0) + '.' + getAttributenameFromAlias(name.get(1))
				else
					if(attributes.contains(name.get(1)))
						return getSourcenameFromAlias(name.get(0)) + '.' + name.get(1)
					else	
						return getSourcenameFromAlias(name.get(0)) + '.' + getAttributenameFromAlias(name.get(1))
			}
			throw new IllegalArgumentException("attribute " + attribute + " could not be resolved" )
		}
		
		//TODO refactore
		var String name = attribute
		for(List<String> l : getAttributeAliases.values)
			if(l.contains(attribute))
				name = getAttributenameFromAlias(attribute)
		
		for(AttributeStruct attr : getAttributes)
			if(attr.attributename.equals(name))
				return attr.sourcename + '.' + attr.attributename

		if(this.aggregations.contains(attribute) || this.expressions.contains(attribute))
			return attribute			
				
		throw new IllegalArgumentException("attribute " + attribute + " could not be resolved" )		
	}
	
	def public String getAttributename(Attribute attribute, String srcname)
	{
		return getAttributename(attribute.name, srcname)
	}
	
	def public String getAttributename(Attribute attribute)
	{
		return getAttributename(attribute.name, null)
	}
	
	def public String getAttributename(String attribute)
	{
		return getAttributename(attribute, null)
	}
	
	//unused
	def public String getSimpleAttributename(String attribute)
	{
		var name = ''	
		if(attribute.contains("."))
			name = attribute.split("\\.").get(1)
			
		if(attributeAliasesAsList.contains(name))
			return getAttributenameFromAlias(attribute)
		return name		
	}
	
	/** Returns all {@link Attribute} elements to the corresponding source. */
	def public List<String> getAttributeNamesFrom(String srcname) 
	{
 		for(SourceStruct source : sources)
			if(source.sourcename.equals(srcname))
			{
				var list = source.attributes.stream.map(e|e.attributename).collect(Collectors.toList);
				return list 
			}
	}
	
	
	/* Builds an AggregationOP -> was replaced by buildAggregateOP(..)
	def Object[] buildAggregationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, CharSequence input) 
	{
		//Produces a string array with strings like 'FUNCTION' = 'COUNT' 
		var functions = generateKeyValueString(
			'FUNCTION',
			aggAttr.stream.map(e|e.name).collect(Collectors.toList),
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		//Produces a string array with strings like 'INPUT_ATTRIBUTES' = 'attr1'
		var input_attr = generateKeyValueString(
			'INPUT_ATTRIBUTES',
			aggAttr.stream.map(e|e.attribute.name).collect(Collectors.toList),
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		
		//Creates a list with aliases from the given argument and adds missing aliases
		var List<String> aliases = newArrayList()
		for(var i = 0; i < aggAttr.length; i++)
		{
			if(aggAttr.get(i).alias != null)
				aliases.add(aggAttr.get(i).alias.name)
			else
				aliases.add(aggAttr.get(i).name + '_' + aggAttr.get(i).attribute.name)
		}
		//Produces a string array with strings like 'OUTPUT_ATTRIBUTES' = 'COUNT_attr1'
		//or with a corresponding alias for the attribute
		var output_attr = generateKeyValueString(
			'OUTPUT_ATTRIBUTES',
			aliases,
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		
		var List<String> lll = newArrayList()
		for(var i = 0; i < functions.size; i++)
		{
			lll.add(functions.get(i) + ',' + input_attr.get(i))
		}
		//Generates the finally argument string that is formed like 
		// ['FUNCTION' = 'COUNT', 'INPUT_ATTRIBUTES' = 'attr1', 'OUTPUT_ATTRIBUTES' = 'COUNT_attr1'] , [...]
		var args = generateKeyValueString(
			lll,
			output_attr,
			','
		).replace("[''", "['")
		.replace("'']", "']")
		.replace("'',''", "','")

		//Generates the group by argument that is formed like ['attr1', attr2', ...]
		var groupby = ''
		if(!orderAttr.empty)
		{
			groupby += ',GROUP_BY=['
			groupby += generateListString(
				orderAttr.stream.map(e|e.name).collect(Collectors.toList)
			) + ']'
		}
		return (#[aliases, '''AGGREGATION({AGGREGATIONS=[«args»]«groupby»}, «input»)'''])
	}
	
	def Object[] buildAggregationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, Source src) 
	{
		return buildAggregationOP(aggAttr, orderAttr, buildWindowOP(src))
	}

	def Object[] buildAggregationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, List<Source> src) 
	{
		return buildAggregationOP(aggAttr, orderAttr, buildJoin(null, src))
	}
	 */
}