/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.generator

import de.uniol.inf.is.odysseus.core.sdf.schema.SDFAttribute
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFDatatype
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.And
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeRef
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Create_Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Expression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Or
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Select_Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant
import java.util.HashSet
import java.util.List
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.DataType

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CQLGenerator extends AbstractGenerator 
{

//	@Inject extension IQualifiedNameProvider

	var Set<SDFAttribute> attributes = new HashSet
	var Map<String, SDFAttribute> map

	def void setSchema(Set<SDFSchema> s)
	{
		for(SDFSchema t : s)
		{
//			print(t)//TODO Remove after debugging
			attributes.addAll(t.attributes)
		}
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		var i = 0 ;
		for(e : resource.allContents.toIterable.filter(typeof(Statement)))
		{
			fsa.generateFile(
//				e.fullyQualifiedName.toString() + '.pql',
//				 i + " " + resource.URI.lastSegment.replace('.cql', '.pql'),
				""+ i++,	
				e.parseStatement()
			)
		}
	}
	
	def CharSequence parseStatement(Statement stmt)
	'''
	«switch stmt.type 
	{
	Select_Statement : parseSelect(stmt.type as Select_Statement)
	Create_Statement : parseCreate(stmt.type as Create_Statement)
	}
	»
	'''
	
	def parseCreate(Create_Statement stmt)
	{
		var ch = stmt.channel
		if(ch!= null)
		{
			var args = generateKeyValueString(
				ch.attributes.map[e|e.name],
				ch.datatypes.map[e|e.value]
			)
			
			return
			'''
			«getKeyword(0) + ch.name» := ACCESS({source = '«ch.name»', 
			wrapper = 'GenericPush',
			schema = [«args»],
			transport = 'NonBlockingTcp',
			protocol = 'SizeByteBuffer',
			dataHandler ='Tuple',
			options =[['port', '«ch.port»'],['host', '«ch.host»']]})
			'''
		}
		else
		{
			var af = stmt.accessframework
		 	var type = ''
			switch af.type
			{
				case "VIEW",
				case "STREAM":
					type = "ACCESS"
				case "SINK":
					type = "SENDER"	
			}
			var args = ''
			var bool = type.equals('ACCESS')
			if(bool)
			{
				args = generateKeyValueString(
					af.attributes.map[e|e.name],
					af.datatypes.map[e|e.value]
				)
			}
			var options = generateKeyValueString(
				af.keys,
				af.values
			)
			
			return 
			'''
			«getKeyword(2) + af.name» := «type» (
			{«IF bool»source ='«af.name»',«ENDIF»
			«IF !bool»sink='«af.name»'«ENDIF»
			wrapper='«af.wrapper»',
			protocol='«af.protocol»',
			transport='«af.transport»',
			dataHandler='«af.datahandler»',
			«IF bool»schema=[«args»],«ENDIF»
			options=[«options»]})
			'''	
		}
	}

	val static CharSequence[] keywords = #['input_', 'window_', 'output_', 'select_']

	def static CharSequence getKeyword(int i)
	{
		if(i >= keywords.length || i < 0)
			return 'WRONG_INDEX_NO_KEYWORD'
		return keywords.get(i);
	}

	def CharSequence parseSelect(Select_Statement stmt)
	{
		predicate = ''
		if(stmt.predicates == null)//Without a WHERE clause
		{
			return
			'''
			«buildAccessOP(stmt.attributes, stmt.sources, true)»
			'''
		}
		else
		{ 
			return
			'''
			«getKeyword(3)» := SELECT({predicate='
			«buildPredicate(stmt.predicates.elements.get(0))»'},
			«buildAccessOP(stmt.attributes, stmt.sources, false)»)
			'''					
		}
	}

	var predicate = ''
	def CharSequence buildPredicate(Expression e)
	{
		if(!e.eContents.empty)
		{
			switch e
			{
				Or:
				{
					buildPredicate(e.left)
					predicate += '||'
					buildPredicate(e.right)
				}
				And:
				{
					buildPredicate(e.left)
					predicate += '&&'
					buildPredicate(e.right)
				}  
				Equality:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)
				}
				Comparision:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)	
				}
				Plus:
				{
					buildPredicate(e.left)
					predicate += '+'
					buildPredicate(e.right)
				}
				Minus:
				{
					buildPredicate(e.left)
					predicate += '-'
					buildPredicate(e.right)					
				}
				MulOrDiv:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)
				}
				NOT:
				{
					predicate += '!'
					buildPredicate(e.expression)
				}
				Bracket:
				{
					predicate += '(' 
					buildPredicate(e.inner)
					predicate += ')' 
				}
				AttributeRef:
				{
					predicate += e.value.name
				}  	 
			}
		} 
		else
		{
			var str = ''
			switch e
			{
				IntConstant: 	str = e.value + ''
				FloatConstant:  str = e.value
				StringConstant: str = "'" + e.value + "'"
				BoolConstant: 	str = e.value
	
			}
			predicate += str
		}
	}
	
	var wrapper = 'GenericPush'
	var transport = 'TCPClient'
	var dataHandler = 'Tuple'
	def CharSequence buildAccessOP(List<Attribute> attr, List<Source> src, boolean b)
	{
		var str = ''
		for(var i = 0; i < src.size - 1; i++)
		{
			if(b) str += src.get(i).name + ":= "
			str +=
			"ACCESS
			(
				{	
					source = '"+getKeyword(0) + src.get(i).name+"',
					wrapper = '"+wrapper+"',
					transport = '"+transport+"',
					dataHandler = '"+dataHandler+"',
					schema = ["+buildSchema(attr, src.get(i))+"]
				}
			)	
			"
			+buildWindowOP(src.get(i), src.get(i).name)
			+","
		}
		if(b) str += src.get(src.size - 1).name + ":= "
		str +=
		"ACCESS
		(
			{	
				source = '"+getKeyword(0) + src.get(src.size - 1).name+"',
				wrapper = '"+wrapper+"',
				transport = '"+transport+"',
				dataHandler = '"+dataHandler+"',
				schema = ["+buildSchema(attr, src.get(src.size - 1))+"]
			}
		)
		"
		+buildWindowOP(src.get(src.size - 1), src.get(src.size - 1).name)
		
		return str
	}

	def CharSequence buildWindowOP(Source w, CharSequence name)
	{
	
		if(w.time != null)
		{
			'''
			«getKeyword(1)»«name» := TIMEWINDOW
			({size = [«w.time.size», '«w.time.unit»']},
			«getKeyword(0)»«name»
			)
			'''
		}
		else if(w.tuple != null)
		{
			var var1 = if(w.tuple.advance_size != 0) w.tuple.advance_size else 1
			if(w.tuple.partition_attribute == null)
			{
				'''
				«getKeyword(1)»«name» := ELEMENTWINDOW
				(
					{size = «w.tuple.size»,
					advance = «var1»
					},
				«getKeyword(0)»«name»
				)
				'''
			}
			else
			{
				'''
				«getKeyword(1)»«name» := ELEMENTWINDOW
				(
					{size = «w.tuple.size»,
					advance = «var1»,
					partition = '«w.tuple.partition_attribute.name»'
					},
				«getKeyword(0)»«name»
				)
				'''
			}			
		}
		else if(w.unbounded != null)
		{
			''''''
		}
		else
		{
			''''''
		}
	}
		
		
	def String generateKeyValueString(List<String> l1, List<String> l2)
	{
		var args = ''
		var size = l1.size
		for(var i = 0; i < size -1; i++)
		{
			args += "['" + l1.get(i)+ "','" + l2.get(i) + "'],\n"
		}
		args += "['" + l1.get(size - 1) + "','" + l2.get(size - 1) + "']"
		return args
	}
		
	//TODO Refactore	
	def CharSequence buildSchema(List<Attribute> attr, Source src)
	{
		var str = '\n'
		var SDFDatatype type
		var String alias
		if(attr.size == 0)
		{
			for(a : attributes)
			{
				if(a.sourceName.equals(src.name))
				{
					alias = a.attributeName
					type = a.datatype
					str += "['" + alias + "', '" + type.toString + "'],\n"
				}
			}
			str = str.substring(0, str.length - 2)
		}
		else
		{
			for(a : attributes)
			{
				if(a.sourceName.equals(src.name))
				{
					type = a.datatype
					str += "['" + a.attributeName + "', '" + type.toString + "'],\n"
				}
			}
			str = str.substring(0, str.length - 2)
		}
		str
	}	
}