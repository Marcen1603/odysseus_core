/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.generator

import de.uniol.inf.is.odysseus.core.sdf.schema.SDFAttribute
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AccessFramework
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Aggregation
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.And
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeRef
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ChannelFormat
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Create_Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Expression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionsModel
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Or
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Select_Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StreamTo
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.List
import java.util.Map
import java.util.Set
import java.util.stream.Collectors
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGenerator2
import org.eclipse.xtext.generator.IGeneratorContext
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.impl.AttributeImpl

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CQLGenerator implements IGenerator2
{

	var Set<SDFAttribute> outerattributes = new HashSet
	var Set<SDFAttribute> innerattributes = new HashSet
	var Set<SDFSchema>    innerschema;
	var Set<SDFSchema>    outerschema;
	var Map<String, String> sinks = new HashMap	
	var Map<String, String> streamto = new HashMap	
	var count_ID = 0
	var predicate = ''

	override afterGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context)  {}
	override beforeGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		var i = 0 ;
		for(e : resource.allContents.toIterable.filter(typeof(Statement)))
		{
			fsa.generateFile(
				""+ i++,	
				e.parseStatement()
			)
		}
	}
	
	def CharSequence parseStatement(Statement stmt)
	{
		switch stmt.type 
		{
			Select_Statement : parseSelectStatement(stmt.type as Select_Statement, false)
			Create_Statement : parseCreateStatement(stmt.type as Create_Statement, false)
			StreamTo		 : parseStreamtoStatement(stmt.type as StreamTo)
		}
		
	}
	
	def CharSequence parseSelectStatement(Select_Statement stmt, boolean isView)
	{
		predicate = ''
		var symbol1 = if(isView) ' := ' else ' = '
		if(stmt.predicates == null)//SELECT attr1, ... / * FROM ...;
		{
			println("1")
			if(!stmt.attributes.empty)//SELECT attr1, ...
			{
				println("2.1")
				if(stmt.sources.size == 1)//.. FROM src1;
				{
					if(stmt.aggregations.empty)
					{
						return '''project_«getID() + symbol1»«buildProjectOP(stmt.attributes, stmt.sources.get(0))»'''										
					}
					else// case 2 for aggregations with one source
					{
						println("buildAggregationOP()")
						var agg = buildAggregrationOP(stmt.aggregations, stmt.order,'')
						return '''project_«getID() + symbol1»«»'''
					}
				}
				else//.. FROM src1, src2, ...;
				{
					println("2.2")
					if(stmt.aggregations.empty)
					{
						return '''project_«getID() + symbol1»«buildProjectOP(stmt.attributes, buildJoin(null, stmt.sources))»'''	
					}	
					else
					{
						println("buildAggregationOP()")
						var agg = buildAggregrationOP(stmt.aggregations, stmt.order,'')
						return ''''''// case 2 for aggregations with several sources
					}
				}
			}
			else//SELECT * ..
			{
				if(stmt.sources.size == 1)//.. FROM src1;
				{
					var Source src = stmt.sources.get(0);
					if(stmt.aggregations.empty)
					{
						return '''project_«getID() + symbol1»«buildProjectOP(null, src)»'''
					}
					else
					{
						println("buildAggregationOP()2")
						var result = buildAggregrationOP(stmt.aggregations, stmt.order, src)
						var List<String> attributes = result.get(0) as List<String>
						var String operator   = result.get(1).toString
//						println(agg.get(1).toString)
						return '''project_«getID() + symbol1 + operator»'''
					}												
				}
				else//.. FROM src1, src2, ...;
				{
					if(stmt.aggregations.empty)
					{
						return '''join_«getID() + symbol1»«buildJoin(null, stmt.sources)»'''
					}
					else
					{
						println("buildAggregationOP()")
var agg = buildAggregrationOP(stmt.aggregations, stmt.order,'')
						println(agg)
						return ''''''												
					}
				}				
			}
		}
		else
		{ 
			if(stmt.sources.size > 1 && !stmt.attributes.empty)// SELECT * FROM src1 / src1, .. src2 WHERE ...;
			{
				return '''select_«getID() + symbol1»«buildSelectOP(stmt.predicates, buildProjectOP(stmt.attributes, buildJoin(null, stmt.sources)))»'''	
			}// SELECT * FROM src1, src2, ... WHERE ...; | SELECT attr1, ... FROM src1 / src1, ... WHERE ...;
			if(stmt.attributes.empty)
			{
				return '''select_«getID() + symbol1»«buildSelectOP(stmt.predicates, stmt.sources)»'''
			}
			return '''select_«getID() + symbol1»«buildSelectOP(stmt.predicates, buildProjectOP(stmt.attributes, stmt.sources.get(0)))»'''
		}
	}
	
	//TODO In progress!
	def Object[] buildAggregrationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, CharSequence input) 
	{
		//Produces a string array with strings like 'FUNCTION' = 'COUNT' 
		var functions = generateKeyValueString(
			'FUNCTION',
			aggAttr.stream.map(e|e.name).collect(Collectors.toList),
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		//Produces a string array with strings like 'INPUT_ATTRIBUTES' = 'attr1'
		var input_attr = generateKeyValueString(
			'INPUT_ATTRIBUTES',
			aggAttr.stream.map(e|e.attribute.name).collect(Collectors.toList),
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		
		//Creates a list with aliases from the given argument and adds missing aliases
		var List<String> aliases = newArrayList()
		for(var i = 0; i < aggAttr.length; i++)
		{
			if(aggAttr.get(i).alias != null)
				aliases.add(aggAttr.get(i).alias.name)
			else
				aliases.add(aggAttr.get(i).name + '_' + aggAttr.get(i).attribute.name)
		}
		//Produces a string array with strings like 'OUTPUT_ATTRIBUTES' = 'COUNT_attr1'
		//or with a corresponding alias for the attribute
		var output_attr = generateKeyValueString(
			'OUTPUT_ATTRIBUTES',
			aliases,
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		
		var List<String> lll = newArrayList()
		for(var i = 0; i < functions.size; i++)
		{
			lll.add(functions.get(i) + ',' + input_attr.get(i))
		}
		//Generates the finally argument string that is formed like 
		// ['FUNCTION' = 'COUNT', 'INPUT_ATTRIBUTES' = 'attr1', 'OUTPUT_ATTRIBUTES' = 'COUNT_attr1'] , [...]
		var args = generateKeyValueString(
			lll,
			output_attr,
			','
		).replace("[''", "['")
		.replace("'']", "']")
		.replace("'',''", "','")

		//Generates the group by argument that is formed like ['attr1', attr2', ...]
		var groupby = ''
		if(!orderAttr.empty)
		{
			groupby += ',GROUP_BY=['
			groupby += generateListString(
				orderAttr.stream.map(e|e.name).collect(Collectors.toList)
			) + ']'
		}
		return (#[aliases, '''AGGREGATION({AGGREGATIONS=[«args»]«groupby»}, «input»)'''])
	}
	
	def Object[] buildAggregrationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, Source src) 
	{
		return buildAggregrationOP(aggAttr, orderAttr, src.name)
	}

	def Object[] buildAggregrationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, List<Source> src) 
	{
		return buildAggregrationOP(aggAttr, orderAttr, buildJoin(null, src))
	}
	
	def CharSequence parseCreateStatement(Create_Statement stmt, boolean isView)
	{
		var symbol1 = if(isView) ' := ' else ' = '
		var ch = stmt.channelformat
		if(ch!= null)
		{
			if(ch.stream != null)
			{
				return '''«ch.stream.name + symbol1»«buildAccessOP(ch)»'''
			}
			if(ch.view.select != null) 
			{
				var str = parseSelectStatement(ch.view.select, true).toString
				return str.replace(str.substring(0, str.indexOf(":")), ch.view.name + " ")
			}
			var str = parseCreateStatement(ch.view.create, true).toString
			return str.replace(str.substring(0, str.indexOf(":")), ch.view.name + " ")
		}
		else
		{
			var af = stmt.accessframework
			if(af.type.equals("STREAM"))
			{
				return '''«af.name + symbol1»«buildAccessOP(af)»'''
			}
			buildSenderOP(af)
			return ''''''
		}
	}
		
	def parseStreamtoStatement(StreamTo stmt)
	{
		if(stmt.statement != null)
		{
			var s = parseSelectStatement(stmt.statement, false).toString
			streamto.put(stmt.name, s.subSequence(s.indexOf('=') + 1, s.length).toString)		
		}
		else
		{
			streamto.put(stmt.name, stmt.inputname)
		}
		if(!sinks.keySet.contains(stmt.name)) 
		{ 
			return ''
		}
		return '''output«getID() + " = " + sinks.get(stmt.name).replace("_INPUT_", streamto.get(stmt.name))»'''			
	}
		
	def CharSequence buildAccessOP(ChannelFormat channel)
	{
		var wrapper     = 'GenericPush'
		var protocol    = 'SizeByteBuffer'
		var transport   = 'NonBlockingTcp'
		var dataHandler = 'Tuple'		
		var args 		= generateKeyValueString(
							channel.stream.attributes.map[e|e.name],
							channel.stream.datatypes.map[e|e.value],
							','
						  )
						  
		return '''ACCESS
				  (
					{	  
						source      = '«getKeyword(0) +  channel.stream.name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						schema = [«args»],
						options =[['port', '«channel.stream.port»'],
								  ['host', '«channel.stream.host»']]
					 }
				   )'''
	}	
		
	def CharSequence buildAccessOP(AccessFramework access)
	{
		var wrapper     = access.wrapper
		var protocol    = access.protocol
		var transport   = access.transport
		var dataHandler = access.datahandler
		var args 		= generateKeyValueString(
							access.attributes.map[e|e.name],
							access.datatypes.map[e|e.value],
							','
						  )
						  
		var options 	= generateKeyValueString(
							access.keys,
							access.values,
							','
						  )						  
						  
		return '''ACCESS
				  (
					{	  
						source      = '«getKeyword(0) +  access.name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						schema = [«args»],
						options =[«options»]
					 }
				   )'''
	}		
	
	def buildSenderOP(AccessFramework access) 
	{
		var wrapper     = access.wrapper
		var protocol    = access.protocol
		var transport   = access.transport
		var dataHandler = access.datahandler
						  
		var options 	= generateKeyValueString(
							access.keys,
							access.values,
							','
						  )						  
						  
		var str = '''SENDER
				  (
					{	  
						sink        = '«getKeyword(0) +  access.name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						options =[«options»]
					 }, _INPUT_
				   )'''	

		if(streamto.keySet.contains(access.name))
		{
			return str.replace("_INPUT_", streamto.get(access.name))
		}
		sinks.put(access.name, str);
		return ''
	}

	/**
	 * Builds a join operator with a given {@link ExpressionsModel} and list of {@link Source}
	 * elements. If the predicate is null, there will be no join predicate in the operation.
	 * If the list contains only one source, an {@link IllegalArgumentException} will be thrown.
	 */
	def CharSequence buildJoin(ExpressionsModel predicate, List<Source> srcs)
	{
		if(srcs.size < 2)
		{ 
			throw new IllegalArgumentException(
				"Invalid number of source elements: There have to be at least two elements"
			)
		}
		var List<Source> list = srcs
		var src = list.get(0)
		if(list.size == 2)
		{
			return '''JOIN(«buildWindowOP(list.get(0))»,«buildWindowOP(list.get(1))»)'''
		}
		list.remove(0)
		if(predicate != null)
		{
			var predicateString = '''{predicate='«buildPredicate(predicate.elements.get(0))»'}'''
			return '''JOIN(«predicateString»,«buildWindowOP(src)»,«buildJoin(null, list)»)'''
		}
		else { return '''JOIN(«buildWindowOP(src)»,«buildJoin(null, list)»)''' } 	
	}

	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a list of {@link Source} elements. If the list contains more then one element,
	 * the {@link CQLGenerator#buildJoin(..)} method will be called to define the input
	 * operator.
	 */
	def CharSequence buildSelectOP(ExpressionsModel predicate, List<Source> srcs)
	{
		if(srcs.size == 1)
			return '''SELECT({predicate='«buildPredicate(predicate.elements.get(0))»'},«srcs.get(0).name»)'''
		return '''SELECT({predicate='«buildPredicate(predicate.elements.get(0))»'},«buildJoin(null, srcs)»)'''
	}

	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a char sequence to define the input operator. 
	 */
	def CharSequence buildSelectOP(ExpressionsModel predicate, CharSequence operator)
	{
		return '''SELECT({predicate='«buildPredicate(predicate.elements.get(0))»'},«operator»)'''
	}

	/**
	 * Builds a project operator with a list of {@link Attribute} and {@link Source}
	 * element. If the list is null, all attributes to the corresponding source will be
	 * added to the attributes parameter.
	 */
	def CharSequence buildProjectOP(List<Attribute> attributes, Source src)
	{
		if(src == null) { throw new NullPointerException("Given source was null") }
		
		if(attributes == null)
		{
			return '''PROJECT(
						{
							attributes=[«generateListString(getAttributeNamesFrom(src.name))»]
						},«buildWindowOP(src)»)'''
		}
		return '''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|e.name).collect(Collectors.toList))»]
				  	},«buildWindowOP(src)»)'''
	}
	
	/**
	 * Builds a project operator with a list of {@link Attribute} and char sequence
	 * to define the input operator.
	 */
	def CharSequence buildProjectOP(List<Attribute> attributes, CharSequence operator)
	{
		return '''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|e.name).collect(Collectors.toList))»]
				  	},«operator»)'''
	}
	
	
	/**
	 * Builds a project operator with a list of {@link Attribute} and char sequence
	 * to define the input operator.
	 */
	def CharSequence buildProjectOP(String[] attributes, CharSequence operator)
	{
		return '''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes)»]
				  	},«operator»)'''
	}
	
	//TODO String have to be encupseld between '
	/**Builds a predicate string from a given {@link Expression}. */
	def CharSequence buildPredicate(Expression e)
	{
		if(!e.eContents.empty)
		{
			switch e
			{
				Or:
				{
					buildPredicate(e.left)
					predicate += '||'
					buildPredicate(e.right)
				}
				And:
				{
					buildPredicate(e.left)
					predicate += '&&'
					buildPredicate(e.right)
				}  
				Equality:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)
				}
				Comparision:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)	
				}
				Plus:
				{
					buildPredicate(e.left)
					predicate += '+'
					buildPredicate(e.right)
				}
				Minus:
				{
					buildPredicate(e.left)
					predicate += '-'
					buildPredicate(e.right)					
				}
				MulOrDiv:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)
				}
				NOT:
				{
					predicate += '!'
					buildPredicate(e.expression)
				}
				Bracket:
				{
					predicate += '(' 
					buildPredicate(e.inner)
					predicate += ')' 
				}
				AttributeRef:
				{
					predicate += e.value.name
				}  	 
			}
		} 
		else
		{
			var str = ''
			switch e
			{
				IntConstant: 	str = e.value + ''
				FloatConstant:  str = e.value
				StringConstant: str = "'" + e.value + "'"
				BoolConstant: 	str = e.value
	
			}
			predicate += str
		}
	}
	
	def CharSequence buildWindowOP(Source src)
	{
		if(src.time != null)
		{
			return '''TIMEWINDOW
					  (
					  	{
					  		size = [«src.time.size»,'«src.time.unit»']
						},
						«src.name»
					 )'''
		}
		else if(src.tuple != null)
		{
			var var1 = if(src.tuple.advance_size != 0) src.tuple.advance_size else 1
			if(src.tuple.partition_attribute == null)
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»
						   	},
						   	«src.name»
						   )'''

			}
			else
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»,
								partition = '«src.tuple.partition_attribute.name»'
						   	},
						   	«src.name»
						   )'''
			}			
		}
		else { return src.name }
	}

	/**
	 * TODO Write documentation! 
	 */
	def String generateKeyValueString(String ... s)
	{
		var str = "["
		for(var i = 0; i < s.length - 2; i++)
			str += "'" + s.get(i) + "'" + s.get(s.length - 1)			
		return str += "'" + s.get(s.length - 2) + "']"
	}
		
	def String generateKeyValueString(List<String> l1, List<String> l2, String s)
	{
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)// OUT of bounds...
		{
			str += generateKeyValueString(l1.get(i), l2.get(i), s) + ","
		}
		return (str += generateKeyValueString(l1.get(l1.size - 1), l2.get(l1.size - 1), s))
	}
	
	def String generateKeyValueString(String s, List<String> ... l1)
	{
		var str = ''
		for(var i = 0; i < l1.size; i++)
		{
			if(i != l1.size - 1)
			{
				for(var j = 0; j < l1.get(i).size; j++)
				{
					str += generateKeyValueString(l1.get(i).get(j), s) + ","
				}
			}
			else
			{
				for(var j = 0; j < l1.get(i).size - 1; j++)
					str += generateKeyValueString(l1.get(i).get(j), s) + ","
				str += generateKeyValueString(l1.get(i).get(l1.get(i).size - 1), s)
			}
		}
		return str
	}
	
	def String generateKeyValueString(String s1, List<String> l2, String s2)
	{
		var str = ''
		for(var i = 0; i < l2.size - 1; i++)
		{
			str += generateKeyValueString(s1, l2.get(i), s2) + ","
		}
		return (str += generateKeyValueString(s1, l2.get(l2.size - 1), s2))
	}
	
	def String generateListString(String s1)
	{
		return "'" + s1 + "'"
	}
		
	def String generateListString(List<String> l1)
	{
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)
		{
			str += generateListString(l1.get(i)) + ","
		}
		return (str += generateListString(l1.get(l1.size - 1)))
	}
		
	def CharSequence buildSchema(List<Attribute> attr, Source src)
	{
		var str = ''
		for(a : innerattributes)
			if(a.sourceName.equals(src.name))
				str += generateKeyValueString(a.attributeName, a.datatype.toString, ',') + ","
		return (str = str.substring(0, str.length - 2))
	}
	
	def CharSequence getID()
	{
		count_ID++
		return count_ID.toString
	}
	
	def void clear()
	{
		outerattributes.clear()
		innerattributes.clear()
		count_ID = 0
		sinks.clear()
		streamto.clear()
	}

	def void setOuterschema(Set<SDFSchema> s)
	{
		outerschema = s
		for(SDFSchema t : s)
		{
			outerattributes.addAll(t.attributes)
		}
	}

	def void setInnerschema(Set<SDFSchema> s)
	{
		innerschema = s
		for(SDFSchema t : s)
		{
			innerattributes.addAll(t.attributes)
		}
	}
	
	val static CharSequence[] keywords = #['input_', 'window_', 'output_', 'select_']
	def static CharSequence getKeyword(int i)
	{
		if(i >= keywords.length || i < 0)
			return 'WRONG_INDEX_NO_KEYWORD'
		return keywords.get(i);
	}
	
	/** Returns all {@link Attribute} elements to the corresponding source. */
	def getAttributeNamesFrom(String src) 
	{
		/*
		 * A source is either from outerattributes» or from innerattributes.
		 * Hence, there should be no duplicated entries while iterating 
		 * through both lists.
		 */
		var List<String> l = new ArrayList 
		for(SDFAttribute a : outerattributes)
			if(a.sourceName.equals(src))
				l.add(a.attributeName)
		for(SDFAttribute a : innerattributes)
			if(a.sourceName.equals(src))
				l.add(a.attributeName)
		return l
	}
	
}