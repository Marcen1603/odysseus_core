/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.generator

import de.uniol.inf.is.odysseus.core.sdf.schema.SDFAttribute
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Aggregation
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.And
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeRef
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeWithNestedStatement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateParameters
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateSink1
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStream1
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStreamChannel
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStreamFile
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateView
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.DataType
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Expression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionsModel
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Or
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Select
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StreamTo
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant
import java.util.ArrayList
import java.util.Arrays
import java.util.Collection
import java.util.HashMap
import java.util.List
import java.util.Map
import java.util.Map.Entry
import java.util.Set
import java.util.stream.Collectors
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGenerator2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.Collections

//import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Create

//TODO Documentation
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CQLGenerator implements IGenerator2
{

	var Map<String, String> sinks = new HashMap	
	var Map<String, String> streamto = new HashMap	
	var count_ID = 0
	var predicate = ''
	var List<String> definitions = newArrayList
	var Map<String, String> operators = newHashMap
	var List<String> aggregationAttributes = newArrayList
	var Map<String, List<String>> nSelect = newHashMap
	var Map<String, List<String>> attributeAliases = newHashMap
	var List<SourceStruct> sources = newArrayList
	var List<String> sourcenames = newArrayList
	
	val String OP     = "operator_"
	val String VIEW   = "view_" 
	val String ASSIG1 = " = "
	val String ASSIG2 = " := "

	def void clear()
	{
		sinks.clear()
		streamto.clear()
		count_ID = 0
		predicate = ''
		definitions.clear()
		operators.clear()
		aggregationAttributes.clear()
		nSelect.clear()
		attributeAliases.clear()
		sources.clear()
		sourcenames.clear()
//		outerattributes.clear()
//		innerattributes.clear()
//		aAliases.clear()
//		sAliases.clear()
//		attributes.clear()
//		model = ''
	}

	static class AttributeStruct
	{
		String attributename;
		String sourcename;
		String datatype;
		List<String> aliases;
		
		override equals(Object obj) 
		{
			if(obj instanceof AttributeStruct)
				if(this.attributename.equals((obj as AttributeStruct).attributename)
					&& this.sourcename.equals((obj as AttributeStruct).sourcename)
					&& this.datatype.equals((obj as AttributeStruct).datatype)
					&& this.aliases.equals((obj as AttributeStruct).aliases)
				)
					return true
			return false
		}
		
		override hashCode() {
			return 0
		}
		
		override toString() 
		{
			return "attributename " + attributename
			+ "\n sourcename " + sourcename 
			+ "\n datatype " + datatype 	
			+ "\n aliases " + aliases.toString
		}
		
	}

	static class SourceStruct
	{
		String sourcename;
		List<AttributeStruct> attributes;
		List<String> aliases;
		boolean internal;
		
		def addRenamedAttributes(List<String> list)
		{
			var newStructs = newArrayList
			for(AttributeStruct struct : attributes)
				for(var i = 1; i < list.size; i++)
				{
					if(i % 2 == 1)
					{
						var name = list.get(i).split("\\.").get(1)
						var newStruct = new AttributeStruct()
						newStruct.attributename = name
						newStruct.datatype = struct.datatype
						newStruct.sourcename = struct.sourcename	
						newStruct.aliases = newArrayList
						newStructs.add(newStruct)
					}
				}
			attributes.addAll(newStructs)
		}
		
		override equals(Object obj) 
		{
			if (obj instanceof SourceStruct)
				if(this.sourcename.equals((obj as SourceStruct).sourcename)
					&& this.attributes.equals((obj as SourceStruct).attributes)
					&& this.aliases.equals((obj as SourceStruct).aliases)
					&& this.internal.equals((obj as SourceStruct).internal)
				  )	
					return true			
			return false
		}
		
		override hashCode() {
			return 0
		}
	}
	
	def List<AttributeStruct> getAttributes()
	{
		var list = newArrayList
		for(SourceStruct source : sources)
			list.addAll(source.attributes)
		return list
	}

	def Map<AttributeStruct, List<String>> getAttributeAliases()
	{
		var map = newHashMap
		for(SourceStruct source : sources)
			for(AttributeStruct attribute : source.attributes)
				if(!attribute.aliases.empty)
				map.put(attribute, attribute.aliases)
		return map
	} 

	def List<String> getAttributeAliasesAsList()
	{
		var list = newArrayList
		for(SourceStruct source : sources)
			for(AttributeStruct attribute : source.attributes)
				list.addAll(attribute.aliases)
		return list
	} 

	def Map<SourceStruct, List<String>> getSourceAliases()
	{
		var map = newHashMap
		for(SourceStruct source : sources)
				map.put(source, source.aliases)
		return map
	} 

	override afterGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context)  {}
	override beforeGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		var i = 0 ;
		for(e : resource.allContents.toIterable.filter(typeof(Statement)))
		{
			fsa.generateFile(
				""+ i++,	
				e.parseStatement()
			)
		}
	}
	
	def CharSequence parseStatement(Statement stmt)
	{
		switch stmt.type
		{
			CreateView			: parseCreateView(stmt.type as CreateView)
			CreateStream1  		: parseCreateStream1(stmt.type as CreateStream1)
			CreateSink1         : parseCreateSink1(stmt.type as CreateSink1)
			CreateStreamChannel : parseCreateStreamChannel(stmt.type as CreateStreamChannel)
			CreateStreamFile    : parseCreateStreamFile(stmt.type as CreateStreamFile)
			StreamTo		 	: parseStreamtoStatement(stmt.type as StreamTo)
			Select 		   		: parseSelect(stmt.type as Select)
		}
		
		//Build model
		var model = ''
		for(Entry<SourceStruct, List<String>> entry : getSourceAliases.entrySet)
		{
			for(String alias : entry.value)
				 model += alias + ASSIG1 + entry.key.sourcename + '\n'
		}
		for(var i = 0; i < definitions.size; i++)
		{
			if(!definitions.get(i).contains(OP))
				model +=  definitions.get(i) + ASSIG2 + operators.get(definitions.get(i)) + '\n'
			else
				model +=  definitions.get(i) + ASSIG1 + operators.get(definitions.get(i)) + '\n'
			for(Entry<String, List<String>> entry : nSelect.entrySet)
			{
				if(entry.key.equals(definitions.get(i)))
				{
					var l = entry.value
					for(String alias : l)
						model += alias + ASSIG1 + entry.key + '\n'
				} 	
			}
		}

		if(!getAttributeAliases.empty)
		{
			var String[] lines = model.split(System.getProperty("line.separator"));
			var lastline = lines.get(lines.length - 1)
			var String[] parts 
			if(lastline.contains(ASSIG1))
				parts = lastline.split(ASSIG1)
			else
				parts = lastline.split(ASSIG2)
			model += buildRenameOperator(parts.get(0))
		}		
		
		return model
	}
	
	def String registerOperator(String operator)
	{
		return registerOperator(operator, OP + getID())
	}
	
	def String registerOperator(String operator, String definition)
	{
		definitions.add(definition.toString)
		operators.put(definition, operator)
		return definition
	}
	
	//TODO refactore
	def registerAlias(Source src)
	{
		var name  = src.name
		var alias = src.alias
		if(alias != null && name != null)
		{
			for(SourceStruct source : sources)
			{
				if(source.sourcename.equals(name))
				{
					source.aliases.add(alias.name)					
				}
			}
		}
		
//		var name  = src.name
//		var alias = src.alias
//		if(alias != null && name != null)
//		{
//			var aliasname = alias.name
//			if(sAliases.containsKey(name))
//			{
//				if(!sAliases.containsValue(aliasname))
//				{
//					var aliases = sAliases.get(name)
//					aliases.add(aliasname)
//					sAliases.put(name, aliases)
//				}
//			}
//			else
//			{
//				var aliases = newArrayList
//				aliases.add(aliasname)
//				sAliases.put(name, aliases)
//			}
//		}
	}
	
	//TODO refactore
	def registerAlias(Attribute attr)
	{
		if(attr != null)
		{
			var name  = attr.name
			var alias = attr.alias
			if(alias != null && name != null)
			{
				for(SourceStruct source : sources)
					for(AttributeStruct attribute : source.attributes)
						if(attribute.attributename.equals(attr.name))
							attribute.aliases.add(alias.name)
			}
		}
		
		
//		if(attr != null)
//		{
//			var name  = attr.name
//			var alias = attr.alias
//			if(alias != null && name != null)
//			{
//				var aliasname = alias.name
//				if(aAliases.containsKey(name))
//				{
//					if(!aAliases.containsValue(aliasname))
//					{
//						var aliases = aAliases.get(name)
//						aliases.add(aliasname)
//						aAliases.put(name, aliases)
//					}
//				}
//				else
//				{
//					var aliases = newArrayList
//					aliases.add(aliasname)
//					aAliases.put(name, aliases)
//				}
//			}
//		}
	}
	
	def checkForAmbiguousAttributes(List<Source> srcs, List<Attribute> attrs)
	{
//		var list1 = newArrayList
//		var list2 = newArrayList
//		for(SourceStruct src1 : sources)
//			for(Source src2 : srcs)
//				if(src1.sourcename.equals(src2.name))
//					if(!list2.contains(src2.name))
//					{
//						var attributenames1 = src1.attributes.stream.map(
//							e|getSimpleAttributename(e.attributename)
//						).collect(Collectors.toList)
//						var attributenames2 = src1.attributes.stream.map(
//							e|e.attributename
//						).collect(Collectors.toList)
//						
//						for(String name1 : attributenames1)
//							for(String name2 : attributenames2)
//								if(name1.equals(name2))
//									list1.add(name1)
//						
//						var Set<String> set = newHashSet(list1)
//						if(set.size() < list1.size())
//						{
//							throw new AmbiguousAttributeException(
//								"ambiguous attribute definition: rename attributes in source "+ src2.name
//							)
//						}
//					}	
						///
//						list2.add(src2.name)
//						for(String name1 : attrs.stream.map(e|e.attributename).collect(Collectors.toList))
//							for(String name2 : src1.attributes.stream.map(e|e.attributename).collect(Collectors.toList))
//							{
//								var str = getAttributename(name1).split("\\.").get(1)// ..
//								if(str.equals(name2))
//									list1.add(name2)
//							}							
//						var Set<String> set = newHashSet(list1)
//						if(set.size() < list1.size())
//						{
//							throw new AmbiguousAttributeException(
//								"ambiguous attribute definition: rename attributes in source "+ src2.name
//							)
//						}
//					}
	}
	
	def checkExistingSources(List<Source> sources)
	{
//		var list1 =  sources.stream.map(e|e.name).collect(Collectors.toList)
//		var list2 =  this.sources.stream.map(e|e.sourcename).collect(Collectors.toList)
//		for(String name : list1)
//			if(!list2.contains(name))
//				throw new IllegalArgumentException(
//					"given source " + name + " is not contained by a known schema"
//				)
	}
	
	def getAllSourceFromSelect(Select select)
	{
//		var list1 = EcoreUtil2.getAllContentsOfType(select, Source)
//		var iter = list1.iterator
//		while(iter.hasNext())
//		{
//			var source = iter.next()
//			if(source.name == null)
//			{
//				iter.remove()
//				getAllSourceNames(source.nested)
//			}
//			
//		}
		
	}
	
	def parseSelect(Select stmt)
	{

		// Add source aliases
		for(Source source : stmt.sources)
			registerAlias(source)
			
		// Add attribute aliases
		for(Attribute attribute : stmt.attributes)
			registerAlias(attribute)	
		
		checkExistingSources(stmt.sources)//TODO Implement
		checkForAmbiguousAttributes(stmt.sources, stmt.attributes)//TODO Implement
		
		// Parse select	and register operators
		firstCall = true
		renamedAttributes.clear()
		var CharSequence result = ''
		if(null == stmt.predicates)
			result = parseSelectWithoutPredicate(stmt)
		else
			result = parseSelectWithPredicate(stmt)
		
		
	}
	
	private def CharSequence parseSelectWithoutPredicate(Select stmt)
	{
		if(!stmt.attributes.empty)//SELECT attr1, ...
			{
			    var String operator = null
			    var attributes = stmt.attributes.stream.map(e|e.name).collect(Collectors.toList)
				if(!stmt.aggregations.empty)
				{
					var result = buildAggregateOP(stmt.aggregations, stmt.order, stmt.sources)
					attributes = result.get(0) as List<String>
				    operator   = registerOperator(result.get(1).toString)
				
					//FIXME Not necessary, it has been done before!
					attributes.addAll(
						stmt.attributes.stream.map(e|e.name).collect(Collectors.toList)
					)
				}									
				var join = buildJoin(null, stmt.sources, operator)
				if(!renamedAttributes.empty)
				{
					for(Entry<String, List<String>> e : renamedAttributes.entrySet)
						for(SourceStruct source : this.sources)
							if(source.sourcename.equals(e.key))
							{
								source.addRenamedAttributes(e.value)
								var list = newArrayList
								for(var i = 1; i < e.value.size; i++)
									if(i % 2 == 1)
										attributes.add(e.value.get(i))
							}
				}
				var prj =  '''«buildProjectOP(attributes, join)»'''
//				generateAlias(stmt.sources)
				return prj
			}
			else//SELECT * ..
			{
				if(stmt.aggregations.empty)
				{
					if(stmt.sources.size == 1)
					{
						var prj = '''«buildProjectOP(stmt.sources.get(0))»'''
//						generateAlias(stmt.sources)
						return prj
					}
//					if(!renamedAttributes.empty)
//					{
//						for(Entry<String, List<String>> e : renamedAttributes.entrySet)
//							for(SourceStruct source : this.sources)
//								if(source.sourcename.equals(e.key))
//								{
//									source.addRenamedAttributes(e.value)
//									attributes.addAll(e.value)
//								}
//					}
					return registerOperator('''«buildJoin(stmt.sources)»''')
				}
				var operator = buildAggregateOP(stmt.aggregations, stmt.order, stmt.sources)
//				generateAlias(stmt.sources)
				return registerOperator('''«operator.get(1).toString»''')
			}
	}
	
	private def CharSequence parseSelectWithPredicate(Select stmt)
	{
		predicate = ''
	    var String operator = null
	    var List<String>     attributes = stmt.attributes.stream.map(e|e.name).collect(Collectors.toList)
		var List<Expression> predicates = newArrayList
		var List<Source>        sources = newArrayList
		
		////WOKRING PROGRESS remove duplicates!!
		predicates.add(0, stmt.predicates.elements.get(0))
		if(stmt.having != null)
			predicates.add(0, stmt.having.elements.get(0))
		sources.addAll(stmt.sources)
		if(!stmt.aggregations.empty)
		{
			var result = buildAggregateOP(stmt.aggregations, stmt.order, sources)
			attributes.addAll(result.get(0) as List<String>)
		    operator   = registerOperator(result.get(1).toString)
			//FIXME
			//Not necessary, it has been done before!
//			attributes.addAll(
//				stmt.attributes.stream.map(e|e.name).collect(Collectors.toList)
//			)
		}
		
		var nested = EcoreUtil2.eAllOfType(stmt, AttributeWithNestedStatement)
		if(!nested.empty)
		{//FIXME 
			for(var i = 0; i < nested.size; i++)
			{
				var a = nested.get(i).nested.attributes.stream.map(e|e.name).collect(Collectors.toSet)
				for(String s : a)
					if(!attributes.contains(s))
						attributes.add(s)
				var s = nested.get(i).nested.sources
				var names = newArrayList
				for(Source s1 : sources)
				{
					names.add(s1.name)
				}
				for(Source s2 : s)
				{
					if(!names.contains(s2.name))
						sources.add(s2)
				}	
//				for(Source c : s)
//					if(!sources.contains(c))
//						sources.add(c)
			}
		}
		
		var result = ''
		if(stmt.sources.size > 1 && !stmt.attributes.empty)// SELECT * FROM src1 / src1, .. src2 WHERE ...;
		{
			var join = buildJoin(null, sources, operator)
				if(!renamedAttributes.empty)
				{
					for(Entry<String, List<String>> e : renamedAttributes.entrySet)
						for(SourceStruct source : this.sources)
							if(source.sourcename.equals(e.key))
							{
								source.addRenamedAttributes(e.value)
								var list = newArrayList
								for(var i = 1; i < e.value.size; i++)
									if(i % 2 == 1)
										attributes.add(e.value.get(i))
							}
				}					
			var prj =  buildProjectOP(attributes, join)
			result = '''«buildSelectOP(predicates, prj)»'''	
			return result
		}// SELECT * FROM src1, src2, ... WHERE ...; | SELECT attr1, ... FROM src1 / src1, ... WHERE ...;
		if(stmt.attributes.empty)
		{
			var join = buildJoin(null, sources, operator)
				if(!renamedAttributes.empty)
				{
					for(Entry<String, List<String>> e : renamedAttributes.entrySet)
						for(SourceStruct source : this.sources)
							if(source.sourcename.equals(e.key))
							{
								source.addRenamedAttributes(e.value)
								var list = newArrayList
								for(var i = 1; i < e.value.size; i++)
									if(i % 2 == 1)
										attributes.add(e.value.get(i))
							}
				}
			result = '''«buildSelectOP(predicates, join)»'''
			return result
		}
		var join = buildJoin(null, sources, operator)
				if(!renamedAttributes.empty)
				{
					for(Entry<String, List<String>> e : renamedAttributes.entrySet)
						for(SourceStruct source : this.sources)
							if(source.sourcename.equals(e.key))
							{
								source.addRenamedAttributes(e.value)
								var list = newArrayList
								for(var i = 1; i < e.value.size; i++)
									if(i % 2 == 1)
										attributes.add(e.value.get(i))
							}
				}
		var prj = buildProjectOP(attributes, join)
		result = '''«buildSelectOP(predicates, prj)»'''
		return result
	}
	
	
	def CharSequence buildRenameOperator(CharSequence operator)//TODO Documentation
	{
		var list = newArrayList
		for(Entry<AttributeStruct, List<String>> l : getAttributeAliases.entrySet)
		{
			list.add(l.key.attributename)
			list.add(l.value.get(0))
		}
		var rename = '''renamed_«getID()» = RENAME({aliases=[«generateListString(list)»], pairs='true'}, «operator»)'''
		return rename
	}
	
	def CharSequence buildRenameOperator2(List<String> paired, String source)
	{
		return '''RENAME({aliases=[«generateListString(paired)»], pairs='true'}, «source»)'''
	}
	
	def registerSourceAlias(Source source)
	{
		if(source.alias != null && source.nested == null)
			registerOperator(source.name, source.alias.name)
	}
	
	def Object[] buildAggregateOP(List<Aggregation> list, List<Attribute> list2, List<Source> srcs)
	{
		return buildAggregateOP(list, list2, buildJoin(srcs))
	}
	
	def Object[] buildAggregateOP(List<Aggregation> list, List<Attribute> list2, Source src)
	{
		return buildAggregateOP(list, list2, checkForNestedStatement(src))
	}
	
	def Object[] buildAggregateOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, CharSequence input)
	{
		var argsstr 				 = ''
		var List<String> args    = newArrayList()
		var List<String> aliases = newArrayList()
		for(var i = 0; i < aggAttr.length; i++)
		{
			args.add(aggAttr.get(i).name)
			args.add(getAttributename(aggAttr.get(i).attribute.name))
			var alias = ''
			if(aggAttr.get(i).alias != null)
				alias= aggAttr.get(i).alias.name
			else
				alias = aggAttr.get(i).name + '_' + aggAttr.get(i).attribute.name
			args.add(alias)
			aliases.add(alias)
			args.add(getDataTypeFrom(aggAttr.get(i).attribute))
			aggregationAttributes.add(alias)
			args.add(',')
			argsstr += generateKeyValueString(args)
			if(i != aggAttr.length - 1) argsstr += ','
			args.clear
		}
		//Generates the group by argument that is formed like ['attr1', attr2', ...]
		var groupby = ''
		if(!orderAttr.empty)
		{
			groupby += ',GROUP_BY=['
			groupby += generateListString(
				orderAttr.stream.map(e|getAttributename(e.name)).collect(Collectors.toList)
			) + ']'
		}
		return #[aliases, '''AGGREGATE({AGGREGATIONS=[«argsstr»]«groupby»}, «input»)''']
	}
		
	def CharSequence parseCreateStream1(CreateStream1 create)
	{
		return registerOperator(buildCreate1("ACCESS", create.pars, create.attributes.attributes, create.attributes.datatypes, create.attributes.name).toString, create.attributes.name)
	}	
		
	def CharSequence parseCreateSink1(CreateSink1 sink) 
	{
		return registerOperator(buildCreate1("SENDER", sink.pars, sink.attributes.attributes, sink.attributes.datatypes, sink.attributes.name).toString, sink.attributes.name)
	}	
			
	def CharSequence buildCreate1(String type, CreateParameters pars, List<Attribute> attrs, List<DataType> dtypes, String name)
	{	
		var wrapper     = pars.wrapper
		var protocol    = pars.protocol
		var transport   = pars.transport
		var dataHandler = pars.datahandler
		var args 		= generateKeyValueString(
							attrs.map[e|e.name],
							dtypes.map[e|e.value],
							','
						  )
		var options 	= generateKeyValueString(
							pars.keys,
							pars.values,
							','
						  )		
		var t = ''
		var s = ''
		var b = false
		if(type.equals("ACCESS"))
		{
			t = 'source'
			s = '''schema = [«args»],'''	
		}
		else
		{
			b = true
			t = 'sink'	
		}				  
						  
		var sink = '''«type»
				  (
					{	  
						«t»      = '«name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						«s»
						options =[«options»]
					 }
					 «IF b»,__INPUT__«ENDIF»
				   )'''
	    if(b)
	    {
	     	sinks.put(name, sink);
	     	return''	
	    }
		return sink
	}	
		
	def CharSequence parseCreateStreamFile(CreateStreamFile file)
	{
		var schema = generateKeyValueString(
					file.attributes.attributes.map[e|e.name],
					file.attributes.datatypes.map[e|e.value],
					','
				  )
		
		var options = '''['filename','«file.filename»']'''		  
		return registerOperator(buildCreate2('GenericPush', file.type, 'File', 'Tuple', schema, options, file.attributes.name).toString, file.attributes.name)
	}
	
	def CharSequence parseCreateStreamChannel(CreateStreamChannel channel) 
	{
		var schema = generateKeyValueString(
			channel.attributes.attributes.map[e|e.name],
			channel.attributes.datatypes.map[e|e.value],
			','
		  )
		
		var options = '''['port','«channel.port»'],['host', '«channel.host»']'''		  
		return registerOperator(buildCreate2('GenericPush', 'SizeByteBuffer', 'NonBlockingTcp', 'Tuple', schema, options, channel.attributes.name).toString, channel.attributes.name)
	}	
	
	def CharSequence buildCreate2(String wrapper, String protocol, String transport, String dataHandler, String schema, String options, String name)
	{						  
		return '''ACCESS
				  (
					{	  
						source      = '«name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						schema = [«schema»],
						options =[«options»]
					 }
				   )'''
	}
		
	def CharSequence parseCreateView(CreateView view)
	{
		return registerOperator(parseSelect(view.select).toString, VIEW + getID())
	}
		
	def parseStreamtoStatement(StreamTo to)
	{
		if(to.statement != null)
		{
			streamto.put(to.name, parseSelect(to.statement).toString)
			
		}		
		else
		{
			streamto.put(to.name, to.inputname)
		}

		if(sinks.keySet.contains(to.name))
			return '''«sinks.get(to.name).replace("__INPUT__", streamto.get(to.name))»'''
		return ''
	}

	var joinCounter = 1
	var firstCall = true
	var Map<String, List<String>> renamedAttributes = newHashMap
	def String selfJoin(String scr1, String src2)
	{
		var source1 = scr1
		if(source1.equals(src2))
		{
			var paired = newArrayList
			var attributes = newArrayList
			for(String name : getAttributeNamesFrom(source1))
			{
				var attributename = source1 + "." + name + "_" + joinCounter.toString
				println("name: " + name)
				println("renamed: " + attributename)
				paired.add(name)
				paired.add(attributename)
				attributes.add(attributename)
			}
			renamedAttributes.put(source1, paired)			
			source1 = buildRenameOperator2(paired, source1).toString
			joinCounter++
		}
		return source1
	}
	
	def CharSequence buildJoin(ExpressionsModel predicate, String[] srcs)
	{
		var sourcenames = srcs
		if(firstCall)
			Collections.sort(sourcenames)
		firstCall = false
				
		if(sourcenames.size < 1)
		{ 
			throw new IllegalArgumentException(
				"Invalid number of source elements: There have to be at least two sources"
			)
		}
		if(sourcenames.size == 1)//Will only be considered if the first call of this method provides a single source
		{
			firstCall = true
			return sourcenames.get(0)
		}
		var List<String> list = new ArrayList(Arrays.asList(sourcenames))
		var source1 = list.get(0)
		var source2 = list.get(1)
		source1 = selfJoin(source1, source2)
		
		if(list.size == 2)
		{
			firstCall = true
			return '''JOIN(«source1»,«source2»)'''
		}
		list.remove(0)
		if(predicate != null)//TODO There will never be a predicate != null, hence it's obsolete
		{
			var predicateString = '''{predicate='«parsePredicate(predicate.elements.get(0))»'}'''
			return '''JOIN(«predicateString»,«source1»,«buildJoin(null, list)»)'''
		}
		else 
		{ 
			return '''JOIN(«source1»,«buildJoin(null, list)»)'''
		} 

	}

	def buildJoin(Collection<Source> scrs)
	{
		
		var args = scrs.stream.map(
			e|checkForNestedStatement(e).toString
		).collect(Collectors.toList)

		return buildJoin(null, args)
	}

	def CharSequence buildJoin(ExpressionsModel predicate, Collection<Source> srcs, CharSequence input2)
	{
		var args = srcs.stream.map(
			e|checkForNestedStatement(e).toString
		).collect(Collectors.toList)
		
		if(input2 != null)
			args.add(input2.toString)
		var join = buildJoin(predicate, args)
		return join
	}

	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a char sequence to define the input operator. 
	 */
	def CharSequence buildSelectOP(Expression predicate, CharSequence operator)
	{
		predicate = ''
		var result = '''SELECT({predicate='«parsePredicate(predicate)»'},«operator»)'''
		return registerOperator(result)
	}
	
	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a char sequence to define the input operator. 
	 */
	def CharSequence buildSelectOP(List<Expression> predicate, CharSequence operator)
	{
		predicate = ''
		return registerOperator('''SELECT({predicate='«parsePredicate(predicate)»'},«operator»)''')
	}
	
	def CharSequence buildProjectOP(String[] attributes, CharSequence operator)
	{
		return registerOperator('''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|getAttributename(e)).collect(Collectors.toList))»]
				  	},«operator»)''')
	}
	
	def CharSequence buildProjectOP(Source src)
	{
		return buildProjectOP(#[] as String[], src)
	}
	
	def CharSequence buildProjectOP(String[] attributes, Source src)
	{
		if(src == null) { throw new NullPointerException("Given source was null") }
		
		if(attributes.empty)
		{
			return registerOperator('''PROJECT(
						{
							attributes=[«generateListString(getAttributeNamesFrom(src.name).stream.map(e|getAttributename(e)).collect(Collectors.toList))»]
						},«checkForNestedStatement(src)»)''')
		}
		return registerOperator('''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|getAttributename(e)).collect(Collectors.toList))»]
				  	},«checkForNestedStatement(src)»)''')
	}
	
	//TODO String have to be encupseld between '
	/**Builds a predicate string from a given {@link Expression}. */
	def CharSequence parsePredicate(Expression e)
	{
		if(!e.eContents.empty)
		{
			switch e
			{
				Or:
				{
					parsePredicate(e.left)
					predicate += '||'
					parsePredicate(e.right)
				}
				And:
				{
					parsePredicate(e.left)
					predicate += '&&'
					parsePredicate(e.right)
				}  
				Equality:
				{
					parsePredicate(e.left)
					predicate += e.op
					parsePredicate(e.right)
				}
				Comparision:
				{
					parsePredicate(e.left)
					predicate += e.op
					parsePredicate(e.right)	
				}
				Plus:
				{
					parsePredicate(e.left)
					predicate += '+'
					parsePredicate(e.right)
				}
				Minus:
				{
					parsePredicate(e.left)
					predicate += '-'
					parsePredicate(e.right)					
				}
				MulOrDiv:
				{
					parsePredicate(e.left)
					predicate += e.op
					parsePredicate(e.right)
				}
				NOT:
				{
					predicate += '!'
					parsePredicate(e.expression)
				}
				Bracket:
				{
					predicate += '(' 
					parsePredicate(e.inner)
					predicate += ')' 
				}
				AttributeRef:
				{
					/*
					 * 
					 * attr1 > 10 AND attr1 IN (SELECT attr1 FROM s1 WHERE attr1 != 10) AND attr2 IN (... )
					 * 
					 * AttributeRef := (attr1 IN (SELECT attr1 FROM s1 WHERE attr1 != 10))
					 * 
					 * 
					 */
					if(e.value instanceof AttributeWithNestedStatement)
					{
						parseNestedPredicate((e.value as AttributeWithNestedStatement).nested)
//						for(Source source : (e.value as AttributeWithNestedStatement).nested.sources)
//						{
//							
//						}
					} 
					else
					{
						if(e.value instanceof Attribute)
							predicate += getAttributename(e.value as Attribute)
					}
				}  	 
			}
		} 
		else
		{
			var str = ''
			switch e
			{
				IntConstant: 	str = e.value + ''
				FloatConstant:  str = e.value
				StringConstant: str = "'" + e.value + "'"
				BoolConstant: 	str = e.value
	
			}
			predicate += str
		}
//		println(predicate)
		return predicate
	}
	
	def private CharSequence parseNestedPredicate(Select select)
	{
		var pred = select.predicates
		if(pred == null)
		{
			for(Source s : checkForNestedStatement(select.sources))
			{
				var p = s.nested.predicates
				if(p != null)
				{				
					predicate += parsePredicate(s.nested.predicates.elements.get(0))
				}
			 }
			return predicate
		}
		else
		{
			return parsePredicate(pred.elements.get(0))
		}
	}
	
	def CharSequence parsePredicate(List<Expression> expressions)
	{
		var s = ''
		for(var i = 0 ; i < expressions.size - 1; i++)
		{
			if(expressions.get(i) instanceof AttributeRef)
			{
				if((expressions.get(i) as AttributeRef).value instanceof AttributeWithNestedStatement)
				{
					// ignore it!
				}
			}
			else
			{
				predicate = ''
				var result = parsePredicate(expressions.get(i))
//				if(result.equals(''))
//					s+= result
//				else
					s +=  result + '&&'
			}
		}
		predicate = ''
		s += parsePredicate(expressions.get(expressions.size - 1))
		return s
	}
		
	//TODO Register nested queries	
	def CharSequence checkForNestedStatement(Source src)
	{
		
		if(src.nested != null)
		{
			var nested = parseSelect(src.nested)
			var alias = src.alias.name
			registerNestedSelect(nested.toString, alias)
//			registerOperator(alias, nested.toString)			
			return alias
		}
		else
		{
//			registerAlias(src)
//			if(src.alias != null)
//			{
//				registerOperator(src.alias.name, src.name)
//				definitions.add(src.alias.name.toString)
//				operators.put(src.alias.name, src.name)	
//			}
			return buildWindowOP(src)
		}
	}

	def List<Source> checkForNestedStatement(List<Source> srcs)
	{
		var List<Source> l = newArrayList
		for(Source s : srcs)
			if(s.nested != null)
				l.add(s)
				
		return l
	}

	def CharSequence buildWindowOP(Source src)
	{
		if(src.time != null)
		{
			var var1 = if(src.time.advance_size != 0) src.time.advance_size else 1
			var var2 = if(src.time.advance_size != 0) src.time.advance_unit else src.time.unit
			return '''TIMEWINDOW
					  (
					  	{
					  		size = [«src.time.size»,'«src.time.unit»'],
					  		advance = [«var1»,'«var2»']
						},
						«src.name»
					 )'''			 
		}
		else if(src.tuple != null)
		{
			var var1 = if(src.tuple.advance_size != 0) src.tuple.advance_size else 1
			if(src.tuple.partition_attribute == null)
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»
						   	},
						   	«src.name»
						   )'''

			}
			else
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»,
								partition = '«src.tuple.partition_attribute.name»'
						   	},
						   	«src.name»
						   )'''
			}			
		}
		else 
		{ 
			return src.name
		}
		
	}

	def String generateKeyValueString(String ... s)
	{
		var str = "["
		if(s.length == 1) 
			return str += "'" + s.get(0) + "']"
		for(var i = 0; i < s.length - 2; i++)
			str += "'" + s.get(i) + "'" + s.get(s.length - 1)			
		return str += "'" + s.get(s.length - 2) + "']"
	}
		
	def String generateKeyValueString(List<String> l1, List<String> l2, String s)
	{
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)// OUT of bounds...
		{
			str += generateKeyValueString(l1.get(i), l2.get(i), s) + ","
		}
		return (str += generateKeyValueString(l1.get(l1.size - 1), l2.get(l1.size - 1), s))
	}
	
	def String generateKeyValueString(String s1, List<String> l2, String s2)
	{
		var str = ''
		for(var i = 0; i < l2.size - 1; i++)
		{
			str += generateKeyValueString(s1, l2.get(i), s2) + ","
		}
		return (str += generateKeyValueString(s1, l2.get(l2.size - 1), s2))
	}
	
	def String generateListString(String s1)
	{
		return "'" + s1 + "'"
	}
		
	def String generateListString(List<String> l1)
	{
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)
		{
			str += generateListString(l1.get(i)) + ","
		}
		return (str += generateListString(l1.get(l1.size - 1)))
	}
	
//	@Deprecated	
//	def CharSequence buildSchema(List<Attribute> attr, Source src)
//	{
//		var str = ''
//		for(a : innerattributes)
//			if(a.sourceName.equals(src.name))
//				str += generateKeyValueString(a.attributeName, a.datatype.toString, ',') + ","
//		return (str = str.substring(0, str.length - 2))
//	}
	
	def CharSequence getID()
	{
		count_ID++
		return count_ID.toString
	}

	def void registerSources(Set<SDFSchema> schema, boolean internal)
	{
		for(SDFSchema s : schema)
		{
			for(String sourcename : s.baseSourceNames)
			{
				var source = new SourceStruct()
				source.internal = false
				source.sourcename = sourcename
				source.attributes = newArrayList()
				source.aliases = newArrayList()
				for(SDFAttribute attributename : s.attributes)
					if(sourcename.equals(attributename.sourceName))
					{
						var attribute = new AttributeStruct()
						attribute.attributename = attributename.attributeName 
						attribute.sourcename = sourcename
						attribute.datatype = attributename.datatype.toString	
						attribute.aliases = newArrayList()					
						source.attributes.add(attribute)
					}						
				sources.add(source)
			}
		}
	}

	def void setOuterschema(Set<SDFSchema> schema)
	{
		registerSources(schema, false)
//		for(SDFSchema t : s)
//			for(SDFAttribute a : t.attributes)
//			{	
//				
//				
//				if(!sourcenames.contains(a.sourceName))		
//					sourcenames.add(a.sourceName)		
//				outerattributes.add(a)
//				attributes.add(a.attributeName)
//			}			
	}

	def void setInnerschema(Set<SDFSchema> schema)
	{
		registerSources(schema, true)
//		for(SDFSchema t : s)
//			for(SDFAttribute a : t.attributes)
//			{
//				if(!sourcenames.contains(a.sourceName))		
//					sourcenames.add(a.sourceName)		
//				innerattributes.add(a)
//				attributes.add(a.attributeName)//TODO HERE! 
//			}		
	}

	def registerNestedSelect(String name, String alias)
	{
		if(nSelect.containsKey(name))
		{
			if(!nSelect.containsValue(alias))
			{
				var aliases = nSelect.get(name)
				aliases.add(alias)
				nSelect.put(name, aliases)
			}
		}
		else
		{
			var aliases = newArrayList
			aliases.add(alias)
			nSelect.put(name, aliases)
		}
	}
	
	def String getDataTypeFrom(Attribute attribute) 
	{
		if(attribute == null) throw new NullPointerException("given attribute was null")
		
		var attributename = attribute.name
		if(attribute.name.contains("."))
		{
			println("HE")
			var String[] name = attribute.name.split("\\.")
			if(attributeAliasesAsList.contains(name.get(1)))
				attributename = getAttributenameFromAlias(name.get(1))	
			else 
				attributename = name.get(1)
			println(attributename)			
		}
		else
			if(attributeAliasesAsList.contains(attribute.name))
				attributename = getAttributenameFromAlias(attribute.name)
		
		println(getAttributes().stream.map(e|e.attributename).collect(Collectors.toList))
		for(AttributeStruct attr : getAttributes())
			if(attr.attributename.equals(attributename))
				return attr.datatype		
					
//		for(SDFAttribute a : innerattributes)
//			if(a.attributeName.equals(attribute.name))
//				return a.datatype.toString
//		//TODO Is this still in use? ...
//		for(SDFAttribute a : outerattributes)
//			if(a.attributeName.equals(attribute.name))
//				return a.datatype.toString
		throw new IllegalArgumentException("given attribute " + attribute.name + "unknown")		
	}
	
	def String getSourcenameFromAlias(String sourcealias)
	{
		//println("XCX " + sAliases)
			
		for(Entry<SourceStruct, List<String>> source : getSourceAliases().entrySet)
			if(source.value.contains(sourcealias))
				return source.key.sourcename
			
//		for(Entry<String, List<String>> entry : sAliases.entrySet)
//			for(String alias : entry.value)
//				if(alias.equals(sourcealias))
//					return entry.key
					
		throw new IllegalArgumentException("given alias " + sourcealias + " is invalid: no corresponding source found")									
	}
	
	def String getAttributenameFromAlias(String attributealias)
	{
		for(Entry<AttributeStruct, List<String>> entry : getAttributeAliases.entrySet)
			for(String alias : entry.value)
				if(alias.equals(attributealias))
					return entry.key.attributename
					
		throw new IllegalArgumentException("given alias " + attributealias + " is invalid: no corresponding attribute found")									
	}
	
	def String getAttributename(String attribute)
	{
		if(attribute.contains("."))
		{
			/*
			 * Hint a simple . as regex won't work, because 
			 * it's the metacharacter for 'match all'. Hence
			 * \\. is used instead.
			 */
			var String[] name = attribute.split('\\.')
			println("attribute: " + attribute)
			println(name.toString)
			if(name != null && name.length == 2)
			{
				var attributes = getAttributes().stream.map(e|e.attributename).collect(Collectors.toList)
				var sources = getAttributes().stream.map(e|e.sourcename).collect(Collectors.toList)
				if(sources.contains(name.get(0)))
					if(attributes.contains(name.get(1)))
						return attribute
					else
						return name.get(0) + '.' + getAttributenameFromAlias(name.get(1))
				else
					if(attributes.contains(name.get(1)))
						return getSourcenameFromAlias(name.get(0)) + '.' + name.get(1)
					else//Attributes are not necessary contained by aAliases	
						return getSourcenameFromAlias(name.get(0)) + '.' + getAttributenameFromAlias(name.get(1))
			}
			throw new IllegalArgumentException("attribute " + attribute + " could not be resolved" )
		}
		
		println(attribute)
		//TODO refactore
		var String name = attribute
		for(List<String> l : getAttributeAliases.values)
			if(l.contains(attribute))
				name = getAttributenameFromAlias(attribute)
		
		for(AttributeStruct attr : getAttributes)
			if(attr.attributename.equals(name))
				return attr.sourcename + '.' + attr.attributename
				
//		for(SDFAttribute a : innerattributes)
//			if(a.attributeName.equals(name))
//				return a.sourceName + '.' + a.attributeName
//		for(SDFAttribute a : outerattributes)
//			if(a.attributeName.equals(name))
//				return a.sourceName + '.' + a.attributeName

		if(aggregationAttributes.contains(attribute))
			return attribute		
				
		throw new IllegalArgumentException("attribute " + attribute + " could not be resolved" )		
	}
	
	def String getAttributename(Attribute attribute)
	{
		return getAttributename(attribute.name)
	}
	
	def String getSimpleAttributename(String attribute)
	{
		var name = ''	
		if(attribute.contains("."))
			name = attribute.split("\\.").get(1)
			
		if(attributeAliasesAsList.contains(name))
			return getAttributenameFromAlias(attribute)
		return name		
	}
	
	
	
	/** Returns all {@link Attribute} elements to the corresponding source. */
	def getAttributeNamesFrom(String srcname) 
	{
		/*
		 * A source is either from outerattributes» or from innerattributes.
		 * Hence, there should be no duplicated entries while iterating 
		 * through both lists.
		 */
		 
		 //FIXME srcname can be an alias, therefore no attributes will be found!
//		var List<String> l = new ArrayList 
		 
//		 attributes.addAll(outerattributes)
//		 attributes.addAll(innerattributes)
//		for(SDFAttribute attr : attributes)
//			if(attr.sourceName.equals(srcname))
//				l.add(attr.attributeName)
		
		for(SourceStruct source : sources)
			if(source.sourcename.equals(srcname))
				return source.attributes.stream.map(e|e.attributename).collect(Collectors.toList)
		
//		for(SDFAttribute a : outerattributes)
//			if(a.sourceName.equals(srcname))
//				l.add(getAttributename(a.attributeName))
//				
//		for(SDFAttribute a : innerattributes)
//			if(a.sourceName.equals(srcname))
//				l.add(getAttributename(a.attributeName))
//		return l
	}
	
	
	/* Builds an AggregationOP -> was replaced by buildAggregateOP(..)
	def Object[] buildAggregationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, CharSequence input) 
	{
		//Produces a string array with strings like 'FUNCTION' = 'COUNT' 
		var functions = generateKeyValueString(
			'FUNCTION',
			aggAttr.stream.map(e|e.name).collect(Collectors.toList),
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		//Produces a string array with strings like 'INPUT_ATTRIBUTES' = 'attr1'
		var input_attr = generateKeyValueString(
			'INPUT_ATTRIBUTES',
			aggAttr.stream.map(e|e.attribute.name).collect(Collectors.toList),
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		
		//Creates a list with aliases from the given argument and adds missing aliases
		var List<String> aliases = newArrayList()
		for(var i = 0; i < aggAttr.length; i++)
		{
			if(aggAttr.get(i).alias != null)
				aliases.add(aggAttr.get(i).alias.name)
			else
				aliases.add(aggAttr.get(i).name + '_' + aggAttr.get(i).attribute.name)
		}
		//Produces a string array with strings like 'OUTPUT_ATTRIBUTES' = 'COUNT_attr1'
		//or with a corresponding alias for the attribute
		var output_attr = generateKeyValueString(
			'OUTPUT_ATTRIBUTES',
			aliases,
			'='
		).split(',').stream.map(e|e.replace("[","").replace("]", "")).collect(Collectors.toList)
		
		var List<String> lll = newArrayList()
		for(var i = 0; i < functions.size; i++)
		{
			lll.add(functions.get(i) + ',' + input_attr.get(i))
		}
		//Generates the finally argument string that is formed like 
		// ['FUNCTION' = 'COUNT', 'INPUT_ATTRIBUTES' = 'attr1', 'OUTPUT_ATTRIBUTES' = 'COUNT_attr1'] , [...]
		var args = generateKeyValueString(
			lll,
			output_attr,
			','
		).replace("[''", "['")
		.replace("'']", "']")
		.replace("'',''", "','")

		//Generates the group by argument that is formed like ['attr1', attr2', ...]
		var groupby = ''
		if(!orderAttr.empty)
		{
			groupby += ',GROUP_BY=['
			groupby += generateListString(
				orderAttr.stream.map(e|e.name).collect(Collectors.toList)
			) + ']'
		}
		return (#[aliases, '''AGGREGATION({AGGREGATIONS=[«args»]«groupby»}, «input»)'''])
	}
	
	def Object[] buildAggregationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, Source src) 
	{
		return buildAggregationOP(aggAttr, orderAttr, buildWindowOP(src))
	}

	def Object[] buildAggregationOP(List<Aggregation> aggAttr, List<Attribute> orderAttr, List<Source> src) 
	{
		return buildAggregationOP(aggAttr, orderAttr, buildJoin(null, src))
	}
	 */
}