/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.generator

import de.uniol.inf.is.odysseus.core.infoservice.InfoService
import de.uniol.inf.is.odysseus.core.infoservice.InfoServiceFactory
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFAttribute
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.And
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Argument
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeRef
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeWithNestedStatement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateParameters
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateSink1
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStream1
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStreamChannel
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStreamFile
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateView
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Expression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionComponent
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Function
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Or
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Select
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.SelectExpression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StreamTo
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant
import java.util.ArrayList
import java.util.Arrays
import java.util.Collection
import java.util.Collections
import java.util.List
import java.util.Map
import java.util.Map.Entry
import java.util.stream.Collectors
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGenerator2
import org.eclipse.xtext.generator.IGeneratorContext
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFDatatype
import de.uniol.inf.is.odysseus.mep.MEP
import de.uniol.inf.is.odysseus.core.mep.IExpressionParser
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.DataType

/** Generates PQL text from a CQL text. */
class CQLGenerator implements IGenerator2
{
	static val private InfoService infoService = InfoServiceFactory.getInfoService("CQLGenerator");//TODO Produces INFO  RCPInfoServiceListener  - Generated PQL Query:
	
	//TODO Write uniform getter for the registry with dispatch methods. Makes it readable and easier to change
	//Data structures to hold information about attributes, sources, generated operators, etc.
	var private Map<String, String> 		registry_Operators = newHashMap
	var private Map<String, String> 		registry_StreamTo = newHashMap	
	var private Map<String, String> 		registry_Sinks = newHashMap
	var private Map<String, String> 		registryBackUp_Operators = newHashMap
	var private Map<String, List<String>> 	registry_NestedSelects = newHashMap
	var private Map<String, List<String>> 	registry_RenamedAttributes = newHashMap
	var private List<SourceStruct> 			registry_Sources = newArrayList
	var private List<String> 				registryBackUp_OperatorNames = newArrayList
	var private List<String> 				registry_OperatorNames = newArrayList
	var private Map<String, String> 		registry_Expressions = newHashMap
	var private List<String> 				registry_Aggregations = newArrayList
	var private Map<String, String>			registry_AttributeAliases = newHashMap
	//Counters to keep track of identifiers for operators, aggregations, expressions
	var private operatorCounter = 0
	var private aggregationCounter = 0
	var private expressionCounter = 0
	var private selfJoinCounter = 1
	//Holds a predicate or expressions string during its recursive generation
	var private String predicateString = null
	var private String expressionString = null
	var private firstJoinInQuery = true
	//Provides different names e.g. to identify valid names for aggregations and map functions 
	var private NameProvider nameProvider
	
	var private IExpressionParser expressionParser
	//
	var private List<Source> querySources = newArrayList
	
	val private String OP     = "operator_"
	val private String VIEW   = "view_" 
	val private String ASSIG1 = "="
	val private String ASSIG2 = ":="

	def void clear()
	{
		registry_StreamTo.clear()
		registry_Sinks.clear()
		registry_OperatorNames.clear()
		registry_Operators.clear()
		registry_NestedSelects.clear()
		registry_Sources.clear()
		registry_Expressions.clear()
		registry_Aggregations.clear()
		registry_RenamedAttributes.clear()
		operatorCounter = 0
		aggregationCounter = 0
		expressionCounter = 0
		selfJoinCounter = 1
		predicateString = null
		expressionString = null
		querySources = newArrayList
		firstJoinInQuery = true
	}

	override afterGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context)  
	{
		clear()
	}
	override beforeGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		clear()
	}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		var i = 0 ;
		for(e : resource.allContents.toIterable.filter(typeof(Statement)))
		{
			fsa.generateFile(
				""+ i++,	
				e.parseStatement()
			)
		}
	}	
	
	def CharSequence parseStatement(Statement stmt)
	{
		switch stmt.type
		{
			CreateView			: parseCreateView(stmt.type as CreateView)
			CreateStream1  		: parseCreateStream1(stmt.type as CreateStream1)
			CreateSink1         : parseCreateSink(stmt.type as CreateSink1)
			CreateStreamChannel : parseCreateStreamChannel(stmt.type as CreateStreamChannel)
			CreateStreamFile    : parseCreateStreamFile(stmt.type as CreateStreamFile)
			StreamTo		 	: parseStreamTo(stmt.type as StreamTo)
			Select 		   		: parseSelect(stmt.type as Select)
		}
		var model= createModel()
		infoService.info("Generated PQL Query:"+ System.getProperty("line.separator") + model)
		return model
	}
	
	def String createModel()
	{
		var model = ''
		for(var i = 0; i < registry_OperatorNames.size; i++)
		{
			if(!registry_OperatorNames.get(i).contains(OP))
				model += formatOutputString(registry_OperatorNames.get(i) + ASSIG2 + registry_Operators.get(registry_OperatorNames.get(i))) + System.getProperty("line.separator")
			else
				model += formatOutputString(registry_OperatorNames.get(i) + ASSIG1 + registry_Operators.get(registry_OperatorNames.get(i))) + System.getProperty("line.separator")
			for(Entry<String, List<String>> entry : registry_NestedSelects.entrySet)
			{
				if(entry.key.equals(registry_OperatorNames.get(i)))
				{
					var l = entry.value
					for(String alias : l)
						model += formatOutputString(alias + ASSIG1 + entry.key) + System.getProperty("line.separator")
				} 	
			}
		}

//		if(!getAttributeAliases.empty)
//		{
//			var String[] lines = model.split(System.getProperty("line.separator"));
//			var lastline = lines.get(lines.length - 1)
//			var String[] parts 
//			if(lastline.contains(ASSIG1))
//				parts = lastline.split(ASSIG1)
//			else
//				parts = lastline.split(ASSIG2)
//			if(parts != null)
//				model += formatOutputString(buildRenameOperatorWithAssigment(parts.get(0)).toString)
//		}
		
		
		return model
	}
	
	/** Parse a select statement and returns its last operator name. */
	def parseSelect(Select stmt)
	{
		for(Source source : stmt.sources)
		{
		    if(!querySources.contains(source) && source.nested == null)
		    {
		        querySources.add(source)
				registerAlias(source)
			}
		}
		firstJoinInQuery = true
		expressionCounter = 0
		aggregationCounter = 0
		expressionString = null
		registry_RenamedAttributes.clear()
		// Parse select	and register operators
		var CharSequence result
		if(null == stmt.predicates)
		 	result = parseSelectWithoutPredicate(stmt)
		else
			result = parseSelectWithPredicate(stmt)
		
		//If the distinct key word was used, add it to the last operator in the query	
		if(stmt.distinct != null)
		{
			var operator = registry_Operators.get(getLastOperator())
			operator = "DISTINCT(" + operator + ")"	
			//Update operator
			registry_Operators.put(result.toString, operator)
		}
		return result
	}
	
	def private CharSequence parseSelectWithoutPredicate(Select stmt)
	{
		var attributes = extractAttributesFromArgument(stmt.arguments)
		var aggregations = extractAggregationsFromArgument(stmt.arguments)
		var expressions = extractSelectExpressionsFromArgument(stmt.arguments)
	    var Map<String, List<String>> attributes2 = newHashMap
    	attributes2 = extractAttributeInformation(stmt, attributes2)
		
		if(!attributes.empty)//SELECT attr1, ...
		{
			var String operator1 = null
			var String operator2 = null
			if(!expressions.empty)//Contains expressions like SELECT DolToEuro(attr1) * 20.05 AS alias1 FROM ..
			{
				var result1 = buildMapOperator(expressions, stmt.sources)
			 	operator1 = result1.get(1).toString//changed
			 	for(String attributename : (result1.get(0) as List<String>))
			 	{
			 		attributes2 = addToMap(attributes2, attributename, '')
		 		}
			}
			if(!aggregations.empty)//Contains aggregations like SELECT AVG(attr1), MAX(attr2) AS maxAttr2s FROM ..
			{
				var result2 = buildAggregateOP(aggregations, stmt.order, stmt.sources)
			    operator2   = registerOperator(result2.get(1).toString)
			 	for(String attributename : (result2.get(0) as List<String>))
			 	{
			 		attributes2 = addToMap(attributes2, attributename, '')
	 			}
			}
			
			var String join2 = null
			if(operator1 != null && operator2 != null)
				join2 = operator2//changed
			else if(operator1 != null)
				join2 = buildJoin(stmt.sources).toString//changed
			else if(operator2 != null)
				join2 = operator2
			else
				join2 = buildJoin(stmt.sources).toString//TODO is still necessary?
			//
//	 		var attributeList = attributes2.get('')
//	 		if(attributeList == null)
//	 		attributes2.put('', attributeList)
//	 		println(attributes2.toString)//TODO Remove this after debugging
	 		///
			return '''«buildProjectOP(attributes2, join2, stmt.arguments)»'''
		}
		else
		{
			if(aggregations.empty && expressions.empty)//Simple SELECT * Query
			{
//				var Map<String, List<String>> attributes2 = newHashMap
				for(Source source : stmt.sources)
				{
					var list = attributes2.get(source)
					if(list == null)
						list = newArrayList
					for(String attributename : getAttributeNamesFrom(source.name))
					{
						attributes2 = addToMap(attributes2, attributename, source.name)
					}
				}
					////
				if(stmt.sources.size == 1)
					return '''«buildProjectOP(attributes2, buildJoin(stmt.sources), null, stmt.sources)»'''
				return registerOperator('''«buildJoin(stmt.sources)»''')//TODO is still necessary?
			}
			else 
			{
				var String operator1 = null
				var String operator2 = null
				if(!expressions.empty)//Contains expressions like SELECT DolToEuro(attr1) * 20.05 AS alias1 FROM ..
				{
					var result1 = buildMapOperator(expressions, stmt.sources)
				 	operator1 = result1.get(1).toString
 				 	for(String attributename : (result1.get(0) as List<String>))
				 	{
				 		attributes2 = addToMap(attributes2, attributename, '')
			 		}
				}
				println(attributes2)
				if(!aggregations.empty)
				{
				 	var result2 = buildAggregateOP(aggregations, stmt.order, stmt.sources)
					operator2 = result2.get(1).toString
				 	for(String attributename : (result2.get(0) as List<String>))
				 	{
				 		attributes2 = addToMap(attributes2, attributename, '')
		 			}
				}
				
				var String join2 = null
				if(operator1 != null && operator2 != null)
					join2 = operator2//changed
				else if(operator1 != null)
					join2 = buildJoin(stmt.sources).toString//changed
				else if(operator2 != null)
					join2 = operator2
				else
					join2 = buildJoin(stmt.sources).toString//TODO is still necessary?
				//
//		 		var attributeList = attributes2.get('')
//		 		if(attributeList == null)
//		 		attributes2.put('', attributeList)
	//	 		println(attributes2.toString)//TODO Remove this after debugging
		 		///
				return '''«buildProjectOP(attributes2, join2, stmt.arguments)»'''
			}
		}
	}
	
	def private CharSequence parseSelectWithPredicate(Select stmt)
	{
		var attributes = extractAttributesFromArgument(stmt.arguments)
		var aggregations = extractAggregationsFromArgument(stmt.arguments)
		var expressions = extractSelectExpressionsFromArgument(stmt.arguments)
	    var String operator1 = null
	    var String operator2 = null
	    var Map<String, List<String>> attributes2 = newHashMap
	    attributes2 = extractAttributeInformation(stmt, attributes2)

		var List<Expression> predicates = newArrayList
		var List<Source>        sources = newArrayList
		
		predicates.add(0, stmt.predicates.elements.get(0))
		if(stmt.having != null)
			predicates.add(0, stmt.having.elements.get(0))
		sources.addAll(stmt.sources)
		
		if(!expressions.empty)//Contains expressions like SELECT DolToEuro(attr1) * 20.05 AS alias1 FROM ..
		{
			var result1 = buildMapOperator(expressions, stmt.sources)
		 	operator1 = result1.get(1).toString//changed
		 	for(String attributename : (result1.get(0) as List<String>))
		 	{
		 		var attributeList = attributes2.get('')
		 		if(attributeList == null)
		 			attributeList = newArrayList
		 		if(!attributeList.contains(attributename))
		 			attributeList.add(attributename)
		 		attributes2.put('', attributeList)
	 		}
		}
		if(!aggregations.empty)
		{
			var result2 = buildAggregateOP(aggregations, stmt.order, sources)
		    operator2   = registerOperator(result2.get(1).toString)
		 	for(String attributename : (result2.get(0) as List<String>))
		 	{
		 		var attributeList = attributes2.get('')
		 		if(attributeList == null)
		 			attributeList = newArrayList
		 		if(!attributeList.contains(attributename))
		 			attributeList.add(attributename)
		 		attributes2.put('', attributeList)
	 		}
		}
		
		var nested = EcoreUtil2.eAllOfType(stmt, AttributeWithNestedStatement)
		if(!nested.empty)
		{
			for(var i = 0; i < nested.size; i++)
			{
				//FIXME No attributes will be added
				attributes2 = extractAttributeInformation(stmt, attributes2)		
				var s = nested.get(i).nested.sources
				var names = newArrayList
				for(Source s1 : sources)
				{
					names.add(s1.name)
				}
				for(Source s2 : s)
				{
					if(!names.contains(s2.name))
						sources.add(s2)
				}	
//				for(Source c : s)
//					if(!sources.contains(c))
//						sources.add(c)
			}
		}
		
		//TODO put this into a method
		var String join2 = null
		if(operator1 !=null && operator2 != null)
			join2 = operator2//changed
		else if(operator1 != null)
			join2 = buildJoin(stmt.sources).toString//changed
		else if(operator2 != null)
			join2 = operator2
		else
			join2 = buildJoin(stmt.sources).toString

		if(!checkIfSelectAll(attributes) || !aggregations.empty || !expressions.empty)
			return '''«buildProjectOP(attributes2, buildSelectOP(predicates, join2), stmt.arguments)»'''
		return '''«buildSelectOP(predicates, join2)»'''
	}
		
	/**Builds a predicate string from a given {@link Expression}. */
	def private CharSequence parsePredicate(Expression e)
	{
		if(!e.eContents.empty)
		{
			switch e
			{
				Or:
				{
					parsePredicate(e.left)
					predicateString += '||'
					parsePredicate(e.right)
					
				}
				And:
				{
					parsePredicate(e.left)
					predicateString += '&&'
					parsePredicate(e.right)
				}  
				Equality:
				{
					parsePredicate(e.left)
					if(e.op.equals("="))
						predicateString += '=='
					else
						predicateString += e.op
					parsePredicate(e.right)
				}
				Comparision:
				{
					parsePredicate(e.left)
					predicateString += e.op	  
					parsePredicate(e.right)	
				}
				Plus:
				{
					parsePredicate(e.left)
					predicateString += '+'
					parsePredicate(e.right)
				}
				Minus:
				{
					parsePredicate(e.left)
					predicateString += '-'
					parsePredicate(e.right)					
				}
				MulOrDiv:
				{
					parsePredicate(e.left)
					predicateString += e.op
					parsePredicate(e.right)
				}
				NOT:
				{
					predicateString += '!'
					parsePredicate(e.expression)
				}
				Bracket:
				{
					predicateString += '(' 
					parsePredicate(e.inner)
					predicateString += ')' 
				}
				AttributeRef:
				{
					/* attr1 > 10 AND attr1 IN (SELECT attr1 FROM s1 WHERE attr1 != 10) AND attr2 IN (... )
					 * AttributeRef := (attr1 IN (SELECT attr1 FROM s1 WHERE attr1 != 10))
					 */
					if(e.value instanceof AttributeWithNestedStatement)
					{
						parseNestedPredicate((e.value as AttributeWithNestedStatement).nested)
//						for(Source source : (e.value as AttributeWithNestedStatement).nested.sources)
//						{
//							
//						}
					} 
					else
					{
						if(e.value instanceof Attribute)
						{
						    
							predicateString += getAttributename(e.value as Attribute)
						}
					}
				}  	 
			}
		} 
		else
		{
			var str = ''
			switch e
			{
				IntConstant: 	str = e.value + ''
				FloatConstant:  str = e.value + ''
				StringConstant: str = "'" + e.value + "'"
				BoolConstant: 	str = e.value + ''
	
			}
			predicateString += str
		}
//		println(predicate)
		return predicateString
	}
	
	def private CharSequence parseNestedPredicate(Select select)
	{
		if(select.predicates == null)
		{
			var List<Source> nestedSources = newArrayList
			for(Source source : select.sources)
				if(source.nested != null)
					nestedSources.add(source)
			
			for(Source source : nestedSources)
			{
				var nestedPredicate = source.nested.predicates
				if(nestedPredicate != null)
					predicateString += parsePredicate(source.nested.predicates.elements.get(0))
			 }
			return predicateString
		}
		else
			return parsePredicate(select.predicates.elements.get(0))
	}
	
	def private CharSequence parsePredicate(List<Expression> expressions)
	{
		var s = ''
		for(var i = 0 ; i < expressions.size - 1; i++)
		{
			if(expressions.get(i) instanceof AttributeRef)
			{
				if((expressions.get(i) as AttributeRef).value instanceof AttributeWithNestedStatement)
				{
					// ignore it!
				}
			}
			else
			{
				predicateString = ''
				var result = parsePredicate(expressions.get(i))
				s +=  result + '&&'
			}
		}
		predicateString = ''
		s += parsePredicate(expressions.get(expressions.size - 1))
		return s
	}
		
	var List<Object> expressionComponents = new ArrayList	
	def private CharSequence parseSelectExpression(SelectExpression e)
	{
		var str = ''
		for(var i = 0; i < e.expressions.size; i++)
		{
			var component = (e.expressions.get(i) as ExpressionComponent).value
			switch(component)
			{
				Function: str += component.name + '(' + parseSelectExpression((component.value as SelectExpression)) + ')'
				Attribute: str += getAttributename(component.name)	
				IntConstant: 	str += component.value + ''
				FloatConstant:  str += component.value + ''
				BoolConstant: 	str += component.value + ''//TODO Is a bool value feasible?
				StringConstant: str += '\"' + component.value + '\"'
			}
			if(!(component instanceof Function))
				expressionComponents.add(component)	
			if(i != e.expressions.size - 1)
				str += e.operators.get(i)
		}
		return str
	}	
	
	def CharSequence parseSelectExpressionType(List<Object> components)
	{
		var list = newArrayList
		for(Object comp :components)
		{
			if(comp instanceof IntConstant)
				list.add(SDFDatatype.INTEGER)
			else if(comp instanceof FloatConstant)
				list.add(SDFDatatype.FLOAT)
				
				
		}
		
		return ''
	}
	
	def private CharSequence parseCreateView(CreateView view)
	{
		return registerOperator(parseSelect(view.select).toString, VIEW + getID())
	}
	
	def private CharSequence parseCreateStream1(CreateStream1 create)
	{
		return registerOperator(buildCreate1("ACCESS", create.pars, create.attributes.arguments, create.attributes.name).toString, create.attributes.name)
	}	
	
	def private CharSequence parseCreateStreamFile(CreateStreamFile file)
	{
		var attributenames = newArrayList
		var datatypes = newArrayList
		for(var i = 0; i < file.attributes.arguments.size - 1; i = i + 2)
		{
			attributenames.add(file.attributes.arguments.get(i))
			datatypes.add(file.attributes.arguments.get(i + 1))
		}
		var schema = generateKeyValueString(
					attributenames,
					datatypes,
					','
				  )
		
		var options = '''['filename','«file.filename»'],['delimiter',';'],['textDelimiter',"'"]'''		  
		return registerOperator(buildCreate2('GenericPull', file.type, 'File', 'Tuple', schema, options, file.attributes.name).toString, file.attributes.name)
	}
	
	def private CharSequence parseCreateStreamChannel(CreateStreamChannel channel) 
	{
		var attributenames = newArrayList
		var datatypes = newArrayList
		for(var i = 0; i < channel.attributes.arguments.size - 1; i = i + 2)
		{
			attributenames.add(channel.attributes.arguments.get(i))
			datatypes.add(channel.attributes.arguments.get(i + 1))
		}
		var schema = generateKeyValueString(
			attributenames,
			datatypes,
			','
		  )
		
		var options = '''['port','«channel.port»'],['host', '«channel.host»']'''		  
		return registerOperator(buildCreate2('GenericPush', 'SizeByteBuffer', 'NonBlockingTcp', 'Tuple', schema, options, channel.attributes.name).toString, channel.attributes.name)
	}	
	
	def private CharSequence parseCreateSink(CreateSink1 sink) 
	{
		var operator = buildCreate1("SENDER", sink.pars, sink.attributes.arguments, sink.attributes.name).toString
		if(!operator.contains("--INPUT--"))
			return registerOperator(operator, sink.attributes.name)
		else 
			registry_Sinks.put(sink.attributes.name, operator)
	}
	
	def private parseStreamTo(StreamTo query)
	{
		var lastOperator = ''
		var sink = ''
		if(registry_Sinks.keySet.contains(query.name))
			sink = registry_Sinks.get(query.name)
	
		if(query.statement != null)
		{
			parseSelect(query.statement)
			lastOperator = getLastOperator()
		}		
		else
			lastOperator = query.name
	
		if(sink != '')
		{
			sink = sink.replace("--INPUT--", lastOperator)
			if(!registryBackUp_Operators.empty)
			{
				registry_Operators = registryBackUp_Operators
				registry_OperatorNames = registryBackUp_OperatorNames
				registryBackUp_Operators.clear()
				registryBackUp_OperatorNames.clear()
			}
			registry_Sinks.remove(query.name)
			registerOperator(sink, query.name)
		}
		else
		{ 				
			registry_StreamTo.put(query.name, query.name)
			registryBackUp_Operators = registry_Operators
			registry_Operators.clear()
			registryBackUp_OperatorNames = registry_OperatorNames
			registry_OperatorNames.clear()			
		}
	}
	
	def private CharSequence buildWindowOP(Source src)
	{
		if(src.time != null)
		{
		println("Hes")
			var var1 = if(src.time.advance_size != 0) src.time.advance_size else 1
			var var2 = if(src.time.advance_size != 0) src.time.advance_unit else src.time.unit
			return '''TIMEWINDOW
					  (
					  	{
					  		size = [«src.time.size»,'«src.time.unit»'],
					  		advance = [«var1»,'«var2»']
						},
						«src.name»
					 )'''			 
		}
		else if(src.tuple != null)
		{
			var var1 = if(src.tuple.advance_size != 0) src.tuple.advance_size else 1
			if(src.tuple.partition_attribute == null)
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»
						   	},
						   	«src.name»
						   )'''

			}
			else
			{
				return  '''ELEMENTWINDOW
						   (
						   	{
								size = «src.tuple.size»,
								advance = «var1»,
								partition = '«src.tuple.partition_attribute.name»'
						   	},
						   	«src.name»
						   )'''
			}			
		}
		else 
		{ 
			return src.name
		}
		
	}
	
	def private Object[] buildMapOperator(List<SelectExpression> expressions, CharSequence sources)
	{
		var expressionArgument = ''
		var List<String> expressionStrings = newArrayList()
		var List<String> attributeNames = newArrayList()
		println("buildMapOperator::")
		for(var i = 0; i < expressions.size; i++)
		{
			var expressionName  = ''
			var expressionString = parseSelectExpression(expressions.get(i)).toString
			var expressionType = MEP.instance.parse(expressionString).returnType.toString //parseSelectExpressionType(expressionComponents)
			println("expressiontype:: " + expressionType)
			if(expressions.get(i).alias ==  null)
				expressionName = "expression_" + (expressionCounter++)
			else
				expressionName = expressions.get(i).alias.name	
			expressionStrings.add(expressionString)
			expressionStrings.add(expressionName)
			expressionStrings.add(',')
			expressionArgument += generateKeyValueString(expressionStrings)
			registry_Expressions.put(expressionName, expressionArgument)
			if(i != expressions.size - 1) expressionArgument += ','
			expressionStrings.clear
			attributeNames.add(expressionName)
		}
//		Collections.sort(attributeNames)
		return #[attributeNames, '''MAP({expressions = [«expressionArgument»]},«sources»)''']
	}
	
	def private Object[] buildMapOperator(List<SelectExpression> expression, List<Source> sources)
	{
		return buildMapOperator(expression, buildJoin(sources))
	}
	
	def private Object[] buildMapOperator(SelectExpression expression, CharSequence sources)
	{
		var list = newArrayList
		list.add(expression)
		return buildMapOperator(list, sources)
	}
	
	def private Object[] buildAggregateOP(List<SelectExpression> aggAttr, List<Attribute> orderAttr, CharSequence input)
	{
		//TODO Add expressions
		var argsstr 			 = ''
		var List<String> args    = newArrayList
		var List<String> aliases = newArrayList
		var List<String> inputs = newArrayList
		
		for(var i = 0; i < aggAttr.length; i++)
		{
			
			var aggregation = aggAttr.get(i).expressions.get(0).value as Function
			
			args.add(aggregation.name)
			
			var attributename = ''
			var datatype = ''
			var components = (aggregation.value as SelectExpression).expressions
			if(components.size == 1)
			{
				var comp = components.get(0).value
				switch(comp)
				{
					Attribute:
					{
						attributename = getAttributename(comp.name)
						datatype = getDataTypeFrom(attributename)
					}
				}
			}
			else
			{
				
			}
//			switch(components)
//			{
//				Attribute: attributename = getAttributename(components.name)
//				Function,
//				IntConstant,
//				FloatConstant,
//				StringConstant,
//				BoolConstant: 
//				{
//					var result = buildMapOperator(aggAttr.get(i).value as SelectExpression, input)
//					attributename = (result.get(0) as List<String>).get(0)
//					var mapOperator = result.get(1).toString
//					inputs.add(registerOperator(mapOperator))
//				}
//			}
			
			args.add(attributename)
			
			var alias = ''
			if(aggAttr.get(i).alias != null)
				alias = aggAttr.get(i).alias.name
			else
				alias = aggregation.name + '_' + (aggregationCounter++)
				
			args.add(alias)
			aliases.add(alias)
			if(attributename != '') args.add(datatype)//If no data type is given, it will be double
			registry_Aggregations.add(alias)
			args.add(',')
			argsstr += generateKeyValueString(args)
			if(i != aggAttr.length - 1) argsstr += ','
			args.clear
		}
		//Generates the group by argument that is formed like ['attr1', attr2', ...]
		var groupby = ''
		if(!orderAttr.empty)
		{
			groupby += ',GROUP_BY=['
			groupby += generateListString(
				orderAttr.stream.map(e|getAttributename(e.name, null)).collect(Collectors.toList)
			) + ']'
		}
		return #[aliases, '''AGGREGATE({AGGREGATIONS=[«argsstr»]«groupby»}, «input»)''']
	}
	
	def private Object[] buildAggregateOP(List<SelectExpression> list, List<Attribute> list2, List<Source> srcs)
	{
		return buildAggregateOP(list, list2, buildJoin(srcs))
	}
//TODO Remove	
//	def private Object[] buildAggregateOP(List<SelectExpression> list, List<Attribute> list2, Source src)
//	{
//		return buildAggregateOP(list, list2, checkForNestedStatement(src))
//	}
	
	def private CharSequence buildRenameOperatorWithAssigment(CharSequence operator)//TODO Documentation
	{
		var list = newArrayList
		for(Entry<AttributeStruct, List<String>> l : getAttributeAliases.entrySet)
		{
			list.add(l.key.attributename)
			list.add(l.value.get(0))
		}
		return '''renamed_«getID()» = RENAME({aliases=[«generateListString(list)»], pairs='true'}, «operator»)'''
	}
	
	def private CharSequence buildRenameOperator2(List<String> paired, String source)//TODO rename method
	{
		return '''RENAME({aliases=[«generateListString(paired)»], pairs='true'}, «source»)'''
	}
			
	def private CharSequence buildCreate1(String type, CreateParameters pars, List<String> attrs, String name)
	{	
		var wrapper     = pars.wrapper
		var protocol    = pars.protocol
		var transport   = pars.transport
		var dataHandler = pars.datahandler
		var attributenames = newArrayList
		var datatypes = newArrayList
		for(var i = 0; i < attrs.size - 1; i = i + 2)
		{
			attributenames.add(attrs.get(i))
			datatypes.add(attrs.get(i + 1))
		}
		var args 		= generateKeyValueString(
							attributenames,
							datatypes,
							','
						  )
		var options 	= generateKeyValueString(
							pars.keys,
							pars.values,
							','
						  )		
		var t = ''
		var s = ''
		var b = false
		if(type.equals("ACCESS"))
		{
			t = 'source'
			s = '''schema = [«args»],'''	
		}
		else
		{
			b = true
			t = 'sink'	
		}				  

		var input = "--INPUT--"
		if(registry_StreamTo.keySet.contains(name))
			input = registry_StreamTo.get(name)
						  
		var sink = '''«type»
				  (
					{	  
						«t»      = '«name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						«s»
						options =[«options»]
					 }
					 «IF b»,«input»«ENDIF»
				   )'''
		return sink
	}	
	
	def private CharSequence buildCreate2(String wrapper, String protocol, String transport, String dataHandler, String schema, String options, String name)
	{						  
		return '''ACCESS
				  (
					{	  
						source      = '«name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						schema = [«schema»],
						options =[«options»]
					 }
				   )'''
	}

	def private buildJoin(List<Source> sources)
	{
		var String[] sourceStrings = newArrayOfSize(sources.size)
		var List<String> operatorNames = newArrayList
		var List<String> sourcenames = newArrayList
		//Check for nested select statements and save their names
		for(var i = 0; i < sources.size; i++)
		{
			if(sources.get(i).nested != null)
			{
				parseSelect(sources.get(i).nested)
				var lastOperator = getLastOperator()
				operatorNames.add(lastOperator)
				sourceStrings.set(i, lastOperator)
			}
			else
			{
				//Check for self join
				val sourcename = sources.get(i).name
				val count = sourcenames.stream.filter(e|e.equals(sourcename)).count
				sourcenames.add(sources.get(i).name)
				sourcesDuringRename = sources
				sourceStrings.set(i, 
					buildRenameOperatorX(
						buildWindowOP(sources.get(i)), sources.get(i), count as int
					).toString
				)
			}
		}	
		//Check for window operators and rename operators
		
		return buildJoin(sourceStrings)
	}
	
	var List<Source> sourcesDuringRename
	def CharSequence buildRenameOperatorX(CharSequence input, Source source, int selfJoin)
	{
		var List<String> aliases = newArrayList
		var sourcealias = if(source.alias != null) source.alias.name else null
		var sourceStruct = getSource(source.name)
		var aliasedAttributes = newArrayList
		var counter = 0
		//Check for aliases
		for(AttributeStruct struct : sourceStruct.attributes)
		{
			for(String structAlias : struct.aliases)
			{				
				var correspondingSource = registry_AttributeAliases.get(structAlias)
				if(correspondingSource.contains('.'))
				{
					var split = correspondingSource.split("\\.")
					val realSourcename = split.get(0)
					if(sourcealias != null)
					{
						if(realSourcename.equals(sourcealias) || realSourcename.equals(source.name))
						{
							var countSources = sourcesDuringRename.stream.filter(e|e.name.equals(realSourcename)).count
							if(aliases.contains(struct.attributename) || (countSources > 1))
								throw new IllegalArgumentException("given attribute " + struct.attributename + " cannot be referenced")
							aliases.add(struct.attributename)
							aliases.add(structAlias)
							counter++
						}
					}
					else
					{
						if(realSourcename.equals(source.name))
						{
							if(aliases.contains(struct.attributename))
								throw new IllegalArgumentException("given attribute " + struct.attributename + " cannot be referenced")
							aliases.add(struct.attributename)
							aliases.add(structAlias)
							counter++
						}
						else
							throw new IllegalArgumentException("given attribute " + struct.attributename + " cannot be referenced")
					}
				}
				else
				{
					if(correspondingSource.equals(source.name))
					{
						if(aliases.contains(struct.attributename))
							throw new IllegalArgumentException("given attribute " + struct.attributename + " cannot be referenced")
						aliases.add(struct.attributename)
						aliases.add(structAlias)
						counter++
					}
				}
			}
			aliasedAttributes.add(struct.attributename)
		}
		//Self join
		if(selfJoin > 0 && counter != sourceStruct.attributes.size)
		{
			println("self join:: ")
			
			var newAliases = newArrayList
			for(String attributename : getAttributeNamesFrom(source.name))
			{
				if(!aliases.contains(attributename))
				{
					//Choose an alias for the self joined attribute
					var newAlias = source.name + '.' + attributename + '#' + selfJoin
					newAliases.add(attributename)
					newAliases.add(newAlias)
					aliases.add(attributename)
					aliases.add(newAlias)
				}
			}
//			registry_RenamedAttributes.put(string1, newAliases)	
		}
	
		println(SDFDatatype.types)
		
		//Build rename operator
		if(!aliases.empty)
			return registerOperator('''RENAME({aliases=[«generateListString(aliases)»], pairs='true'}, «input»)''')
		return input
	}
	
	def private CharSequence buildJoin(String[] srcs)
	{
		var sourcenames = srcs
//		if(firstJoinInQuery)
//			Collections.sort(sourcenames)
//		firstJoinInQuery = false
				
		if(sourcenames.size < 1)
		{ 
			throw new IllegalArgumentException(
				"Invalid number of source elements: There have to be at least two sources"
			)
		}
		if(sourcenames.size == 1)//Will only be considered if the first call of this method provides a single source
		{
			firstJoinInQuery = true
			return sourcenames.get(0)
		}
		var List<String> list = new ArrayList(Arrays.asList(sourcenames))
//		var source1 = checkIfRenameOperatorIsNecessary(list.get(0))
//		var source2 = checkIfRenameOperatorIsNecessary(list.get(1))
//		source1 = checkForSelfJoinAndRegister(source1, source2)
		
		if(list.size == 2)
		{
			firstJoinInQuery = true
			return '''JOIN(«sourcenames.get(0)»,«sourcenames.get(1)»)'''
		}
		list.remove(0)
		return '''JOIN(«sourcenames.get(0)»,«buildJoin(list)»)'''
	}

	def private CharSequence buildSelectOP(List<Expression> predicate, CharSequence operator)
	{
		predicateString = ''
		return registerOperator('''SELECT({predicate='«parsePredicate(predicate)»'},«operator»)''')
	}
	
	def private CharSequence buildProjectOP(Map<String, List<String>> map, CharSequence operator, List<Argument> order)
	{
		return buildProjectOP(map, operator, order, null)
	}
	
	def private CharSequence buildProjectOP(Map<String, List<String>> map, CharSequence operator, List<Argument> order, List<Source> sources)
	{
		var orderedAttributes = newArrayList
		if(order == null && sources != null)
		{
			for(Source source : sources)
				for(String attributename : map.get(source.name))
					orderedAttributes.add(getAttributename(attributename, source.name))
		}
		else
		{
				
			var aggregationCounter = 0
			var expressionCounter  = 0	
			var m = map.get("")
			var List<String> attributes = newArrayList
			//Add attributes to list
			for(Entry<String, List<String>> entry : map.entrySet)
			{
				if(entry.key.equals(""))
				{
					if(m != null) for(String attributename : m)
						attributes.add(attributename)
				}
				else 
					for(String attributename : entry.value)
						attributes.add(attributename)
			}

			var list2 = newArrayList//

			//Sort attributes by given order
			if(!order.isEmpty)
			{
    			for(Argument arg : order)
    			{
    				for(String attribute : attributes)
    				{
    					if(arg.attribute != null && attribute.contains('.'))
    					{///
    					    if(arg.attribute.name.contains('.*'))//TODO not needed anymore
    					    {
    					        orderedAttributes.add(attribute)
    					    }
    					    else
    					    {
    					    	var splitted = attribute.split('\\.')
    					    	var currentAttributename = splitted.get(1)
    					    	var currentSourcename    = splitted.get(0)
    					    	
        						if(currentAttributename.equals(arg.attribute.name))
        							orderedAttributes.add(attribute)
        						else if(arg.attribute.name.contains('.'))
        						{
        							var splittedB = arg.attribute.name.split('\\.')
	    					    	var supposedAttributename = splittedB.get(1)
	        						var supposedSourcename = splittedB.get(0)
//        							var realSourcename = getSourcenameFromAlias(sourcename)
//        							println("realSourcename:: " + realSourcename)
//        							if(realSourcename.equals(''))
//        								realSourcename = sourcename
        							println("realSourcename:: " + supposedSourcename + ", " + currentSourcename)
        							if(supposedSourcename.equals(currentSourcename) 
        								&& supposedAttributename.equals(currentAttributename)
        							)
        								orderedAttributes.add(attribute)
        						}
        						else if(attribute.contains('-'))//TODO mark - as keyword for renamed attribute during self join
        							orderedAttributes.add(attribute)
    					    }
    					}
						else if(arg.attribute != null && arg.attribute.name.contains('.*'))
    					{
    						var sourcename = arg.attribute.name.split("\\.").get(0)
    						if(isSourceAlias(sourcename))
    							sourcename = getSourcenameFromAlias(sourcename)
    						if(!list2.contains(sourcename))
    						{
    							list2.add(sourcename)
	    						for(AttributeStruct struct : getSource(sourcename).attributes)
									orderedAttributes.add(struct.attributename)
							}
    					}
    					else if(arg.attribute != null && isAttributeAlias(attribute))
    					{
    						if(arg.attribute.alias != null && arg.attribute.alias.name.equals(attribute))
    							orderedAttributes.add(attribute)
    					}
    					else if(arg.attribute != null && !isAttributeAlias(attribute))
    					{
    						if(arg.attribute.name.equals(attribute))
    							orderedAttributes.add(getAttributename(attribute))//
    					}
    					else if(arg.expression != null)
    					{
    						if(arg.expression.expressions.size == 1)
    						{
    							var aggregation = arg.expression.expressions.get(0) 
    							var function = aggregation.value
    							if(function instanceof Function)
    							{
    								if(nameProvider.isAggregation(function.name))
    								{
    									if(arg.expression.alias != null)
    									{
    										if(attribute.equals(arg.expression.alias.name))
    											orderedAttributes.add(attribute)
    									}
    									else
    									{
    										if(attribute.equals(function.name + '_' + aggregationCounter))
    										{
    											orderedAttributes.add(attribute)
    											aggregationCounter++
    										}
    									}								
    								}
    								else//TODO same -> refactoring
    								{
										if(arg.expression.alias != null)
										{
											if(attribute.equals(arg.expression.alias.name))
												orderedAttributes.add(registry_Expressions.get(attribute))
										}
										else
										{
											if(attribute.equals('expression_' + (expressionCounter)))
											{
												orderedAttributes.add(registry_Expressions.get(attribute))
												expressionCounter++
											}	
										}
    								}
    							}
    						}				
    						else//TODO same -> refactoring
    						{
								if(arg.expression.alias != null)
								{
									if(attribute.equals(arg.expression.alias.name))
										orderedAttributes.add(registry_Expressions.get(attribute))
								}
								else
								{
									if(attribute.equals('expression_' + (expressionCounter)))
									{
										orderedAttributes.add(registry_Expressions.get(attribute))
										expressionCounter++
									}	
								}
    						}
    					}
    				}		
    			}
			}
		}
		
		println("orderedAttributes:: " + orderedAttributes)
		var argument = generateListString(orderedAttributes)
		.replace("'['", "['")
		.replace("']'", "']")

		println("ARGUMENT:: " + argument)

		return registerOperator('''MAP({expressions=[«argument»]},«operator»)''')			
	}
		
		
	def private CharSequence checkForNestedStatement(Source source)
	{///
		if(source.nested != null)
		{
			parseSelect(source.nested)
			return getLastOperator()//alias//return operator_ instead of the alias
		}
		else
			return buildWindowOP(source)
	}
		
	def boolean checkIfSelectAll(List<Attribute> attributes)
	{
		if(attributes.empty)
			return true
		else
			for(Attribute attribute : attributes)
				if(!attribute.name.contains('.*'))
					return false
		return true
	}	
		
	def private String getLastOperator()
	{
		return registry_OperatorNames.get(registry_OperatorNames.size - 1)
	}
	
//	def private String checkForSelfJoinAndRegister(String sourcename1, String sourcename2)
//	{
//		var string1 = sourcename1
//		if(sourcename1.equals(sourcename2))
//		{
//			var paired     = newArrayList
//			var attributes = newArrayList
//			var source = getSource(sourcename1)
//			
//			for(String attributename : getAttributeNamesFrom(sourcename1))
//			{///rename with alias if exits
//				for(String alias : getAliasFromAttributename(attributename, sourcename1))
//				{
//					
//				}
//							
//				var attributealias = string1 + "." + attributename + "-" + selfJoinCounter.toString
//				paired.add(attributename)
//				paired.add(attributealias)
//				attributes.add(attributealias)
//			}
//			registry_RenamedAttributes.put(string1, paired)			
//			string1 = buildRenameOperator2(paired, string1).toString
//			selfJoinCounter++
//		}
//		return string1
//	}
	
	/** Returns all attributes that were renamed after a self join operation. **/
	def private List<String> getRenamedAttributesFromSelfJoin()
	{
		var attributes = newArrayList
		if(!registry_RenamedAttributes.empty)//TODO Refactoring and documentation
		{
			for(Entry<String, List<String>> e : registry_RenamedAttributes.entrySet)
				for(SourceStruct source : this.registry_Sources)
					if(source.sourcename.equals(e.key))
					{
						source.addRenamedAttributes(e.value)
						for(var i = 1; i < e.value.size; i++)
							if(i % 2 == 1)
								attributes.add(e.value.get(i))
					}
		}
		return attributes
	}
	
	//TODO rename method
	def public List<String> getAttributesFromSource(String attributename)
	{
		if(attributename.contains('.*'))
		{
			var String sourcename = attributename.split("\\.").get(0)
			var l = getAttributeNamesFrom(sourcename)
			return l 
		}
		return newArrayList
	}
	
	def public List<String> getSourceNames()
	{
		return registry_Sources.stream.map(e|e.sourcename).collect(Collectors.toList)
	}
	
	def public List<String> getSourceAliasesAsList()
	{
		var list = newArrayList
		for(List<String> l : getSourceAliases().values)
			list.addAll(l)
		return list
	}
		
	def private Map<String, List<String>> addToMap(Map<String, List<String>> map, String attribute, String realSourcename)
	{
        var attributeList = map.get(realSourcename)
        if(attributeList == null)
            attributeList = newArrayList
        if(!attributeList.contains(attribute))
            attributeList.add(attribute)
        map.put(realSourcename, attributeList)
        return map
	}	
		
	def private Map<String, List<String>> addToMapAndDontAllowOverride(Map<String, List<String>> map, String attribute, String realSourcename)
	{
		var attributeList = map.get(realSourcename)
        if(attributeList == null)
            attributeList = newArrayList
		
        return map
	}	
		
	static private interface AttributeParser{ }	
		
	/** Returns all attributes with its corresponding sources from a select statement within a map. */
	def private Map<String, List<String>> extractAttributeInformation(Select select, Map<String, List<String>> var2)//TODO rename
	{
	    val attributeParser = new AttributeParser()
	    {
	        var String attributename
            var List<String> list
	        var String sourcename
	        var String prefix
	        
	        def private parse(String name)
            {
                if(name.contains('.'))
                {
                   var split = name.split("\\.")
                   attributename = split.get(1)
                   sourcename = split.get(0)
                   prefix = sourcename
                   if(!sourceNames.contains(sourcename))
                       sourcename = getSourcenameFromAlias(sourcename)
                   if(sourcename.equals(''))
                       throw new IllegalArgumentException("source with name " + split.get(0) + " is unkown")
                   if(attributename.contains('*'))
                   {
                       list = newArrayList
                       for(String str : getAttributeNamesFrom(sourcename))
                           list.add(str)
                   }
                   else
                       attributename = null
                }
                attributename = name
            }
            
            def private clear() { attributename = null list = null sourcename = null}
	    }
	    
	    var map = var2
		var List<Attribute> attributes = newArrayList
		for(Argument argument : select.arguments)
			if(argument.attribute != null)
				attributes.add(argument.attribute)
		var List<Source> sources = select.sources
		
		//Check if it's a select * query and add for each source its attributes
		if(attributes.empty && EcoreUtil2.getAllContentsOfType(select, SelectExpression).empty)
		{
			for(Source source : sources)
                for(String attribute : getAttributeNamesFrom(source.name))
                    map = addToMap(map, attribute, source.name)
        }
		else
		{
			for(Attribute attribute : attributes)
			{
				//Count sources that contain the current attribute by its name
				var containedBySources = newArrayList
				for(Source source1 : sources)
				{
					if(source1.nested == null)
					{
						for(SourceStruct source2 : registry_Sources)
						{
							if(source1.name.equals(source2.sourcename)
								&& source2.containsAttribute(attribute.name) 
								&& sources.stream.map(e|e.name).collect(Collectors.toList).contains(source2.sourcename)
							)
							{
								if(!containedBySources.contains(source2))
									containedBySources.add(source2)
								else
								{//TODO comment
									if(!attribute.name.contains('.'))
										throw new IllegalArgumentException(attribute.name)
								}
							}
						}
					}
					else//If source is a nested select, call the method recursively
						map.putAll(extractAttributeInformation(source1.nested, map))
				}
				
                attributeParser.clear()
				attributeParser.parse(attribute.name)
				var String realAttributename = if(attribute.alias != null) attribute.alias.name 
											   else 					   attributeParser.attributename
				var String realSourcename    = attributeParser.sourcename		
				
	            if (containedBySources.size > 0) 
	            {
					if (containedBySources.size == 1) 
					{
					    realSourcename = containedBySources.get(0).sourcename
						if (attributeParser.list != null)
							for (String attributename : attributeParser.list)
								map = addToMap(map, attributename, realSourcename)
					} 
					else if (containedBySources.size > 1 && realSourcename == null) 
					{
						throw new IllegalArgumentException(
							"attribute " + realAttributename + " is ambiguous: possible sources are " +
								containedBySources.toString
						)
					}
					map = addToMap(map, realAttributename, realSourcename)
//					containedBySources.clear()
					
					var simpleAttributename = if(attribute.alias != null) attribute.name else realAttributename
					if(simpleAttributename.contains('.'))
						simpleAttributename = simpleAttributename.split("\\.").get(1)
						
					for (AttributeStruct attr1 : getSource(realSourcename).attributes)
						if (attr1.attributename.equals(simpleAttributename) 
						    && attribute.alias != null
						)
						{
							attr1.aliases.add(attribute.alias.name)
							var prefix  = realSourcename + '.'
							if(attributeParser.prefix != null)
							{
								attr1.prefixes.add(attributeParser.prefix)
								prefix = attributeParser.prefix + '.'
							}
							//If there is already an alias with the same name registered, 
							//the given attribute cannot be referenced
							if(registry_AttributeAliases.entrySet.contains(attribute.alias.name))
								throw new IllegalArgumentException("given alias " + attribute.alias.name + " is ambiguous")
							registry_AttributeAliases.put(attribute.alias.name, prefix + realAttributename)
						}
				}
				else 
				{
				    if(attributeParser.list != null)
				    	for (String attributename : attributeParser.list)
				    		map = addToMap(map, attributename, realSourcename)
				}
				containedBySources.clear()
			}
		}
		
		println("map="+map.toString)
		
		return map
	}
	
	def private SourceStruct getSource(String name)
	{
	    for(SourceStruct source : registry_Sources)
	       if(source.sourcename.equals(name))
	           return source
	    return null
	}
	
	def List<Attribute> extractAttributesFromArgument(List<Argument> args)
	{
		var List<Attribute> list = newArrayList
		for(Argument a : args)
			if(a.attribute != null)
				list.add(a.attribute)
		return list
	}
	
	def List<SelectExpression> extractAggregationsFromArgument(List<Argument> args)
	{
		var List<SelectExpression> list = newArrayList
		for(Argument a : args)
		{
			if(a.expression != null)
			{
				if(a.expression.expressions.size == 1)
				{
					var aggregation = a.expression.expressions.get(0) 
					var function = aggregation.value
					if(function instanceof Function)
					{
						if(nameProvider.isAggregation(function.name))
							list.add(a.expression)
					}
				}
			}
		}
		return list
	}
	
	def List<SelectExpression> extractSelectExpressionsFromArgument(List<Argument> args)
	{
		var List<SelectExpression> list = newArrayList
		for(Argument a : args)
			if(a.expression != null)
			{
				if(a.expression.expressions.size == 1)
				{
					var aggregation = a.expression.expressions.get(0) 
					var function = aggregation.value
					if(function instanceof Function)
					{
						if(nameProvider.isMapper(function.name, parseSelectExpression(a.expression as SelectExpression).toString))
							list.add(a.expression)
					}
				}
				else
				{
					list.add(a.expression)
				}		
			}
		return list
	}

	def private String generateKeyValueString(String ... s)
	{
		var str = "["
		if(s.length == 1) 
			return str += "'" + s.get(0) + "']"
		for(var i = 0; i < s.length - 2; i++)
			str += "'" + s.get(i) + "'" + s.get(s.length - 1)			
		return str += "'" + s.get(s.length - 2) + "']"
	}
		
	def private String generateKeyValueString(List<String> l1, List<String> l2, String s)
	{
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)// OUT of bounds...
		{
			str += generateKeyValueString(l1.get(i), l2.get(i), s) + ","
		}
		return (str += generateKeyValueString(l1.get(l1.size - 1), l2.get(l1.size - 1), s))
	}
	
	//TODO Remove unused method
	def private String generateKeyValueString(String s1, List<String> l2, String s2)
	{
		var str = ''
		for(var i = 0; i < l2.size - 1; i++)
		{
			str += generateKeyValueString(s1, l2.get(i), s2) + ","
		}
		return (str += generateKeyValueString(s1, l2.get(l2.size - 1), s2))
	}
	
	def private String generateListString(String s1)
	{
		return "'" + s1 + "'"
	}
		
	def private String generateListString(List<String> l1)
	{
		if(l1 != null && !l1.empty)
		{
			var str = ''
			for(var i = 0; i < l1.size - 1; i++)
			{
				str += generateListString(l1.get(i)) + ","
			}
			return (str += generateListString(l1.get(l1.size - 1)))
		}
		return ''
	}
	
	def private CharSequence getID()
	{
		operatorCounter++
		return operatorCounter.toString
	}

	def private String registerOperator(CharSequence operator)
	{
		return registerOperator(operator, OP + getID())
	}
	
	def private String registerOperator(CharSequence operator, String definition)
	{
		registry_OperatorNames.add(definition.toString)
		registry_Operators.put(definition, operator.toString)
		return definition
	}
	
	def private registerAlias(Source src)
	{
	    if(src.alias != null)
	    	getSource(src.name).aliases.add(src.alias.name)
	}
	
	//TODO Remove source that came from a cql query and are identical with a source that came from a pql query
	def private void registerSources(Collection<SDFSchema> schema, boolean internal)
	{
		for(SDFSchema s : schema)
		{
			for(String sourcename : s.baseSourceNames)
			{
				if(getSourceNames().contains(sourcename))
				{
					var iter = registry_Sources.iterator
					while(iter.hasNext())
					{
						var next = iter.next
						if(next.sourcename.equals(sourcename))
							if(next.internal && !internal)
							{
								iter.remove
								var source = new SourceStruct()
								source.internal = internal
								source.sourcename = sourcename
								source.attributes = newArrayList()
								source.aliases = newArrayList()
								for(SDFAttribute attributename : s.attributes)
									if(sourcename.equals(attributename.sourceName))
									{
										var attribute = new AttributeStruct()
										attribute.attributename = attributename.attributeName 
										attribute.sourcename = sourcename
										attribute.datatype = attributename.datatype.toString	
										attribute.aliases = newArrayList()	
										attribute.prefixes = newArrayList()	
										source.attributes.add(attribute)
									}						
								registry_Sources.add(source)
							}
								
					}
				}
				else
				{
					var source = new SourceStruct()
					source.internal = internal
					source.sourcename = sourcename
					source.attributes = newArrayList()
					source.aliases = newArrayList()
					for(SDFAttribute attributename : s.attributes)
						if(sourcename.equals(attributename.sourceName))
						{
							var attribute = new AttributeStruct()
							attribute.attributename = attributename.attributeName 
							attribute.sourcename = sourcename
							attribute.datatype = attributename.datatype.toString	
							attribute.aliases = newArrayList()	
							attribute.prefixes = newArrayList()		
							source.attributes.add(attribute)
						}						
					registry_Sources.add(source)
				}
			}
		}
	}

	def private registerNestedSelect(String name, String alias)
	{
		if(registry_NestedSelects.containsKey(name))
		{
			if(!registry_NestedSelects.containsValue(alias))
			{
				var aliases = registry_NestedSelects.get(name)
				aliases.add(alias)
				registry_NestedSelects.put(name, aliases)
			}
		}
		else
		{
			var aliases = newArrayList
			aliases.add(alias)
			registry_NestedSelects.put(name, aliases)
		}
	}

	def void setNameProvider(NameProvider provider)
	{
		nameProvider = provider
	}

	def void setOuterschema(Collection<SDFSchema> schema)
	{
		registerSources(schema, false)
	}

	def void setInnerschema(Collection<SDFSchema> schema)
	{
		registerSources(schema, true)
	}
	
	def void setExpressionParser(IExpressionParser parser)
	{
		expressionParser = parser
	}
	
	def private CharSequence formatOutputString(String sequence)
	{
		
		var String str 
		var replacement1 = 'AXZTGHHAJJJSUEJJ23123123123'
		var replacement2 = 'BNHUEOLASJJKEOOS12312309203'
		if(sequence.contains(ASSIG2))
			str = sequence.replaceFirst(ASSIG2, replacement1)
		else
			str = sequence.replaceFirst(ASSIG1, replacement2)
		
		return str.replaceAll("\\s*[\\r\\n]+\\s*", "")
					   .trim()
					   .replace(" ","")
					   .replace(replacement2," "+ASSIG1+" ")
					   .replace(replacement1," "+ASSIG2+" ")
	}
	
	def public boolean isAttributeAlias(String attributename)
	{
		return getAttributeAliasesAsList().contains(attributename)
	}
	
	def public boolean isSourceAlias(String sourcename)
	{
		return getSourceAliasesAsList().contains(sourcename)
	}
	
	def public List<AttributeStruct> getAttributes()
	{
		var list = newArrayList
		for(SourceStruct source : registry_Sources)
			list.addAll(source.attributes)
		return list
	}

	def public Map<AttributeStruct, List<String>> getAttributeAliases()
	{
		var map = newHashMap
		for(SourceStruct source : registry_Sources)
			for(AttributeStruct attribute : source.attributes)
				if(!attribute.aliases.empty)
					map.put(attribute, attribute.aliases)
		return map
	} 

	def public List<String> getAttributeAliasesAsList()
	{
		var list = newArrayList
		for(List<String> l : getAttributeAliases().values)
			for(String alias : l)
				list.add(alias)	
		return list 
	} 

	def public Map<SourceStruct, List<String>> getSourceAliases()
	{
		var map = newHashMap
		for(SourceStruct source : registry_Sources)
				map.put(source, source.aliases)
		return map
	} 
	
	def public String getDataTypeFrom(Attribute attribute) { return getDataTypeFrom(attribute.name) }
	
	def public String getDataTypeFrom(String attribute) 
	{
		var attributename = getAttributename(attribute)
		var splitted = attributename.split("\\.")
		var sourcename = splitted.get(0)
		println(attributename)
		println(splitted.toString)
	    for(AttributeStruct attr : getSource(sourcename).attributes)
	        if(attr.attributename.equals(splitted.get(1)))
	            return attr.datatype		
	}
	
	def public String getSourcenameFromAlias(String sourcealias)
	{
		for(Entry<SourceStruct, List<String>> source : getSourceAliases().entrySet)
			if(source.value.contains(sourcealias))
				return source.key.sourcename
		return null								
	}
	
	def public AttributeStruct getAttributeFromAlias(String alias)
	{
	    for(Entry<AttributeStruct, List<String>> entry : getAttributeAliases().entrySet)
	    	if(entry.value.contains(alias))
	    		return entry.key
	    return null
	}
	
	def public String getAttributenameFromAlias(String alias)
	{
		var attribute = getAttributeFromAlias(alias)
		if(attribute != null)
			return attribute.attributename

		if(this.registry_Aggregations.contains(alias) 
		    || this.registry_Expressions.keySet.contains(alias)
		)
			return alias			
	}
	
	def public String getAttributename(String attributename, String sourcename)
	{
		println("getAttributename:: " + attributename +", " + sourcename)
		
		var String attribute 
		var String source
		if(sourcename != null && !sourcename.equals(""))
		{
			var SourceStruct tmp
			attribute = attributename
			source = if((tmp = getSource(sourcename)) != null) tmp.sourcename else null
		} 
		else if(attributename.contains("."))
		{
			var String[] split = attributename.split('\\.')
			attribute = split.get(1)
			source = split.get(0)
		}
		////
		if(source != null)
		{
			var isAlias = isAttributeAlias(attribute)
			if(isSourceAlias(source))
				if(isAlias)
					return getSourcenameFromAlias(source) + '.' + getAttributenameFromAlias(attribute)
				else
					return getSourcenameFromAlias(source) + '.' + attribute
			else
				if(isAlias)
					return attribute
				else
					return source + '.' + attribute
		}
		else
		{
			attribute = attributename
			if(registry_Aggregations.contains(attribute))
	            return attribute            
	        if(registry_Expressions.keySet.contains(attribute))
	            return registry_Expressions.get(attribute)
			if(isAttributeAlias(attribute))
				return attribute
				
			var containedBySources = newArrayList	
			var usedNames = newArrayList
			for(Source source1 : querySources)
			{
			    if(!usedNames.contains(source1.name))
			    {
			        usedNames.add(source1.name)
				    var source2 = getSource(source1.name)
				    for(AttributeStruct attr : source2.attributes)
					    if(attr.attributename.equals(attribute))
					        containedBySources.add(source2)
		        }
	        }
	        if(containedBySources.size == 1)
	            return containedBySources.get(0).sourcename + '.' + attribute
		}
				
		throw new IllegalArgumentException("attribute " + attribute + " could not be resolved" )		
	}
	
	//TODO Implement a method to parse an attribute instead of using the same sequence in different methods
	// e.g.: attribute.split('\\.') to check if the attribute is formed like souce1.attr1
	
	//TODO Uniform methods with dispatch methods
	def public String getAttributename(Attribute attribute, String srcname)
	{
		return getAttributename(attribute.name, srcname)
	}
	
	def public String getAttributename(Attribute attribute)
	{
		return getAttributename(attribute.name)
	}
	
	def public String getAttributename(String attribute)
	{
		return getAttributename(attribute, null)
	}
	
	def public String getSimpleAttributename(String attribute)
	{
		return getAttributename(attribute).split("\\.").get(1)	
	}
	
	def public List<String> getAliasFromAttributename(String name, String source)
	{
		return getSource(source).findbyName(name).aliases
	}
	
	/** Returns all {@link Attribute} elements to the corresponding source. */
	def public List<String> getAttributeNamesFrom(String srcname) 
	{
 		for(SourceStruct source : registry_Sources)
			if(source.sourcename.equals(srcname))
			{
				return source.attributes.stream.map(e|e.attributename).collect(Collectors.toList);
			}
			else if(source.aliases.contains(srcname))
			{
				return source.attributes.stream.map(e|e.attributename).collect(Collectors.toList)
			}
	}
}