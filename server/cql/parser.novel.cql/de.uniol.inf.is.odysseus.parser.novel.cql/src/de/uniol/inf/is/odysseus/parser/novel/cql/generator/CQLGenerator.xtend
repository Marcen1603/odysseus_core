/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.generator

import de.uniol.inf.is.odysseus.core.sdf.schema.SDFAttribute
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFDatatype
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.And
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeRef
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Create_Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Expression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Or
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Select_Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant
import java.util.HashSet
import java.util.List
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CQLGenerator extends AbstractGenerator 
{

//	@Inject extension IQualifiedNameProvider

	var Set<SDFAttribute> attributes = new HashSet
	var Map<String, SDFAttribute> map

	def void setSchema(Set<SDFSchema> s)
	{
		for(SDFSchema t : s)
		{
//			print(t)//TODO Remove after debugging
			attributes.addAll(t.attributes)
		}
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		
		var i = 0 ;
//		var ref = 
		
		
		for(e : resource.allContents.toIterable.filter(typeof(Statement)))
		{
			fsa.generateFile(
//				e.fullyQualifiedName.toString() + '.pql',
//				 i + " " + resource.URI.lastSegment.replace('.cql', '.pql'),
				""+ i++,	
				e.parseStatement()
			)
		}
	}
	
	def CharSequence parseStatement(Statement stmt)
	'''
	«switch stmt.type 
	{
	Select_Statement : parseSelect(stmt.type as Select_Statement)
	Create_Statement : parseCreate(stmt.type as Create_Statement)
	}
	»
	'''
	
	def parseCreate(Create_Statement stmt)
	{
		var args = ''
		var size = stmt.attributes.size
		for(var i = 0; i < size -1; i++)
		{
			args += "['" + stmt.attributes.get(i).name + "','" + stmt.datatypes.get(i) + "'],\n"
		}
		args += "['" + stmt.attributes.get(size - 1).name + "','" + stmt.datatypes.get(size - 1) + "']"
		'''
		«stmt.name» := ACCESS({Source = '«stmt.name»', 
		Wrapper = 'GenericPush',
		Schema = [«args»],
		transport = 'NonBlockingTcp',
		protocol = 'SizeByteBuffer',
		dataHandler ='Tuple',
		Options =[['port', '«stmt.port»'],['host', '«stmt.host»']]})
		'''
	}

	def CharSequence parseSelect(Select_Statement stmt)
	{
		predicate = ''
		if(!stmt.attributes.empty)//SELECT attr1, attr2 ...
		{
			'''
			SELECT({predicate=
			«buildPredicate(stmt.predicates.elements.get(0))»},
			«buildAccessOP(stmt.attributes, stmt.sources)»)
			'''
		}
		else// SELECT * ...
		{
			if(stmt.predicates == null)//SELECT * FROM src1, src2;
			{
				'''
				«buildAccessOP(stmt.attributes, stmt.sources)»	
				'''		
			}
			else//SELECT * FROM src1, src2 WHERE ... ;
			{ 
//				stmt.eS
				'''
				SELECT({predicate=
				«buildPredicate(stmt.predicates.elements.get(0))»},
				«buildAccessOP(stmt.attributes, stmt.sources)»)
				'''					
			}
		}
	}

	var predicate = ''
	def CharSequence buildPredicate(Expression e)
	{
		if(!e.eContents.empty)
		{
			switch e
			{
				Or:
				{
					buildPredicate(e.left)
					predicate += '||'
					buildPredicate(e.right)
				}
				And:
				{
					buildPredicate(e.left)
					predicate += '&&'
					buildPredicate(e.right)
				}  
				Equality:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)
				}
				Comparision:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)	
				}
				Plus:
				{
					buildPredicate(e.left)
					predicate += '+'
					buildPredicate(e.right)
				}
				Minus:
				{
					buildPredicate(e.left)
					predicate += '-'
					buildPredicate(e.right)					
				}
				MulOrDiv:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)
				}
				NOT:
				{
					predicate += '!'
					buildPredicate(e.expression)
				}
				Bracket:
				{
					predicate += '(' 
					buildPredicate(e.inner)
					predicate += ')' 
				}
				AttributeRef:
				{
					predicate += e.value.name
				}  	 
			}
		} 
		else
		{
			var str = ''
			switch e
			{
				IntConstant: 	str = e.value + ''
				FloatConstant:  str = e.value
				StringConstant: str = e.value
				BoolConstant: 	str = e.value
	
			}
			predicate += str
		}
	}
	
	
	//TODO Implement buildProjectOP
	def CharSequence buildProjectOP(Select_Statement stmt)
	{
		'''
		PROJECT({attributes = [«»]}, )
		'''
	}
	
	def CharSequence buildAccessOP(List<Attribute> attr, List<Source> src)
	{
		'''
		ACCESS
		(
			{	
				source      = 'Source'
				wrapper     = 'GenericPush'
				transport   = 'TCPClient'
				dataHandler = 'Tuple'
				schema = [«buildSchema(attr, src)»]
			}
		)
		'''
	}

	//TODO Refactore	
	def CharSequence buildSchema(List<Attribute> attr, List<Source> src)
	{
		var str = '\n'
		var i = 0
		var SDFDatatype type
		var String alias
		if(attr.size == 0)
		{
			for(s : src)
				for(a : attributes)
				{
					if(a.sourceName.equals(s.name.replace("FROM","")))//TODO Currently hacked
					{
						alias = a.attributeName
						type = a.datatype
						str += "['" + alias + "', '" + type.toString + "'],\n"
					}
				}
			str = str.substring(0, str.length - 2)
		}
		else
		{
			while(i < attr.size)
			{
				alias = attr.get(i).name 
				for(a : attributes)
				{
					if(a.attributeName.equals(alias))
					{
						type = a.datatype
						if(i != attr.size - 1)
							str += "['" + alias + "', '" + type.toString + "'],\n"
						else
							str += "['" + alias + "', '" + type.toString + "']\n"
					}
				}
				i++ 								
			}
		}
		str
	}	
}