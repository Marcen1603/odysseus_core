/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.generator

import de.uniol.inf.is.odysseus.core.sdf.schema.SDFAttribute
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFDatatype
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.And
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeRef
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Create_Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Expression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionsModel
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Or
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Select_Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.List
import java.util.Map
import java.util.Set
import java.util.stream.Collectors
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGenerator2
import org.eclipse.xtext.generator.IGeneratorContext
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ChannelFormat

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CQLGenerator implements IGenerator2
{

//	@Inject extension IQualifiedNameProvider

	var Set<SDFAttribute> outerattributes = new HashSet
	var Set<SDFAttribute> innerattributes = new HashSet
	var Set<SDFSchema>    innerschema;
	var Set<SDFSchema>    outerschema;
	
	var Map<String, Map<String, String>> accessoperator = new HashMap
	
	var static List<String> sources = new ArrayList

	def void clear()
	{
		outerattributes.clear()
		innerattributes.clear()
		sources.clear()
		accessoperator.clear()
		count_ID = 0
	}

	def void setOuterschema(Set<SDFSchema> s)
	{
		outerschema = s
		for(SDFSchema t : s)
		{
//			print(t)//TODO Remove after debugging
			outerattributes.addAll(t.attributes)
		}
	}

	def void setInnerschema(Set<SDFSchema> s)
	{
		innerschema = s
		for(SDFSchema t : s)
		{
//			print(t)//TODO Remove after debugging
			innerattributes.addAll(t.attributes)
		}
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		var i = 0 ;
		for(e : resource.allContents.toIterable.filter(typeof(Statement)))
		{
			fsa.generateFile(
//				e.fullyQualifiedName.toString() + '.pql',
//				 i + " " + resource.URI.lastSegment.replace('.cql', '.pql'),
				""+ i++,	
				e.parseStatement()
			)
		}
	}
	
	def CharSequence parseStatement(Statement stmt)
	'''
	«switch stmt.type 
	{
	Select_Statement : parseSelectStatement(stmt.type as Select_Statement, false)
	Create_Statement : parseCreateStatement(stmt.type as Create_Statement, false)
	}
	»
	'''
		
	def CharSequence buildAccessOP(ChannelFormat channel)
	{
		
		var wrapper     = 'GenericPush'
		var protocol    = 'SizeByteBuffer'
		var transport   = 'NonBlockingTcp'
		var dataHandler = 'Tuple'		
		var args 		= generateKeyValueString(
							channel.stream.attributes.map[e|e.name],
							channel.stream.datatypes.map[e|e.value]
						  )
						  
		return '''ACCESS
				  (
					{	  
						source      = '«getKeyword(0) +  channel.stream.name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						schema = [«args»],
						options =[['port', '«channel.stream.port»'],
								  ['host', '«channel.stream.host»']]
					 }
				   )'''
	}	
		
	def CharSequence parseCreateStatement(Create_Statement stmt, boolean isView)
	{
		var symbol1 = if(isView) ' := ' else ' = '
		var ch = stmt.channelformat
		if(ch!= null)
		{
			if(ch.stream != null)
			{
				return '''«ch.stream.name + symbol1»«buildAccessOP(ch)»'''
			}
			if(ch.view.select != null) 
			{
				var str = parseSelectStatement(ch.view.select, true).toString
				return str.replace(str.substring(0, str.indexOf(":")), ch.view.name + " ")
			}
			else					   
			{ 
				var str = parseCreateStatement(ch.view.create, true).toString
				return str.replace(str.substring(0, str.indexOf(":")), ch.view.name + " ")
			}
		}
		else
		{
			var af = stmt.accessframework
		 	var type = ''
			switch af.type
			{
				case "STREAM":
					type = "ACCESS"
				case "SINK":
					type = "SENDER"	
			}
			var args = ''
			var bool = type.equals('ACCESS')
			if(bool)
			{
				args = generateKeyValueString(
					af.attributes.map[e|e.name],
					af.datatypes.map[e|e.value]
				)
			}
			var options = generateKeyValueString(
				af.keys,
				af.values
			)
			
			if(bool)
			{
				sources.add(af.name)
				registerAO(af.name, af.wrapper, af.protocol, af.transport, af.datahandler)
			} 
			return 
			'''
			«af.name + symbol1»«type» (
			{«IF bool»source ='«getKeyword(0) + af.name» ',«ENDIF»
			«IF !bool»sink='«getKeyword(2) +  af.name»'«ENDIF»
			wrapper='«af.wrapper»',
			protocol='«af.protocol»',
			transport='«af.transport»',
			dataHandler='«af.datahandler»',
			«IF bool»schema=[«args»],«ENDIF»
			options=[«options»]})
			'''	
		}
	}

	def String getWrapper(String name)
	{
		if(accessoperator.keySet.contains(name))
			return accessoperator.get(name).get('wrapper')
		else 
			return 'NO_WRAPPER_FOUND'
	}
	
	def String getProtocol(String name)
	{
		if(accessoperator.keySet.contains(name))
			return accessoperator.get(name).get('protocol')
		else 
			return 'NO_PROTOCOL_FOUND'
	}	

	def String getTransport(String name)
	{
		if(accessoperator.keySet.contains(name))
			return accessoperator.get(name).get('transport')
		else 
			return 'NO_TRANSPORT_FOUND'
	}

	def String getDataHandler(String name)
	{
		if(accessoperator.keySet.contains(name))
			return accessoperator.get(name).get('dataHandler')
		else 
			return 'NO_DATAHANDLER_FOUND'
	}	

	def registerAO(String name, String wrapper, String protocol, String transport, String dataHandler)
	{
		var Map<String, String> m = new HashMap
		m.put('wrapper', wrapper)
		m.put('protocol', protocol)
		m.put('transport', transport)
		m.put('dataHandler', dataHandler)
		accessoperator.put(name, m)
	}

	val static CharSequence[] keywords = #['input_', 'window_', 'output_', 'select_']

	def static CharSequence getKeyword(int i)
	{
		if(i >= keywords.length || i < 0)
			return 'WRONG_INDEX_NO_KEYWORD'
		return keywords.get(i);
	}

	/**
	 * Builds a join operator with a given {@link ExpressionsModel} and list of {@link Source}
	 * elements. If the predicate is null, there will be no join predicate in the operation.
	 * If the list contains only one source, an {@link IllegalArgumentException} will be thrown.
	 */
	def CharSequence buildJoin(ExpressionsModel predicate, List<Source> srcs)
	{
		if(srcs.size < 2)
		{ 
			throw new IllegalArgumentException(
				"Invalid number of source elements: There have to be at least two elements"
			)
		}
		var List<Source> list = srcs
		var src = list.get(0)
		if(list.size == 2)
		{
			return '''JOIN(«list.get(0).name»,«list.get(1).name»)'''
		}
		list.remove(0)
		if(predicate != null)
		{
			var predicateString = '''{predicate='«buildPredicate(predicate.elements.get(0))»'}'''
			return '''JOIN(«predicateString»,«src.name»,«buildJoin(null, list)»)'''
		}
		else { return '''JOIN(«src.name»,«buildJoin(null, list)»)''' } 	
	}

	def CharSequence parseSelectStatement(Select_Statement stmt, boolean isView)
	{
		predicate = ''
		var symbol1 = if(isView) ' := ' else ' = '
		if(stmt.predicates == null)//SELECT attr1, ... / * FROM ...;
		{
			if(!stmt.attributes.empty)//SELECT attr1, ...
			{
				if(stmt.sources.size == 1)//.. FROM src1;
				{
					return '''project_«getID() + symbol1»«buildProjectOP(stmt.attributes, stmt.sources.get(0))»'''										
				}
				else//.. FROM src1, src2, ...;
				{
					return '''project_«getID() + symbol1»«buildProjectOP(stmt.attributes, buildJoin(null, stmt.sources))»'''	
				}
			}
			else//SELECT * ..
			{
				if(stmt.sources.size == 1)//.. FROM src1;
				{
					return '''project_«getID() + symbol1»«buildProjectOP(null, stmt.sources.get(0))»'''												
				}
				else//.. FROM src1, src2, ...;
				{
					return '''join_«getID() + symbol1»«buildJoin(null, stmt.sources)»'''
				}				
			}
		}
		else
		{ 
			if(stmt.sources.size > 1 && !stmt.attributes.empty)// SELECT * FROM src1 / src1, .. src2 WHERE ...;
			{
				return '''select_«getID() + symbol1»«buildSelectOP(stmt.predicates, buildProjectOP(stmt.attributes, buildJoin(null, stmt.sources)))»'''	
			}// SELECT * FROM src1, src2, ... WHERE ...; | SELECT attr1, ... FROM src1 / src1, ... WHERE ...;
			return '''select_«getID() + symbol1»«buildSelectOP(stmt.predicates, stmt.sources)»'''// are the same!!
		}
	}

	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a list of {@link Source} elements. If the list contains more then one element,
	 * the {@link CQLGenerator#buildJoin(..)} method will be called to define the input
	 * operator.
	 */
	def CharSequence buildSelectOP(ExpressionsModel predicate, List<Source> srcs)
	{
		if(srcs.size == 1)
			return '''SELECT({predicate='«buildPredicate(predicate.elements.get(0))»'},«srcs.get(0).name»)'''
		return '''SELECT({predicate='«buildPredicate(predicate.elements.get(0))»'},«buildJoin(null, srcs)»)'''
	}

	/**
	 * Builds a select operator with a given {@link ExpressionsModel} object as predicate
	 * and a char sequence to define the input operator. 
	 */
	def CharSequence buildSelectOP(ExpressionsModel predicate, CharSequence operator)
	{
		return '''SELECT({predicate='«buildPredicate(predicate.elements.get(0))»'},«operator»)'''
	}

	var static count_ID = 0

	def CharSequence getID()
	{
		count_ID++
		return count_ID.toString
	}

	/**
	 * Builds a project operator with a list of {@link Attribute} and {@link Source}
	 * element. If the list is null, all attributes to the corresponding source will be
	 * added to the attributes parameter.
	 */
	def CharSequence buildProjectOP(List<Attribute> attributes, Source src)
	{
		if(src == null) { throw new NullPointerException("Given source was null") }
		if(attributes == null)
		{
			return '''PROJECT(
						{
							attributes=[«generateListString(getAttributeNamesFrom(src.name))»]
						},«src.name»)'''
		}
		return '''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|e.name).collect(Collectors.toList))»]
				  	},«src.name»)'''
	}
	
	/**
	 * Builds a project operator with a list of {@link Attribute} and char sequence
	 * to define the input operator.
	 */
	def CharSequence buildProjectOP(List<Attribute> attributes, CharSequence operator)
	{
		return '''PROJECT(
				  	{
				  		attributes=[«generateListString(attributes.stream.map(e|e.name).collect(Collectors.toList))»]
				  	},«operator»)'''
	}
	
	/**
	 * Returns all {@link Attribute} elements to the corresponding source.
	 */
	def getAttributeNamesFrom(String src) 
	{
		/*
		 * A source is either from outerattributes» or from innerattributes.
		 * Hence, there should be no duplicated entries while iterating 
		 * through both lists.
		 */
		var List<String> l = new ArrayList 
		for(SDFAttribute a : outerattributes)
			if(a.sourceName.equals(src))
				l.add(a.attributeName)
		for(SDFAttribute a : innerattributes)
			if(a.sourceName.equals(src))
				l.add(a.attributeName)
		return l
	}
	
	var predicate = ''
	/**
	 * Builds a predicate string from a given {@link Expression}.
	 */
	def CharSequence buildPredicate(Expression e)
	{
		if(!e.eContents.empty)
		{
			switch e
			{
				Or:
				{
					buildPredicate(e.left)
					predicate += '||'
					buildPredicate(e.right)
				}
				And:
				{
					buildPredicate(e.left)
					predicate += '&&'
					buildPredicate(e.right)
				}  
				Equality:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)
				}
				Comparision:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)	
				}
				Plus:
				{
					buildPredicate(e.left)
					predicate += '+'
					buildPredicate(e.right)
				}
				Minus:
				{
					buildPredicate(e.left)
					predicate += '-'
					buildPredicate(e.right)					
				}
				MulOrDiv:
				{
					buildPredicate(e.left)
					predicate += e.op
					buildPredicate(e.right)
				}
				NOT:
				{
					predicate += '!'
					buildPredicate(e.expression)
				}
				Bracket:
				{
					predicate += '(' 
					buildPredicate(e.inner)
					predicate += ')' 
				}
				AttributeRef:
				{
					predicate += e.value.name
				}  	 
			}
		} 
		else
		{
			var str = ''
			switch e
			{
				IntConstant: 	str = e.value + ''
				FloatConstant:  str = e.value
				StringConstant: str = "'" + e.value + "'"
				BoolConstant: 	str = e.value
	
			}
			predicate += str
		}
	}
	
//	def CharSequence buildAccessOP(List<Attribute> attr, List<Source> src, boolean b)//TODO Refactore
//	{
//		var str = ''
//		var bool = false
//		for(var i = 0; i < src.size; i++)
//		{
//			var name = src.get(i).name
//			
//			for(a : outerattributes)
//			{
//				if(a.sourceName.equals(name))
//				{
//					str += name
//					if(i != src.size - 1) { str += ',' }
//					bool = true
//				}
//			}
//		
//			if(!bool)
//			{
//				if(sources.contains(name))
//				{
//					str += name
//					if(i != src.size - 1) { str += ',' }
//				}
//				else
//				{
//					
//					if(b) str += name + ":= "			
//					str +=
//					"ACCESS
//					(
//						{	
//							source = '"+getKeyword(0) + name+"',
//							wrapper = '"+getWrapper(name)+"',
//							protocol = '"+getProtocol(name)+"',
//							transport = '"+getTransport(name)+"',
//							dataHandler = '"+getDataHandler(name)+"',
//							schema = ["+buildSchema(attr, src.get(i))+"]
//						}
//					)	
//					"
//					+buildWindowOP(src.get(i), name)
//					
//					if(i != src.size - 1) { str += ',' }
//					
//					sources.add(name)
//				}
//			}
//			bool = false
//		}
		
//		var name = src.get(src.size - 1).name
//		for(a : outerattributes)
//		{
//			if(a.sourceName.equals(name))
//			{
//				str += name
//				bool = true
//			}
//		}
//		
//		if(!bool)
//		{
//			if(sources.contains(name))
//			{
//				str += name 		
//			}
//			else
//			{
//				if(b) str += name + ":= "
//				str +=
//				"ACCESS
//				(
//					{	
//						source = '"+getKeyword(0) + name+"',
//						wrapper = '"+getWrapper(name)+"',
//						protocol = '"+getProtocol(name)+"',
//						transport = '"+getTransport(name)+"',
//						dataHandler = '"+getDataHandler(name)+"',
//						schema = ["+buildSchema(attr, src.get(src.size - 1))+"]
//					}
//				)
//				"
//				+buildWindowOP(src.get(src.size - 1), name)
//				sources.add(name)
//			}
//		}				
//		return str
//	}

	def CharSequence buildWindowOP(Source w, CharSequence name)
	{
	
		if(w.time != null)
		{
			'''
			«getKeyword(1)»«name» := TIMEWINDOW
			({size = [«w.time.size», '«w.time.unit»']},
			«getKeyword(0)»«name»
			)
			'''
		}
		else if(w.tuple != null)
		{
			var var1 = if(w.tuple.advance_size != 0) w.tuple.advance_size else 1
			if(w.tuple.partition_attribute == null)
			{
				'''
				«getKeyword(1)»«name» := ELEMENTWINDOW
				(
					{size = «w.tuple.size»,
					advance = «var1»
					},
				«getKeyword(0)»«name»
				)
				'''
			}
			else
			{
				'''
				«getKeyword(1)»«name» := ELEMENTWINDOW
				(
					{size = «w.tuple.size»,
					advance = «var1»,
					partition = '«w.tuple.partition_attribute.name»'
					},
				«getKeyword(0)»«name»
				)
				'''
			}			
		}
		else if(w.unbounded != null)
		{
			''''''
		}
		else
		{
			''''''
		}
	}
		
	def String generateKeyValueString(List<String> l1, List<String> l2)
	{
		var args = ''
		var size = l1.size
		for(var i = 0; i < size -1; i++)
		{
			args += "['" + l1.get(i)+ "','" + l2.get(i) + "'],\n"
		}
		args += "['" + l1.get(size - 1) + "','" + l2.get(size - 1) + "']"
		return args
	}
		
		
	def String generateListString(List<String> l1)
	{
		var args = ''
		var size = l1.size
		for(var i = 0; i < size - 1; i++)
		{
			args += "'" + l1.get(i)+"',"
		}
		args += "'" + l1.get(size - 1)+"'"
		return args
	}
		
	//TODO Refactore	
	def CharSequence buildSchema(List<Attribute> attr, Source src)
	{
		var str = '\n'
		var SDFDatatype type
		var String alias		
		if(attr.size == 0)
		{
			for(a : innerattributes)
			{
				if(a.sourceName.equals(src.name))
				{
					alias = a.attributeName
					type = a.datatype
					str += "['" + alias + "', '" + type.toString + "'],\n"
				}
			}
			str = str.substring(0, str.length - 2)
		}
		else
		{
			for(a : innerattributes)
			{
				if(a.sourceName.equals(src.name))
				{
					type = a.datatype
					str += "['" + a.attributeName + "', '" + type.toString + "'],\n"
				}
			}
			str = str.substring(0, str.length - 2)
		}
		str
	}
	
	override afterGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
	override beforeGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
}