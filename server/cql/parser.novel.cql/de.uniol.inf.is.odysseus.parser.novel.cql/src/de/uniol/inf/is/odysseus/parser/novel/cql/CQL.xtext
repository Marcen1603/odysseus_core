grammar de.uniol.inf.is.odysseus.parser.novel.cql.CQL with org.eclipse.xtext.common.Terminals

generate cQL "http://www.uniol.de/inf/is/odysseus/parser/novel/cql/CQL"

Model: statements+=(Statement)*;
	
Statement:	
	(type=Select | type=Create | type=StreamTo | type=Drop) 
	(';')?
;
 
Select:
	name='SELECT'
	(distinct='DISTINCT')?
	( '*' |
		( 
			(attributes+=Attribute | aggregations+=Aggregation)+  
			& (',' attributes+=Attribute)* 
			& (',' aggregations+=Aggregation)*
		)
	)
	('FROM' sources+=Source+ (',' sources+=Source)*)
	('WHERE' predicates=ExpressionsModel)?
	('GROUP' 'BY' order+=Attribute+ (',' order+=Attribute)*)? //ordering+=Attribute+ ('ASC' | 'DESC')?)?)
	('HAVING' having=ExpressionsModel)?
;

NestedStatement returns Select: '(' Select ')' ;

Source: 
	(
		name=ID
		(	
			'[' 
			(
				unbounded=Window_Unbounded|
				time=Window_Timebased|
				tuple=Window_Tuplebased
			)
			']'
		)?
		|
		(
			nested=NestedStatement
		)
	)
	('AS' alias=Alias)?
;

Attribute: 
	name=ID
	('AS' alias=Alias)?
;
 
AttributeWithoutAlias returns Attribute: 
	name=ID
; 

AttributeWithNestedStatement:
	value=AttributeWithoutAlias
	'IN'
	nested=NestedStatement
; 
 
Aggregation:
	name=ID
	'(' attribute=AttributeWithoutAlias ')'
	('AS' alias=Alias)?
;

Alias:
	name=ID
;  

//SelectWithoutWhere returns Select:
//	name='SELECT'
//	(distinct='DISTINCT')?
//	( '*' |
//		( 
//			(attributes+=Attribute | aggregations+=Aggregation)+  
//			& (',' attributes+=Attribute)* 
//			& (',' aggregations+=Aggregation)*
//		)
//	)
//	('FROM' sources+=Source+ (',' sources+=Source)*)
//	'GROUP' 'BY' order+=Attribute+ (',' order+=Attribute) //ordering+=Attribute+ ('ASC' | 'DESC')?)?
//	'HAVING' having=ExpressionsModel
//;
//
//SelectWithoutWhere returns Select:
//	name='SELECT'
//	(distinct='DISTINCT')?
//	( '*' |
//		( 
//			(attributes+=Attribute | aggregations+=Aggregation)+  
//			& (',' attributes+=Attribute)* 
//			& (',' aggregations+=Aggregation)*
//		)
//	)
//	('FROM' sources+=Source+ (',' sources+=Source)*)
//	'GROUP' 'BY' order+=Attribute+ (',' order+=Attribute) //ordering+=Attribute+ ('ASC' | 'DESC')?)?
//	'HAVING' having=ExpressionsModel
//;
//
//SelectWithoutGroupBy returns Select:
//	name='SELECT'
//	(distinct='DISTINCT')?
//	( '*' |
//		( 
//			(attributes+=Attribute | aggregations+=Aggregation)+  
//			& (',' attributes+=Attribute)* 
//			& (',' aggregations+=Aggregation)*
//		)
//	)
//	('FROM' sources+=Source+ (',' sources+=Source)*)
//	'WHERE' predicates=ExpressionsModel
//;
//
//SelectWithoutWhereAndGroupBy returns Select:
//	name='SELECT'
//	(distinct='DISTINCT')?
//	( '*' |
//		( 
//			(attributes+=Attribute | aggregations+=Aggregation)+  
//			& (',' attributes+=Attribute)* 
//			& (',' aggregations+=Aggregation)*
//		)
//	)
//	('FROM' sources+=Source+ (',' sources+=Source)*)
//;


//Order:
//	attribute=Attribute
//	direction=('ASC'|'DESC')
//;


Create:
	name=('CREATE'|'ATTACH') (channelformat=ChannelFormat|accessframework=AccessFramework)
;

AccessFramework:
	type=('STREAM'|'SINK')
	name = ID
	'('
	attributes+= Attribute+ 
	datatypes+= DataType+
	(',' attributes+=Attribute datatypes+= DataType)*
	')'
	'WRAPPER' wrapper=STRING
	'PROTOCOL' protocol=STRING
	'TRANSPORT' transport=STRING
	'DATAHANDLER' datahandler=STRING
	'OPTIONS' 
		'(' 
			(keys+=STRING values+=STRING)+ (',' keys+=STRING values+=STRING)?
		')'
;

ChannelFormat: (stream=ChannelFormatStream|view=ChannelFormatView);

ChannelFormatStream:
	'STREAM'
	name = ID
	'('
	attributes+= Attribute+ 
	datatypes+= DataType+
	(',' attributes+=Attribute datatypes+= DataType)*
	')'
	'CHANNEL'//TODO Add FILE as possible parameter --> and even more ..
	host=ID
	':'
	port=INT
;

ChannelFormatView:
	'VIEW' 
	name=ID
	'FROM'
	'('
	(select=Select) (';')?
	')'
;

StreamTo:
	'STREAM' 'TO'
	name=ID
	(statement=Select|inputname=ID)
;

Drop:
	'DROP'
	(name='SINK'|name='STREAM')
	('IF' 'EXISTS')?
;

Window_Unbounded:  
	'UNBOUNDED'
;

Window_Timebased: 
	'SIZE' size=INT unit=ID
	('ADVANCE' advance_size=INT advance_unit=ID)?
	'TIME'
;

Window_Tuplebased://TODO PARTITION BY only if a GROUP BY clause exists
	'SIZE' size=INT
	('ADVANCE' advance_size=INT)?
	'TUPLE'
	('PARTITION' 'BY' partition_attribute=Attribute)?
;

// Expression DSL ///////////////////////////////////////////////////////
terminal FLOAT_NUMBER:  INT '.' INT ;

ExpressionsModel: {ExpressionsModel} elements+=Expression;

Expression: Or;

Or returns Expression:
	And ({Or.left=current} 'OR' right=And)*
;

And returns Expression:
	Equalitiy ({And.left=current} 'AND' right=Equalitiy)*
;

Equalitiy returns Expression:
	Comparison (
		{Equality.left=current} op=('==' | '!=')
		right=Comparison	
	)*
;

Comparison returns Expression:
	PlusOrMinus (
		{Comparision.left=current} op=('>=' | '<=' | '<' | '>')
		right=PlusOrMinus
	)*
;

PlusOrMinus returns Expression:
	MulOrDiv (
		({Plus.left=current} '+' | {Minus.left=current} '-')
		right=MulOrDiv
	)*
;

MulOrDiv returns Expression:
	Primary (
		{MulOrDiv.left=current} op=('*' | '/')
		right=Primary
	)*
;

Primary returns Expression:
	({Bracket} '(' inner=Expression ')') |
	{NOT} 'NOT' expression=Primary |
	Atomic
;

Atomic returns Expression:
//	{NumberConstant} (value=INT | value=INT '.' INT) |
	{IntConstant} value=INT |
	{FloatConstant} value=FLOAT_NUMBER |
	{StringConstant} value= STRING |
	{BoolConstant} value=('TRUE' | 'FALSE') |
	//TODO A SELECT * query offers no reference for an attribute.
	//At the moment is no actual referencing possible!
	{AttributeRef} (value=AttributeWithoutAlias | value=AttributeWithNestedStatement)
;

//TODO have to dynamic -> use scope provider
DataType: 
	value=('INTEGER' | 'DOUBLE' | 'FLOAT' | 'STRING' | 'BOOLEAN' 
	| 'STARTTIMESTAMP' | 'ENDTIMESTAMP' 
);