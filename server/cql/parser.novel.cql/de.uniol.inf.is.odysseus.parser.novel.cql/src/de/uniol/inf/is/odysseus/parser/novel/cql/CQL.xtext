grammar de.uniol.inf.is.odysseus.parser.novel.cql.CQL with org.eclipse.xtext.common.Terminals

generate cQL "http://www.uniol.de/inf/is/odysseus/parser/novel/cql/CQL"

Model: 
	((components+=(Statement|Command)) (';')?)*
;
	
terminal ID: ('a'..'z'|'A'..'Z'|'_'|':'|'$'|'{'|'}') ('a'..'z'|'A'..'Z'|'_'|':'|'$'|'{'|'}'|'0'..'9')*;	
terminal FLOAT:  INT '.' INT;
BOOLEAN: ('FALSE'|'TRUE');
//terminal BIT: ('0'|'1');
//terminal BYTE: BIT BIT BIT BIT BIT BIT BIT BIT;

//terminal VECTOR_INT: '[' (INT)+ (',' INT)* (';' (INT)+ (',' INT)*)*']';
//terminal VECTOR_FLOAT: '[' (FLOAT)+ (',' FLOAT)* (';' (FLOAT)+ (',' FLOAT)*)* ']';
//terminal VECTOR_BOOLEAN: '[' (BOOLEAN)+ (',' BOOLEAN)* (';' (BOOLEAN)+ (',' BOOLEAN)*)* ']';
//terminal VECTOR_BIT: '[' (BIT)+ (',' BIT)* (';' (BOOLEAN)+ (',' BOOLEAN)*)* ']';
//terminal VECTOR_BYTE: '[' (BYTE)+ (',' BYTE)* (';' (BYTE)+ (',' BYTE)*)* ']';

Statement:
	type=(Select
	| Create
	| StreamTo)
;
 
Command :
	type=(DropStream
	| UserManagement
	| RightsManagement
	| RoleManagement
	| CreateDataBaseGenericConnection
	| CreateDataBaseJDBCConnection
	| DropDatabaseConnection)
; 
 
Select:
	{Select}
	'SELECT'
	(distinct='DISTINCT')?
	( '*' |  (arguments+=SelectArgument+  ( ',' arguments+=SelectArgument) *))
	('FROM' sources+=Source+ (',' sources+=Source)*)
	('WHERE' predicates=ExpressionsModel)?
	('GROUP' 'BY' order+=Attribute+ (',' order+=Attribute)*)?
	('HAVING' having=ExpressionsModel)?
;

InnerSelect:
	'(' select=Select ')'
;

InnerSelect2:
	select=Select
;

SelectArgument: (attribute=Attribute | expression=SelectExpression);

Source: 
	(SimpleSource | NestedSource)
;

SimpleSource returns Source:
	{SimpleSource}
	name=QualifiedSourcename (window=WindowOperator)? ('AS' alias=Alias)?
;

NestedSource returns Source:
	{NestedSource}
	statement=InnerSelect 'AS' alias=Alias
;

QualifiedSourcename:
	ID
;

Attribute: 
	name=QualifiedAttributename
	('AS' alias=Alias)?
;
 
AttributeWithoutAliasDefinition returns Attribute: 
	name=QualifiedAttributename
; 

QualifiedAttributename:
	(ID 
		| QualifiedSourcename '.' ID 
		| QualifiedSourcename '.' '*'
	)
;

AttributeWithNestedStatement:
	value=AttributeWithoutAliasDefinition
	'IN'
	nested=InnerSelect
;  

//QuantificationPredicate:
//	ExistPredicate
//;
//
//ExistPredicate returns QuantificationPredicate:
//	{ExistPredicate}
//	'EXISTS' statement=NestedStatement	
//;
//
//AnyPredicate returns QuantificationPredicate:
//	{ExistPredicate}
//	'ANY' statement=NestedStatement	
//;

//Operators for predicates and expressions
AndOperator: 'AND' ;
OrOperator: 'OR';
EQUALITIY_OPERATOR: ('=' | '!=') ;
COMPARE_OPERATOR: ('>=' | '<=' | '<' | '>') ;
ARITHMETIC_OPERATOR:
	ADD_OPERATOR
	| MINUS_OPERATOR 
	| MUL_OR_DIV_OPERATOR 
	| EXPONENT_OPERATOR; 
EXPONENT_OPERATOR: '^' ;
MUL_OR_DIV_OPERATOR: ('*' | '/') ;
ADD_OPERATOR: '+' ;
MINUS_OPERATOR: '-' ;

SelectExpression:
	((expressions+=ExpressionComponent
	(operators+=ARITHMETIC_OPERATOR
	expressions+=(ExpressionComponent|ExpressionComponentAsAttribute))*)
	|(expressions+=ExpressionComponentAsAttribute
		(operators+=ARITHMETIC_OPERATOR
		expressions+=(ExpressionComponent|ExpressionComponentAsAttribute))+))
	('AS' alias=Alias)?//TODO Add SelectExpression without an alias
;

SelectExpressionOnlyWithAttribute returns SelectExpression:
	expressions+=ExpressionComponentAsAttribute
;

//Is either a map function or an aggregation function. This depends 
//on the given name and is decided by the generator on runtime. Also
//checked is that an aggregation is no part of a select expression like
//SELECT attr1 + 10 - SUM(attr1) FROM.., but a select expression can be 
//a part of an aggregation like AVG(attr1 + DolToEur(attr2)).//TODO Not working currently
Function returns ExpressionComponent:
	{Function}
	name=ID
	'('
	value=(SelectExpression|SelectExpressionOnlyWithAttribute)
	')'
;

//Determines the structure of a component of a select expression
ExpressionComponent:
	value=(Function
		| AtomicWithoutAttributeRef)
;

ExpressionComponentAsAttribute returns ExpressionComponent:
	{ExpressionComponentAsAttribute}
	value=AttributeWithoutAliasDefinition
;

SetOperator:
	left=Select
	name=('UNION'|'DIFFERENCE'|'INTERSECTION')
	right=Select
;

Alias:
	name=ID
;  

AccessFramework:
	'WRAPPER' wrapper=STRING
	'PROTOCOL' protocol=STRING
	'TRANSPORT' transport=STRING
	'DATAHANDLER' datahandler=STRING
	'OPTIONS' '('(keys+=STRING values+=STRING)+ (',' keys+=STRING values+=STRING)?')'
;

SchemaDefinition:
	name=ID
	'('
	arguments+=ID arguments+=ID
	(',' arguments+=ID arguments+=ID)*
	')'
;

Create:
	{Create}
	('CREATE'|'ATTACH')
	type=('STREAM'|'SINK'|'VIEW')
	create=(CreateAccessFramework
			|CreateChannelFrameworkViaPort
			|CreateChannelFormatViaFile
			|CreateDatabaseStream
			|CreateDatabaseSink
			|CreateView)
	
;

CreateAccessFramework:
	attributes=SchemaDefinition
	pars=AccessFramework
;

CreateChannelFrameworkViaPort:
	attributes=SchemaDefinition
	'CHANNEL' host=ID ':' port=INT
;

CreateChannelFormatViaFile:
	attributes=SchemaDefinition
 	'FILE' filename=STRING 'AS' type=ID
;

CreateDatabaseStream:
	attributes=SchemaDefinition
	'DATABASE'
	database=ID
	'TABLE'
	table=ID
	('EACH'
	 size=INT
	 unit=ID)?
;

CreateDatabaseSink:
	name=ID
	'AS'
	'DATABASE'
	database=ID
	'TABLE'
	table=ID
	('AND' option=('DROP'|'TRUNCATE'))?
;

CreateView:  
	name=ID 
	'FROM' 
	select=InnerSelect
;

CreateDataBaseJDBCConnection returns Command:
	{CreateDataBaseConnectionJDBC}
	'CREATE'
	'DATABASE'
	'CONNECTION'
	name=ID
	'JDBC'
	server=ID
;

CreateDataBaseGenericConnection returns Command:
	{CreateDataBaseConnectionGeneric}
	'CREATE'
	'DATABASE'
	'CONNECTION'
	name=ID
	'AS'
	driver=ID
	'TO'
	source=ID
	('AT'
	server=ID)?
	('WITH' 
	 'USER'
	 user=ID
	 'PASSWORD'
	 password=ID)?
;

DropDatabaseConnection returns Command:
	{DropDatabaseConnection}
	'DROP'
	'DATABASE'
	'CONNECTION'
	name=ID
;

StreamTo: 
	{StreamTo}
	'STREAM' 
	'TO' 
	name=ID 
	(statement=InnerSelect2|inputname=ID)
;

DropStream returns Command:
	{DropStream}
	'DROP'
	name=('SINK'|'STREAM'|'VIEW')
	stream=ID
	(exists='IF' 'EXISTS')?
;

UserManagement returns Command:
	{UserManagement}
	name=('CREATE'|'ALTER'|'DROP')
	subject=('USER'|'ROLE'|'TENANT')
	subjectName=ID
	('IDENTIFIED' 'BY' password=STRING)?
;

RightsManagement returns Command:
	({RightsManagement} name='GRANT' 
	operations+=ID (',' operations+=ID)* ('ON' operations2+=ID (',' operations2+=ID)*)?
	'TO' user=ID)
	|({RightsManagement} name='REVOKE' 
	operations+=ID (',' operations+=ID)* ('ON' operations2+=ID (',' operations2+=ID)*)?	
	'FROM' user=ID)
;

RoleManagement returns Command:
	({RoleManagement} name='GRANT' 
	'ROLE' operations+=ID (',' operations+=ID)*
	'TO' user=ID)
	|({RoleManagement} name='REVOKE' 
	'ROLE' operations+=ID (',' operations+=ID)*	
	'FROM' user=ID)
;

WindowOperator:
	'['
	(UnboundedWindow
	| TimebasedWindow
	| TuplebasedWindow)
	']'
;

UnboundedWindow returns WindowOperator:  
	{UndboundedWindow}
	'UNBOUNDED'
;

TimebasedWindow returns WindowOperator:
	{TimebasedWindow} 
	'SIZE' size=INT unit=ID
	('ADVANCE' advance_size=INT advance_unit=ID)?
	'TIME'
;

TuplebasedWindow returns WindowOperator:
	{TuplebasedWindow}
	'SIZE' size=INT
	('ADVANCE' advance_size=INT)?
	'TUPLE'
	('PARTITION' 'BY' partition_attribute=Attribute)?
;

// Expression DSL ///////////////////////////////////////////////////////
ExpressionsModel: {ExpressionsModel} elements+=Expression;

Expression: OrPredicate;

OrPredicate returns Expression:
	AndPredicate ({OrPredicate.left=current} OrOperator right=AndPredicate)*
;

AndPredicate returns Expression:
	Equalitiy ({AndPredicate.left=current} AndOperator right=Equalitiy)*
;

Equalitiy returns Expression:
	Comparison (
		{Equality.left=current} op=EQUALITIY_OPERATOR
		right=Comparison	
	)*
;

Comparison returns Expression:
	PlusOrMinus (
		{Comparision.left=current} op=COMPARE_OPERATOR
		right=PlusOrMinus
	)*
;

PlusOrMinus returns Expression:
	MulOrDiv (
		({Plus.left=current} '+' | {Minus.left=current} '-')
		right=MulOrDiv
	)*
;

MulOrDiv returns Expression:
	Primary (
		{MulOrDiv.left=current} op=('/'|'*')
		right=Primary
	)*
;

Primary returns Expression:
	({Bracket} '(' inner=Expression ')') |
	{NOT} 'NOT' expression=Primary |
	Atomic
;

Atomic returns Expression:
	{IntConstant} value=INT 
	| {FloatConstant} value=FLOAT 
	| {StringConstant} value=STRING 
	| {BoolConstant} value=BOOLEAN
	//TODO A SELECT * query offers no reference for an attribute.
	//At the moment is no actual referencing possible!
	| {AttributeRef} (value=AttributeWithoutAliasDefinition | value=AttributeWithNestedStatement)
;

//TODO Add matrix and vector notation
AtomicWithoutAttributeRef returns Expression:
	{IntConstant} value=INT 
	| {FloatConstant} value=FLOAT 
	| {StringConstant} value=STRING 
	| {BoolConstant} value=BOOLEAN
;

AtomicWithOnlyStringConstant returns Expression:
	{StringConstant} value= STRING 
;

DataType:
//	value=('INTEGER' | 'DOUBLE' | 'LONG'| 'FLOAT' | 'STRING' | 'BOOLEAN')
	//| 'STARTTIMESTAMP' | 'ENDTIMESTAMP' 
//	|'Tuple'
//   value=('Object'|'Tuple'|'NTuple'|'Date'|'Double'|'EndTimestamp'|'EndTimestampString'|'Float'|'Integer'|'UnsignedInt16'|
//	'Long'|'StartTimestamp'|'StartTimestampString'|'Short'|'Char'|'Byte'|'BitVector'|'ByteBuffer'|'HexString'|'LIST<Object>'|
//	'LIST<String>'|'LIST<Long>'|'LIST<Integer>'|'LIST<Byte>'|'LIST<Char>'|'LIST<Float>'|'LIST<Double>'|'LIST<Date>'|'LIST<Boolean>'| 
//	'LIST<Short>'|'LIST<Tuple>'|'LIST<LIST<Object>>'|'String'|'DString'|'Document'|'MV'|'Timestamp'|'Boolean'|'Vector'|'Matrix'| 
//	'PartialAggregate'|'AvgSumPartialAggregate'|'CountPartialAggregate'|'RelationalElementPartialAggregate'|'ListPartialAggregate')
	value=ID
;
//TODO have to be dynamic -> use scope provider
//DataType: 
//	value=ID//('INTEGER' | 'DOUBLE' | 'LONG'| 'FLOAT' | 'STRING' | 'BOOLEAN' 
	//| 'STARTTIMESTAMP' | 'ENDTIMESTAMP' 
//)
//;