grammar de.uniol.inf.is.odysseus.parser.novel.cql.CQL with org.eclipse.xtext.common.Terminals

generate cQL "http://www.uniol.de/inf/is/odysseus/parser/novel/cql/CQL"

Model: statements+=Statement*;
	
Statement:  (type=Select_Statement | type=Create_Statement) (';')? ; 

//Nested_Statement: '(' Select_Statement ')' ;

// Data types //////////////////////////////////////////////////////////

Atomic returns Expression:
//	{NumberConstant} (value=INT | value=INT '.' INT) |
	{IntConstant} value=INT |
	{FloatConstant} value=FLOAT_NUMBER |
	{StringConstant} value= STRING |
	{BoolConstant} value=('TRUE' | 'FALSE') |
	{AttributeRef} value=Attribute//TODO A SELECT * query offers no reference for an attribute.
								  //At the moment is no actual referencing possible!  
;

terminal FLOAT_NUMBER:  INT '.' INT ;

Alias: 
	name=ID
;

Source: 
	name=ID
	('[' (unbounded=Window_Unbounded|time=Window_Timebased|tuple=Window_Tuplebased)']')?
;

//TODO Add more data types
DataType: 
	value=('INTEGER' | 'DOUBLE' | 'FLOAT' | 'STRING' | 'BOOLEAN' 
	| 'STARTTIMESTAMP' | 'ENDTIMESTAMP' 
);

Attribute: name=ID;
 
//TODO Validator: do not allow "Source1 AS Alias1.attr1"

enum FunctionType: SUM | ADD | MAX | MIN | COUNT | AVG | LAST | FIRST ;

//Function: functionType=FunctionType '(' value=Attribute ')' ;

// Expressions //////////////////////////////////////////////////////////

ExpressionsModel: {ExpressionsModel} elements+=Expression+;

Expression: Or;

Or returns Expression:
	And ({Or.left=current} 'OR' right=And)*
;

And returns Expression:
	Equalitiy ({And.left=current} 'AND' right=Equalitiy)*
;


//Or returns Expression:
//	And ({Or.left=current} 'OR' right=And)*
//;
//
//And returns Expression:
//	Equalitiy ({And.left=current} 'AND' right=Equalitiy)*
//;

Equalitiy returns Expression:
	Comparison (
		{Equality.left=current} op=('==' | '!=')
		right=Comparison	
	)*
;

Comparison returns Expression:
	PlusOrMinus (
		{Comparision.left=current} op=('>=' | '<=' | '<' | '>')
		right=PlusOrMinus
	)*
;

PlusOrMinus returns Expression:
	MulOrDiv (
		({Plus.left=current} '+' | {Minus.left=current} '-')
		right=MulOrDiv
	)*
;

MulOrDiv returns Expression:
	Primary (
		{MulOrDiv.left=current} op=('*' | '/')
		right=Primary
	)*
;

Primary returns Expression:
	({Bracket} '(' inner=Expression ')') |
	{NOT} 'NOT' expression=Primary |
	Atomic
;

//	Atomic (
//		{Plus.left=current} '+' | {Minus.left=current} '-' 
//		right=Atomic
//	)*

////////////////////////////////////////////////////////////////////////

Select_Statement:
	name='SELECT'
	('DISTINCT')?
	( '*' | attributes+=Attribute+ (',' attributes+=Attribute)*)
	'FROM'
	(sources+=Source+ (',' sources+=Source)*)
	('WHERE' (predicates=ExpressionsModel))?//| attribute=[Attribute] 'IN' '(' values+=Value ')'))?
//	(('ORDER' 'BY' | 'order' 'by') ordering+=[Attribute]+ ('ASC' | 'asc' | 'DESC' | 'desc')? )?
//	(('HAVING' | 'having') havingFunction=[Parameter] havingOperator=Operator havingValue=Value)?
//	';'
;

Window_Unbounded:  
	'UNBOUNDED'
;

Window_Timebased: 
	'SIZE' size=INT unit=ID
	('ADVANCE' advance_size=INT advance_unit=ID)?
	'TIME'
;

Window_Tuplebased://TODO PARTITION BY only if a GROUP BY clause exists
	'SIZE' size=INT
	('ADVANCE' advance_size=INT)?
	'TUPLE'
	('PARTITION' 'BY' partition_attribute=Attribute)?
;

Operator:
	name=ID
;

Condition:
	left=[Attribute] right=Expression |
	right=Expression left=[Attribute]
;

//Parameter:
//	Attribute //| Function
//	(('AS' | 'as') alias=ID)?
//;

Value:
	name=ID
;

Scalar_Function:
	name=ID
//	('UCASE(' | 'ucase(' | 'LCASE(' | 'lcase(' | 'MID(' | 'mid(' |
//	 'LEN(' | 'len(' | 'ROUND(' | 'round(' | 'NOW(' | 'now(' |
//	 'FORMAT(' | 'format('
//	)
;

Create_Statement:
	'CREATE' (channel=Create_Channel | accessframework=Create_AccessFramework)
;

Create_AccessFramework:
	type=('STREAM' | 'VIEW' | 'SINK')
	name = ID
	'('
	attributes+= Attribute+ 
	datatypes+= DataType+
	(',' attributes+=Attribute datatypes+= DataType)*
	')'
	'WRAPPER' wrapper=STRING
	'PROTOCOL' protocol=STRING
	'TRANSPORT' transport=STRING
	'DATAHANDLER' datahandler=STRING
	'OPTIONS' 
		'(' 
			(keys+=STRING values+=STRING)+ (',' keys+=STRING values+=STRING)?
		')'
;

Create_Channel:
	type=('STREAM' | 'VIEW')
	name = ID
	'('
	attributes+= Attribute+ 
	datatypes+= DataType+
	(',' attributes+=Attribute datatypes+= DataType)*
	')'
	'CHANNEL'
	host=ID
	':'
	port=INT
;

StreamTo:
	'STREAM' 'TO'
	name=ID
	statement=Select_Statement
;

