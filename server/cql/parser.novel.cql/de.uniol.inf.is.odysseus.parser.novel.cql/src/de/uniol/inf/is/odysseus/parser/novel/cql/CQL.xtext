grammar de.uniol.inf.is.odysseus.parser.novel.cql.CQL with org.eclipse.xtext.common.Terminals

generate cQL "http://www.uniol.de/inf/is/odysseus/parser/novel/cql/CQL"


Model: statements+=(Statement)*;
	
terminal ID: ('a'..'z'|'A'..'Z'|'_'|':'|'$'|'{'|'}') ('a'..'z'|'A'..'Z'|'_'|':'|'$'|'{'|'}'|'0'..'9')*;	
terminal FLOAT:  INT '.' INT;
	
IDOrINT:
	ID | INT
;

Statement:	//FIXME DROP has two types: Statement and Command -> causes error in detection commands while parsing!
	(type=Select | type=StreamTo | type=Drop | type=CreateStream1 | type=CreateSink1 | type=CreateStreamChannel | type=CreateStreamFile | type=CreateView) 
	(';')?
;
 
Select: // FIXME attributes, aggregations and expressions order must be recognizable
	name='SELECT'
	(distinct='DISTINCT')?
	( '*' |  (arguments+=Argument+  ( ',' arguments+=Argument) *))
	('FROM' sources+=Source+ (',' sources+=Source)*)
	('WHERE' predicates=ExpressionsModel)?
	('GROUP' 'BY' order+=Attribute+ (',' order+=Attribute)*)? //ordering+=Attribute+ ('ASC' | 'DESC')?)?)
	('HAVING' having=ExpressionsModel)?
;

NestedStatement returns Select: '(' Select ')' ;

Argument:
	(attribute=Attribute | aggregation=Aggregation | expression=SelectExpression)
;

Source: 
	name=SourceName 
	('[' (unbounded=Window_Unbounded|time=Window_Timebased|tuple=Window_Tuplebased) ']')? ('AS' alias=Alias)?
	|
	(nested=NestedStatement 'AS' alias=Alias)
;

SourceName:
	ID
;

Attribute: 
	name=AttributeName
	('AS' alias=Alias)?
;
 
AttributeWithoutAliasDefinition returns Attribute: 
	name=AttributeName
; 

AttributeName:
	(ID | SourceName '.' ID | SourceName '.' '*')
;

AttributeWithNestedStatement:
	value=AttributeWithoutAliasDefinition
	'IN'
	nested=NestedStatement
;  
 
Aggregation://TODO That is not supposed to be hard coded! 
	name=('AVG' | 'MIN' | 'MAX' | 'COUNT' | 'SUM' | 'MEDIAN' | 'FIRST' | 'LAST')
	'('(attribute=AttributeWithoutAliasDefinition | expression=SelectExpressionWithoutAliasDefinition)')'
	('AS' alias=Alias)?
;

AggregationWithoutAliasDefinition returns Aggregation:
	name=('AVG' | 'MIN' | 'MAX' | 'COUNT' | 'SUM' | 'MEDIAN' | 'FIRST' | 'LAST')
	'('(attribute=AttributeWithoutAliasDefinition) ')' 
;

ExpressionComponent:
	 (ExpressionComponentConstantOrAttribute(
	 	{ExpressionComponent.value=current}
	 ))
	 | (ExpressionComponentMapperOrConstant(
	 	{ExpressionComponent.value=current}
	 ))
;

ExpressionComponentConstantOrAttribute returns ExpressionComponent:
	(value = AtomicWithoutAttributeRef) | (value=AttributeWithoutAliasDefinition)
;

ExpressionComponentMapperOrConstant returns ExpressionComponent:
	Mapper({ExpressionComponent.value=current})
	| value = AtomicWithoutAttributeRef
;

ExpressionComponentOnlyAttribute returns ExpressionComponent:
	value=AttributeWithoutAliasDefinition
;

ExpressionComponentOnlyConstant returns ExpressionComponent:
	value=AtomicWithoutAttributeRef
;

ExpressionComponentOnlymapper returns ExpressionComponent:
	Mapper({ExpressionComponent.value=current})
;

Mapper returns ExpressionComponent://TODO That is not supposed to be hard coded! 
	{Mapper}
	name=('DolToEur')
	'('(value=SelectExpressionWithoutAliasDefinition)')'
;

SelectExpression:
	(
		( expressions+=(ExpressionComponentMapperOrConstant)
		  (operators+=('+'|'-'|'*'|'/') 
			expressions+=(ExpressionComponentConstantOrAttribute | ExpressionComponentOnlymapper)
		  )*
		)
		| (expressions+=(ExpressionComponentOnlyAttribute)
			(operators+=('+'|'-'|'*'|'/') 
			  expressions+=(ExpressionComponentConstantOrAttribute | ExpressionComponentOnlymapper)
			)+
		  )
  	)
	('AS' alias=Alias)?
;

SelectExpressionWithoutAliasDefinition returns SelectExpression:
	SelectExpressionWithOnlyAttributeOrConstant(
		(expressions+=(ExpressionComponentMapperOrConstant)
			(operators+=('+'|'-'|'*'|'/') 
				expressions+=(ExpressionComponentConstantOrAttribute | ExpressionComponentOnlymapper)
				)*
		)
		| (expressions+=(ExpressionComponentOnlyAttribute)
			(operators+=('+'|'-'|'*'|'/') 
				 expressions+=(ExpressionComponentConstantOrAttribute | ExpressionComponentOnlymapper)
				 )+
		)
	)
;

SelectExpressionWithOnlyAttributeOrConstant returns SelectExpressionWithoutAliasDefinition:
		expressions+=ExpressionComponentConstantOrAttribute 
		(operators+=('+'|'-'|'*'|'/') 
			expressions+=(ExpressionComponentConstantOrAttribute)
		)*	
;
/////
//SelectExpressionOnlyWithAttributeAndConstant returns SelectExpression:
//	(leftattribute=AttributeWithoutAliasDefinition 
//		| leftconstant=AtomicWithoutAttributeRef
//	)
//	operator=('+'|'-'|'/'|'*')
//	(innerexpression=SelectExpressionOnlyWithAttributeAndConstant2)?
//	(rightattribute=AttributeWithoutAliasDefinition 
//		| rightconstant=AtomicWithoutAttributeRef
//	)
//;
//
//SelectExpressionOnlyWithAttributeAndConstant2 returns SelectExpression:
//	(leftattribute=AttributeWithoutAliasDefinition 
//		| leftconstant=AtomicWithoutAttributeRef
//	)
//	operator=('+'|'-'|'/'|'*')
//	(innerexpression=SelectExpressionOnlyWithAttributeAndConstant2)?
//;
//
//SelectExpressionOnlyWithStringConstant returns SelectExpression:
//	leftconstant=AtomicWithOnlyStringConstant
//	operator=('+'|'-')
//	(innerexpression=SelectExpressionOnlyWithStringConstant2)?
//	rightconstant=AtomicWithOnlyStringConstant
//	('AS' alias=Alias)?
//;
//
//SelectExpressionOnlyWithStringConstant2 returns SelectExpression:
//	leftconstant=AtomicWithOnlyStringConstant
//	operator=('+'|'-')
//	(innerexpression=SelectExpressionOnlyWithStringConstant2)?
//;
//
//SelectExpressionOnlyWithAttribute returns SelectExpression:
//	leftattribute=AttributeWithoutAliasDefinition
//	operator=('+'|'-'|'/'|'*')
//	(innerexpression=SelectExpressionOnlyWithAttribute2)?
//	rightatttriute=AttributeWithoutAliasDefinition
//;
//
//SelectExpressionOnlyWithAttribute2 returns SelectExpression:
//	leftattribute=AttributeWithoutAliasDefinition
//	operator=('+'|'-'|'/'|'*')
//	(innerexpression=SelectExpressionOnlyWithAttribute2)?
//;

Alias:
	name=ID
;  

enum CreateKeyword:
	CREATE | ATTACH
;

CreateParameters:
	'WRAPPER' wrapper=STRING
	'PROTOCOL' protocol=STRING
	'TRANSPORT' transport=STRING
	'DATAHANDLER' datahandler=STRING
	'OPTIONS' '('(keys+=STRING values+=STRING)+ (',' keys+=STRING values+=STRING)?')'
;

AttributeDefinition:
	name=ID
	'('attributes+= Attribute+ datatypes+= DataType+ (',' attributes+=Attribute datatypes+= DataType)*')'
;

CreateStream1:
	keyword=CreateKeyword
	'STREAM'
	attributes=AttributeDefinition
	pars=CreateParameters
;

CreateSink1:
	keyword=CreateKeyword
	'SINK'
	attributes=AttributeDefinition
	pars=CreateParameters
;

CreateStreamChannel:
	keyword=CreateKeyword
	'STREAM'
	attributes=AttributeDefinition 
 	'CHANNEL' host=ID ':' port=INT
;

CreateStreamFile:
	keyword=CreateKeyword
	'STREAM'
	attributes=AttributeDefinition
 	'FILE' filename=STRING 'AS' type=ID
;

//Create:
//	name=('CREATE'|'ATTACH') (channelformat=ChannelFormat|accessframework=AccessFramework)
//;
//
//AccessFramework:
//	type=('STREAM'|'SINK')
//	name = ID
//	'('
//	attributes+= Attribute+ 
//	datatypes+= DataType+
//	(',' attributes+=Attribute datatypes+= DataType)*
//	')'
//	'WRAPPER' wrapper=STRING
//	'PROTOCOL' protocol=STRING
//	'TRANSPORT' transport=STRING
//	'DATAHANDLER' datahandler=STRING
//	'OPTIONS' 
//		'(' 
//			(keys+=STRING values+=STRING)+ (',' keys+=STRING values+=STRING)?
//		')'
//;
//
//ChannelFormat: (stream=ChannelFormatStream|view=ChannelFormatView);
//
//ChannelFormatStream:
//	'STREAM'
//	name = ID
//	'('
//	attributes+= Attribute+ 
//	datatypes+= DataType+
//	(',' attributes+=Attribute datatypes+= DataType)*
//	')'
//	(    'CHANNEL' (keys+=ID) ':'
//		|'FILE' (keys+=STRING) 'AS'
//	) 
//	(values+=IDOrINT)
//;

CreateView: 'VIEW' name=ID 'FROM' select=NestedStatement;

StreamTo: 'STREAM' 'TO' name=ID (statement=Select|inputname=ID);


// build generic rule for those commands

Command:
	keyword1 = ID
	keyword2 = ID
	value1   = ID
	keyword3 = ID
	value2   = ID
	(';')?
;

Drop returns Command:
	keyword1='DROP'
	keyword2=('SINK'|'STREAM')
	value1=ID
	(keyword3='IF' 'EXISTS')?
;


Window_Unbounded:  
	'UNBOUNDED'
;

Window_Timebased: 
	'SIZE' size=INT unit=ID
	('ADVANCE' advance_size=INT advance_unit=ID)?
	'TIME'
;

Window_Tuplebased://TODO PARTITION BY only if a GROUP BY clause exists
	'SIZE' size=INT
	('ADVANCE' advance_size=INT)?
	'TUPLE'
	('PARTITION' 'BY' partition_attribute=Attribute)?
;

// Expression DSL ///////////////////////////////////////////////////////
ExpressionsModel: {ExpressionsModel} elements+=Expression;

Expression: Or;

Or returns Expression:
	And ({Or.left=current} 'OR' right=And)*
;

And returns Expression:
	Equalitiy ({And.left=current} 'AND' right=Equalitiy)*
;

Equalitiy returns Expression:
	Comparison (
		{Equality.left=current} op=('=' | '!=')
		right=Comparison	
	)*
;

Comparison returns Expression:
	PlusOrMinus (
		{Comparision.left=current} op=('>=' | '<=' | '<' | '>')
		right=PlusOrMinus
	)*
;

PlusOrMinus returns Expression:
	MulOrDiv (
		({Plus.left=current} '+' | {Minus.left=current} '-')
		right=MulOrDiv
	)*
;

MulOrDiv returns Expression:
	Primary (
		{MulOrDiv.left=current} op=('*' | '/')
		right=Primary
	)*
;

Primary returns Expression:
	({Bracket} '(' inner=Expression ')') |
	{NOT} 'NOT' expression=Primary |
	Atomic
;

Atomic returns Expression:
	{IntConstant} value=INT 
	| {FloatConstant} value=FLOAT 
	| {StringConstant} value=STRING 
	| {BoolConstant} value=('TRUE' | 'FALSE')
	//TODO A SELECT * query offers no reference for an attribute.
	//At the moment is no actual referencing possible!
	| {AttributeRef} (value=AttributeWithoutAliasDefinition | value=AttributeWithNestedStatement)
;

AtomicWithoutAttributeRef returns Expression:
	{IntConstant} value=INT 
	| {FloatConstant} value=FLOAT 
	| {StringConstant} value=STRING 
	| {BoolConstant} value=('TRUE' | 'FALSE')
;

AtomicWithOnlyStringConstant returns Expression:
	{StringConstant} value= STRING 
;

//TODO have to be dynamic -> use scope provider
DataType: 
	value=('INTEGER' | 'DOUBLE' | 'LONG'| 'FLOAT' | 'STRING' | 'BOOLEAN' 
	| 'STARTTIMESTAMP' | 'ENDTIMESTAMP' 
);