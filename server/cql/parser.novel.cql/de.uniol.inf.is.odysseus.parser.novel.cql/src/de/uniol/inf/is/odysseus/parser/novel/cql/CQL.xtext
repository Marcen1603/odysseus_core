grammar de.uniol.inf.is.odysseus.parser.novel.cql.CQL with org.eclipse.xtext.common.Terminals

generate cQL "http://www.uniol.de/inf/is/odysseus/parser/novel/cql/CQL"

Model: 
	((components+=(Query|Command)) (';')?)*
;
	
terminal ID: (LETTER) (LETTER|SPECIAL_CHARS|INT)*;	
terminal LETTER: ('a'..'z'|'A'..'Z') ;	
terminal SPECIAL_CHARS: (':'|'_'|'{'|'}'|'$') ;
terminal FLOAT:  INT '.' INT;
terminal BIT: ('0'|'1');
terminal BYTE: BIT BIT BIT BIT BIT BIT BIT BIT;
BOOLEAN: ('FALSE'|'TRUE');

terminal VECTOR_FLOAT: '[' (FLOAT)+ (',' FLOAT)* ']';
terminal MATRIX_FLOAT : '[' (FLOAT)+ (',' FLOAT)* (';' (FLOAT)+ (',' FLOAT)*)* ']';

enum Time:
	MILLISECOND 
		|SECOND 
		| MINUTE
		| HOUR
		| WEEK
		| MILLISECONDS 
		| SECONDS 
		| MINUTES
		| HOURS
		| WEEKS
;

QualifiedAttributename:
	(ID
		| (QualifiedSourcename '.' ID) 
		| (QualifiedSourcename '.' '*')
		| ( '{' ID '}')
	)
;

QualifiedAttributenameWithoutSpecialChars:
	(ID| (QualifiedSourcename '.' ID))
;

QualifiedSourcename:
	ID
;

Query:
	type=(
	Create
	| StreamTo
	| ComplexSelect
	)
;
 
Command :
	type=(
	DropStream
	| UserManagement
	| RightsManagement
	| RoleManagement
	| CreateDataBaseGenericConnection
	| CreateDataBaseJDBCConnection
	| DropDatabaseConnection
	| CreateContextStore
	| DropContextStore
	)
; 
 
SimpleSelect:
	{SimpleSelect}
	(
		'SELECT' (distinct='DISTINCT')?
		('*'|(arguments+=SelectArgument+  ( ',' arguments+=SelectArgument) *))
		('FROM' sources+=Source+ (',' sources+=Source)*)
		('WHERE' predicates=ExpressionsModel)?
		('GROUP' 'BY' order+=Attribute+ (',' order+=Attribute)*)?
		('HAVING' having=ExpressionsModel)?
	)
;

ComplexSelect:
	{ComplexSelect}
	left=SimpleSelect
	(operation=('UNION'|'DIFFERENCE'|'INTERSECTION') right=SimpleSelect)?
;

InnerSelect:
	'(' select=SimpleSelect ')'
;

InnerSelect2:
	select=SimpleSelect
;

SelectArgument: (attribute=Attribute | expression=SelectExpression);

Source: 
	(SimpleSource | NestedSource)
;

SimpleSource returns Source:
	{SimpleSource}
	name=QualifiedSourcename (window=WindowOperator)? ('AS' alias=Alias)?
;

NestedSource returns Source:
	{NestedSource}
	statement=InnerSelect 'AS' alias=Alias
;

Attribute: 
	name=QualifiedAttributename
	('AS' alias=Alias)?
;
 
AttributeWithoutAliasDefinition returns Attribute: 
	name=QualifiedAttributename
; 

AttributeForSelectExpression returns Attribute:
	(name=QualifiedAttributenameWithoutSpecialChars)
;

ComplexPredicate:
	((quantification=QuantificationPredicate)
	| (exists=ExistPredicate)
	| (in=InPredicate))
	select=InnerSelect
;  

QuantificationPredicate:
	attribute=AttributeWithoutAliasDefinition
	operator=COMPARE_OPERATOR
	predicate=('ALL'|'ANY'|'SOME')
;


ExistPredicate:
	predicate=('EXISTS')
;

InPredicate:
	attribute=AttributeWithoutAliasDefinition
	predicate=('IN')
;

AndOperator: 'AND' ;
OrOperator: 'OR' ;
EQUALITIY_OPERATOR: ('=' | '!=') ;
COMPARE_OPERATOR: ('>=' | '<=' | '<' | '>') ;
ARITHMETIC_OPERATOR:
	ADD_OPERATOR
	| MINUS_OPERATOR 
	| MUL_OR_DIV_OPERATOR
	| EXPONENT_OPERATOR
;
EXPONENT_OPERATOR: '^' ;
MUL_OR_DIV_OPERATOR: ('/'|'*') ;
ADD_OPERATOR: '+' ;
MINUS_OPERATOR: '-' ;

SelectExpression:
	(
		(expressions+=ExpressionComponent
			(operators+=ARITHMETIC_OPERATOR
			expressions+=(ExpressionComponent|ExpressionComponentAsAttribute)
			)*
		)
		|(expressions+=ExpressionComponentAsAttribute
			(operators+=ARITHMETIC_OPERATOR
			expressions+=(ExpressionComponent|ExpressionComponentAsAttribute)
			)
		)
	)
	('AS' alias=Alias)?//TODO Add SelectExpression without an alias
;

SelectExpressionOnlyWithAttribute returns SelectExpression:
	expressions+=ExpressionComponentAsAttribute
;

//Is either a map function or an aggregation function. This depends 
//on the given name and is decided by the generator on runtime. Also
//checked is that an aggregation is no part of a select expression like
//SELECT attr1 + 10 - SUM(attr1) FROM.., but a select expression can be 
//a part of an aggregation like AVG(attr1 + DolToEur(attr2)).//TODO Not working currently
Function returns ExpressionComponent:
	{Function}
	name=ID
	'('
	value=(SelectExpression|SelectExpressionOnlyWithAttribute|StarExpression)
	')'
;


//Determines the structure of a component of a select expression
ExpressionComponent:
	value=(Function | AtomicWithoutAttributeRef)
;

StarExpression returns SelectExpression:
	{StarExpression}
	expressions+=Star
;


Star returns ExpressionComponent:
	{Star}
	value=Starthing
;

Starthing:
	{Starthing}
	'*'
;

ExpressionComponentAsAttribute returns ExpressionComponent:
	{ExpressionComponentAsAttribute}
	value=AttributeForSelectExpression
;

Alias:
	name=ID
;  

AccessFramework:
	'WRAPPER' wrapper=STRING
	'PROTOCOL' protocol=STRING
	'TRANSPORT' transport=STRING
	'DATAHANDLER' datahandler=STRING
	'OPTIONS' '('(keys+=STRING values+=(STRING|PATH))+ (',' keys+=STRING values+=(STRING|PATH))*')'
;

terminal PATH:
	"'" (("\' \\ \'") .) (("\' \\ \'") .)* "'" |
	'"' (("\' \\ \'") .) (("\' \\ \'") .)* '"'  
; 

SchemaDefinition:
	name=ID
	'('
	arguments+=ID arguments+=ID
	(',' arguments+=ID arguments+=ID)*
	')'
;

Create:
	{Create}
	('CREATE'|'ATTACH')
	type=('STREAM'|'SINK'|'VIEW')
	create=(CreateAccessFramework
			|CreateChannelFrameworkViaPort
			|CreateChannelFormatViaFile
			|CreateDatabaseStream
			|CreateDatabaseSink
			|CreateView)
	
;

CreateAccessFramework:
	attributes=SchemaDefinition
	pars=AccessFramework
;

CreateChannelFrameworkViaPort:
	attributes=SchemaDefinition
	'CHANNEL' host=ID ':' port=INT
;

CreateChannelFormatViaFile:
	attributes=SchemaDefinition
 	'FILE' filename=STRING 'AS' type=ID
;

CreateDatabaseStream:
	attributes=SchemaDefinition
	'DATABASE'
	database=ID
	'TABLE'
	table=ID
	('EACH'
	 size=INT
	 unit=Time)?
;

CreateDatabaseSink:
	name=ID
	'AS'
	'DATABASE'
	database=ID
	'TABLE'
	table=ID
	('AND' option=('DROP'|'TRUNCATE'))?
;

CreateView:  
	name=ID 
	'FROM' 
	select=InnerSelect
;

CreateDataBaseJDBCConnection returns Command:
	{CreateDataBaseConnectionJDBC}
	'CREATE'
	'DATABASE'
	'CONNECTION'
	name=ID
	'JDBC'
	server=ID
	('WITH' 
	 'USER'
	 user=ID
	 'PASSWORD'
	 password=ID
	 (lazy='NO_LAZY_CONNECTION_CHECK')?)?
;

CreateDataBaseGenericConnection returns Command:
	{CreateDataBaseConnectionGeneric}
	'CREATE'
	'DATABASE'
	'CONNECTION'
	name=ID
	'AS'
	driver=ID
	'TO'
	source=ID
	('AT'
	host=ID
	':'
	port=INT)?
	('WITH' 
	 'USER'
	 user=ID
	 'PASSWORD'
	 password=ID
	 (lazy='NO_LAZY_CONNECTION_CHECK')?)?
;

DropDatabaseConnection returns Command:
	{DropDatabaseConnection}
	'DROP'
	'DATABASE'
	'CONNECTION'
	name=ID
;

ContextStoreType:
	(type='SINGLE')
	|(type='MULTI' 
		size=INT 
		('PARTITION' 
		'BY' 
		partition=INT)?
	)
;

CreateContextStore returns Command:
	{CreateContextStore}
	'CREATE'
	'CONTEXT'
	'STORE'
	attributes=SchemaDefinition
	'AS'
	contextType=ContextStoreType
;

DropContextStore returns Command:
	{DropContextStore}
	'DROP'
	'CONTEXT'
	'STORE'
	name=ID
	('IF' exists='EXISTS')?
;

StreamTo: 
	{StreamTo}
	'STREAM' 
	'TO' 
	name=ID 
	(statement=InnerSelect2|inputname=ID)
;

DropStream returns Command:
	{DropStream}
	'DROP'
	name=('SINK'|'STREAM'|'VIEW')
	stream=ID
	(exists='IF' 'EXISTS')?
;

UserManagement returns Command:
	{UserManagement}
	name=('CREATE'|'ALTER'|'DROP')
	subject=('USER'|'ROLE'|'TENANT')
	subjectName=ID
	('IDENTIFIED' 'BY' password=STRING)?
;

RightsManagement returns Command:
	({RightsManagement} name='GRANT' 
	operations+=ID (',' operations+=ID)* ('ON' operations2+=ID (',' operations2+=ID)*)?
	'TO' user=ID)
	|({RightsManagement} name='REVOKE' 
	operations+=ID (',' operations+=ID)* ('ON' operations2+=ID (',' operations2+=ID)*)?	
	'FROM' user=ID)
;

RoleManagement returns Command:
	({RoleManagement} name='GRANT' 
	'ROLE' operations+=ID (',' operations+=ID)*
	'TO' user=ID)
	|({RoleManagement} name='REVOKE' 
	'ROLE' operations+=ID (',' operations+=ID)*	
	'FROM' user=ID)
;

WindowOperator:
	'['
	(UnboundedWindow
	| TimebasedWindow
	| TuplebasedWindow)
	']'
;

UnboundedWindow returns WindowOperator:  
	{UndboundedWindow}
	'UNBOUNDED'
;

TimebasedWindow returns WindowOperator:
	{TimebasedWindow} 
	'SIZE' size=INT unit=Time
	('ADVANCE' advance_size=INT advance_unit=Time)?
	'TIME'
;

TuplebasedWindow returns WindowOperator:
	{TuplebasedWindow}
	'SIZE' size=INT
	('ADVANCE' advance_size=INT)?
	'TUPLE'
	('PARTITION' 'BY' partition_attribute=Attribute)?
;

// Expression DSL ///////////////////////////////////////////////////////
ExpressionsModel: {ExpressionsModel} elements+=Expression;

Expression: OrPredicate;

OrPredicate returns Expression:
	AndPredicate ({OrPredicate.left=current} OrOperator right=AndPredicate)*
;

AndPredicate returns Expression:
	Equalitiy ({AndPredicate.left=current} AndOperator right=Equalitiy)*
;

Equalitiy returns Expression:
	Comparison (
		{Equality.left=current} op=EQUALITIY_OPERATOR
		right=Comparison	
	)*
;

Comparison returns Expression:
	PlusOrMinus (
		{Comparision.left=current} op=COMPARE_OPERATOR
		right=PlusOrMinus
	)*
;

PlusOrMinus returns Expression:
	MulOrDiv (
		({Plus.left=current} '+' | {Minus.left=current} '-')
		right=MulOrDiv
	)*
;

MulOrDiv returns Expression:
	Primary (
		{MulOrDiv.left=current} op=('/'|'*')
		right=Primary
	)*
;

Primary returns Expression:
	({Bracket} '(' inner=Expression ')') |
	{NOT} 'NOT' expression=Primary |
	Atomic
;

Atomic returns Expression:
	{IntConstant} value=INT 
	| {FloatConstant} value=FLOAT 
	| {StringConstant} value=STRING 
	| {BoolConstant} value=BOOLEAN
	| {AttributeRef} value=AttributeWithoutAliasDefinition
	| {ComplexPredicateRef} value=ComplexPredicate
;

//TODO Rename
AtomicWithoutAttributeRef returns Expression:
	{IntConstant} value=INT 
	| {FloatConstant} value=FLOAT 
	| {StringConstant} value=STRING 
	| {BoolConstant} value=BOOLEAN
	| {Matrix} value=(MATRIX_FLOAT)
	| {Vector} value=(VECTOR_FLOAT)
;
