/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.serializer;

import com.google.inject.Inject;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Alias;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.And;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CQLPackage;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Condition;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Create_Statement;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionsModel;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Model;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Operator;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Or;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Scalar_Function;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Select_Statement;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Value;
import de.uniol.inf.is.odysseus.parser.novel.cql.services.CQLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CQLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CQLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CQLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CQLPackage.ALIAS:
				sequence_Alias(context, (Alias) semanticObject); 
				return; 
			case CQLPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case CQLPackage.ATTRIBUTE:
				if (rule == grammarAccess.getAtomicRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualitiyRule()
						|| action == grammarAccess.getEqualitiyAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisionLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()) {
					sequence_Atomic(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributeRule()) {
					sequence_Attribute(context, (Attribute) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.BOOL_CONSTANT:
				sequence_Atomic(context, (BoolConstant) semanticObject); 
				return; 
			case CQLPackage.BRACKET:
				sequence_Primary(context, (Bracket) semanticObject); 
				return; 
			case CQLPackage.COMPARISION:
				sequence_Comparison(context, (Comparision) semanticObject); 
				return; 
			case CQLPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case CQLPackage.CREATE_STATEMENT:
				sequence_Create_Statement(context, (Create_Statement) semanticObject); 
				return; 
			case CQLPackage.EQUALITY:
				sequence_Equalitiy(context, (Equality) semanticObject); 
				return; 
			case CQLPackage.EXPRESSIONS_MODEL:
				sequence_ExpressionsModel(context, (ExpressionsModel) semanticObject); 
				return; 
			case CQLPackage.FLOAT_CONSTANT:
				sequence_Atomic(context, (FloatConstant) semanticObject); 
				return; 
			case CQLPackage.INT_CONSTANT:
				sequence_Atomic(context, (IntConstant) semanticObject); 
				return; 
			case CQLPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case CQLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case CQLPackage.MUL_OR_DIV:
				sequence_MulOrDiv(context, (MulOrDiv) semanticObject); 
				return; 
			case CQLPackage.NOT:
				sequence_Primary(context, (NOT) semanticObject); 
				return; 
			case CQLPackage.OPERATOR:
				sequence_Operator(context, (Operator) semanticObject); 
				return; 
			case CQLPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case CQLPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case CQLPackage.SCALAR_FUNCTION:
				sequence_Scalar_Function(context, (Scalar_Function) semanticObject); 
				return; 
			case CQLPackage.SELECT_STATEMENT:
				sequence_Select_Statement(context, (Select_Statement) semanticObject); 
				return; 
			case CQLPackage.SOURCE:
				sequence_Source(context, (Source) semanticObject); 
				return; 
			case CQLPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case CQLPackage.STRING_CONSTANT:
				sequence_Atomic(context, (StringConstant) semanticObject); 
				return; 
			case CQLPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Alias returns Alias
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Alias(ISerializationContext context, Alias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.ALIAS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.ALIAS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAliasAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equalitiy)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualitiyParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atomic returns Attribute
	 *     Expression returns Attribute
	 *     Or returns Attribute
	 *     Or.Or_1_0 returns Attribute
	 *     And returns Attribute
	 *     And.And_1_0 returns Attribute
	 *     Equalitiy returns Attribute
	 *     Equalitiy.Equality_1_0 returns Attribute
	 *     Comparison returns Attribute
	 *     Comparison.Comparision_1_0 returns Attribute
	 *     PlusOrMinus returns Attribute
	 *     PlusOrMinus.Plus_1_0_0_0 returns Attribute
	 *     PlusOrMinus.Minus_1_0_1_0 returns Attribute
	 *     MulOrDiv returns Attribute
	 *     MulOrDiv.MulOrDiv_1_0 returns Attribute
	 *     Primary returns Attribute
	 *
	 * Constraint:
	 *     value=[Attribute|ID]
	 */
	protected void sequence_Atomic(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueAttributeIDTerminalRuleCall_4_1_0_1(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atomic returns BoolConstant
	 *     Expression returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equalitiy returns BoolConstant
	 *     Equalitiy.Equality_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.Comparision_1_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *
	 * Constraint:
	 *     (value='TRUE' | value='FALSE')
	 */
	protected void sequence_Atomic(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atomic returns FloatConstant
	 *     Expression returns FloatConstant
	 *     Or returns FloatConstant
	 *     Or.Or_1_0 returns FloatConstant
	 *     And returns FloatConstant
	 *     And.And_1_0 returns FloatConstant
	 *     Equalitiy returns FloatConstant
	 *     Equalitiy.Equality_1_0 returns FloatConstant
	 *     Comparison returns FloatConstant
	 *     Comparison.Comparision_1_0 returns FloatConstant
	 *     PlusOrMinus returns FloatConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns FloatConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns FloatConstant
	 *     MulOrDiv returns FloatConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns FloatConstant
	 *     Primary returns FloatConstant
	 *
	 * Constraint:
	 *     value=FLOAT_NUMBER
	 */
	protected void sequence_Atomic(ISerializationContext context, FloatConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.FLOAT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.FLOAT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueFLOAT_NUMBERTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atomic returns IntConstant
	 *     Expression returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equalitiy returns IntConstant
	 *     Equalitiy.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparision_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atomic returns StringConstant
	 *     Expression returns StringConstant
	 *     Or returns StringConstant
	 *     Or.Or_1_0 returns StringConstant
	 *     And returns StringConstant
	 *     And.And_1_0 returns StringConstant
	 *     Equalitiy returns StringConstant
	 *     Equalitiy.Equality_1_0 returns StringConstant
	 *     Comparison returns StringConstant
	 *     Comparison.Comparision_1_0 returns StringConstant
	 *     PlusOrMinus returns StringConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns StringConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns StringConstant
	 *     MulOrDiv returns StringConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns StringConstant
	 *     Primary returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (source=[Source|ID]? name=ID)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparision
	 *     Or returns Comparision
	 *     Or.Or_1_0 returns Comparision
	 *     And returns Comparision
	 *     And.And_1_0 returns Comparision
	 *     Equalitiy returns Comparision
	 *     Equalitiy.Equality_1_0 returns Comparision
	 *     Comparison returns Comparision
	 *     Comparison.Comparision_1_0 returns Comparision
	 *
	 * Constraint:
	 *     (left=Comparison_Comparision_1_0 (op='>=' | op='<=' | op='<' | op='>') right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparision semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     ((left=[Attribute|ID] right=Expression) | (right=Expression left=[Attribute|ID]))
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Create_Statement returns Create_Statement
	 *
	 * Constraint:
	 *     (name=ID attributes+=Attribute+ datatypes+=DataType+ (attributes+=Attribute datatypes+=DataType)*)
	 */
	protected void sequence_Create_Statement(ISerializationContext context, Create_Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equalitiy returns Equality
	 *     Equalitiy.Equality_1_0 returns Equality
	 *
	 * Constraint:
	 *     (left=Equalitiy_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 */
	protected void sequence_Equalitiy(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionsModel returns ExpressionsModel
	 *
	 * Constraint:
	 *     elements+=Expression+
	 */
	protected void sequence_ExpressionsModel(ISerializationContext context, ExpressionsModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     statements+=Statement+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulOrDiv
	 *     Or returns MulOrDiv
	 *     Or.Or_1_0 returns MulOrDiv
	 *     And returns MulOrDiv
	 *     And.And_1_0 returns MulOrDiv
	 *     Equalitiy returns MulOrDiv
	 *     Equalitiy.Equality_1_0 returns MulOrDiv
	 *     Comparison returns MulOrDiv
	 *     Comparison.Comparision_1_0 returns MulOrDiv
	 *     PlusOrMinus returns MulOrDiv
	 *     PlusOrMinus.Plus_1_0_0_0 returns MulOrDiv
	 *     PlusOrMinus.Minus_1_0_1_0 returns MulOrDiv
	 *     MulOrDiv returns MulOrDiv
	 *     MulOrDiv.MulOrDiv_1_0 returns MulOrDiv
	 *
	 * Constraint:
	 *     (left=MulOrDiv_MulOrDiv_1_0 (op='*' | op='/') right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, MulOrDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operator returns Operator
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Operator(ISerializationContext context, Operator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.OPERATOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.OPERATOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOperatorAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equalitiy returns Minus
	 *     Equalitiy.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparision_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equalitiy returns Plus
	 *     Equalitiy.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparision_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Bracket
	 *     Or returns Bracket
	 *     Or.Or_1_0 returns Bracket
	 *     And returns Bracket
	 *     And.And_1_0 returns Bracket
	 *     Equalitiy returns Bracket
	 *     Equalitiy.Equality_1_0 returns Bracket
	 *     Comparison returns Bracket
	 *     Comparison.Comparision_1_0 returns Bracket
	 *     PlusOrMinus returns Bracket
	 *     PlusOrMinus.Plus_1_0_0_0 returns Bracket
	 *     PlusOrMinus.Minus_1_0_1_0 returns Bracket
	 *     MulOrDiv returns Bracket
	 *     MulOrDiv.MulOrDiv_1_0 returns Bracket
	 *     Primary returns Bracket
	 *
	 * Constraint:
	 *     inner=Expression
	 */
	protected void sequence_Primary(ISerializationContext context, Bracket semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.BRACKET__INNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.BRACKET__INNER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getInnerExpressionParserRuleCall_0_2_0(), semanticObject.getInner());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NOT
	 *     Or returns NOT
	 *     Or.Or_1_0 returns NOT
	 *     And returns NOT
	 *     And.And_1_0 returns NOT
	 *     Equalitiy returns NOT
	 *     Equalitiy.Equality_1_0 returns NOT
	 *     Comparison returns NOT
	 *     Comparison.Comparision_1_0 returns NOT
	 *     PlusOrMinus returns NOT
	 *     PlusOrMinus.Plus_1_0_0_0 returns NOT
	 *     PlusOrMinus.Minus_1_0_1_0 returns NOT
	 *     MulOrDiv returns NOT
	 *     MulOrDiv.MulOrDiv_1_0 returns NOT
	 *     Primary returns NOT
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, NOT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scalar_Function returns Scalar_Function
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Scalar_Function(ISerializationContext context, Scalar_Function semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.SCALAR_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.SCALAR_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScalar_FunctionAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Select_Statement returns Select_Statement
	 *
	 * Constraint:
	 *     (
	 *         name='SELECT' 
	 *         attributes+=Attribute+ 
	 *         attributes+=Attribute* 
	 *         sources+=Source+ 
	 *         sources+=Source* 
	 *         predicates=ExpressionsModel
	 *     )
	 */
	protected void sequence_Select_Statement(ISerializationContext context, Select_Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Source returns Source
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Source(ISerializationContext context, Source semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.SOURCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.SOURCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSourceAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (type=Select_Statement | type=Create_Statement)
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.VALUE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
