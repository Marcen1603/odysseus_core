/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.serializer;

import com.google.inject.Inject;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Aggregation;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Alias;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.And;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeDefinition;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeRef;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeWithNestedStatement;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CQLPackage;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Command;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateParameters;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateSink1;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStream1;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStreamChannel;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateStreamFile;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateView;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.DataType;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionComponent;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionsModel;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Mapper;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Model;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Or;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Select;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.SelectExpression;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.SelectExpressionWithoutAliasDefinition;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StreamTo;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Window_Timebased;
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Window_Tuplebased;
import de.uniol.inf.is.odysseus.parser.novel.cql.services.CQLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CQLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CQLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CQLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CQLPackage.AGGREGATION:
				if (rule == grammarAccess.getAggregationWithoutAliasDefinitionRule()) {
					sequence_AggregationWithoutAliasDefinition(context, (Aggregation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAggregationRule()) {
					sequence_Aggregation(context, (Aggregation) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.ALIAS:
				sequence_Alias(context, (Alias) semanticObject); 
				return; 
			case CQLPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case CQLPackage.ATTRIBUTE:
				if (rule == grammarAccess.getAttributeWithoutAliasDefinitionRule()) {
					sequence_AttributeWithoutAliasDefinition(context, (Attribute) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAttributeRule()) {
					sequence_Attribute(context, (Attribute) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.ATTRIBUTE_DEFINITION:
				sequence_AttributeDefinition(context, (AttributeDefinition) semanticObject); 
				return; 
			case CQLPackage.ATTRIBUTE_REF:
				sequence_Atomic(context, (AttributeRef) semanticObject); 
				return; 
			case CQLPackage.ATTRIBUTE_WITH_NESTED_STATEMENT:
				sequence_AttributeWithNestedStatement(context, (AttributeWithNestedStatement) semanticObject); 
				return; 
			case CQLPackage.BOOL_CONSTANT:
				if (rule == grammarAccess.getAtomicWithoutAttributeRefRule()) {
					sequence_AtomicWithoutAttributeRef(context, (BoolConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualitiyRule()
						|| action == grammarAccess.getEqualitiyAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisionLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (BoolConstant) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.BRACKET:
				sequence_Primary(context, (Bracket) semanticObject); 
				return; 
			case CQLPackage.COMMAND:
				if (rule == grammarAccess.getCommandRule()) {
					sequence_Command(context, (Command) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDropRule()) {
					sequence_Drop(context, (Command) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.COMPARISION:
				sequence_Comparison(context, (Comparision) semanticObject); 
				return; 
			case CQLPackage.CREATE_PARAMETERS:
				sequence_CreateParameters(context, (CreateParameters) semanticObject); 
				return; 
			case CQLPackage.CREATE_SINK1:
				sequence_CreateSink1(context, (CreateSink1) semanticObject); 
				return; 
			case CQLPackage.CREATE_STREAM1:
				sequence_CreateStream1(context, (CreateStream1) semanticObject); 
				return; 
			case CQLPackage.CREATE_STREAM_CHANNEL:
				sequence_CreateStreamChannel(context, (CreateStreamChannel) semanticObject); 
				return; 
			case CQLPackage.CREATE_STREAM_FILE:
				sequence_CreateStreamFile(context, (CreateStreamFile) semanticObject); 
				return; 
			case CQLPackage.CREATE_VIEW:
				sequence_CreateView(context, (CreateView) semanticObject); 
				return; 
			case CQLPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case CQLPackage.EQUALITY:
				sequence_Equalitiy(context, (Equality) semanticObject); 
				return; 
			case CQLPackage.EXPRESSION_COMPONENT:
				if (action == grammarAccess.getExpressionComponentAccess().getExpressionComponentValueAction_0_1()
						|| rule == grammarAccess.getExpressionComponentConstantOrAttributeRule()) {
					sequence_ExpressionComponentConstantOrAttribute(context, (ExpressionComponent) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getExpressionComponentAccess().getExpressionComponentValueAction_1_1()
						|| rule == grammarAccess.getExpressionComponentMapperOrConstantRule()) {
					sequence_ExpressionComponentMapperOrConstant(context, (ExpressionComponent) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionComponentOnlyAttributeRule()) {
					sequence_ExpressionComponentOnlyAttribute(context, (ExpressionComponent) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionComponentOnlyConstantRule()) {
					sequence_ExpressionComponentOnlyConstant(context, (ExpressionComponent) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionComponentOnlymapperRule()) {
					sequence_ExpressionComponentOnlymapper(context, (ExpressionComponent) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionComponentRule()) {
					sequence_ExpressionComponent(context, (ExpressionComponent) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.EXPRESSIONS_MODEL:
				sequence_ExpressionsModel(context, (ExpressionsModel) semanticObject); 
				return; 
			case CQLPackage.FLOAT_CONSTANT:
				if (rule == grammarAccess.getAtomicWithoutAttributeRefRule()) {
					sequence_AtomicWithoutAttributeRef(context, (FloatConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualitiyRule()
						|| action == grammarAccess.getEqualitiyAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisionLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (FloatConstant) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.INT_CONSTANT:
				if (rule == grammarAccess.getAtomicWithoutAttributeRefRule()) {
					sequence_AtomicWithoutAttributeRef(context, (IntConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualitiyRule()
						|| action == grammarAccess.getEqualitiyAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisionLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (IntConstant) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.MAPPER:
				sequence_Mapper(context, (Mapper) semanticObject); 
				return; 
			case CQLPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case CQLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case CQLPackage.MUL_OR_DIV:
				sequence_MulOrDiv(context, (MulOrDiv) semanticObject); 
				return; 
			case CQLPackage.NOT:
				sequence_Primary(context, (NOT) semanticObject); 
				return; 
			case CQLPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case CQLPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case CQLPackage.SELECT:
				sequence_Select(context, (Select) semanticObject); 
				return; 
			case CQLPackage.SELECT_EXPRESSION:
				sequence_SelectExpression(context, (SelectExpression) semanticObject); 
				return; 
			case CQLPackage.SELECT_EXPRESSION_WITHOUT_ALIAS_DEFINITION:
				if (rule == grammarAccess.getSelectExpressionWithOnlyAttributeOrConstantRule()) {
					sequence_SelectExpressionWithOnlyAttributeOrConstant(context, (SelectExpressionWithoutAliasDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSelectExpressionWithoutAliasDefinitionRule()) {
					sequence_SelectExpressionWithOnlyAttributeOrConstant_SelectExpressionWithoutAliasDefinition(context, (SelectExpressionWithoutAliasDefinition) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.SOURCE:
				sequence_Source(context, (Source) semanticObject); 
				return; 
			case CQLPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case CQLPackage.STREAM_TO:
				sequence_StreamTo(context, (StreamTo) semanticObject); 
				return; 
			case CQLPackage.STRING_CONSTANT:
				if (rule == grammarAccess.getAtomicWithOnlyStringConstantRule()) {
					sequence_AtomicWithOnlyStringConstant(context, (StringConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomicWithoutAttributeRefRule()) {
					sequence_AtomicWithoutAttributeRef(context, (StringConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualitiyRule()
						|| action == grammarAccess.getEqualitiyAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisionLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (StringConstant) semanticObject); 
					return; 
				}
				else break;
			case CQLPackage.WINDOW_TIMEBASED:
				sequence_Window_Timebased(context, (Window_Timebased) semanticObject); 
				return; 
			case CQLPackage.WINDOW_TUPLEBASED:
				sequence_Window_Tuplebased(context, (Window_Tuplebased) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AggregationWithoutAliasDefinition returns Aggregation
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name='AVG' | 
	 *             name='MIN' | 
	 *             name='MAX' | 
	 *             name='COUNT' | 
	 *             name='SUM' | 
	 *             name='MEDIAN' | 
	 *             name='FIRST' | 
	 *             name='LAST'
	 *         ) 
	 *         attribute=AttributeWithoutAliasDefinition
	 *     )
	 */
	protected void sequence_AggregationWithoutAliasDefinition(ISerializationContext context, Aggregation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Aggregation returns Aggregation
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name='AVG' | 
	 *             name='MIN' | 
	 *             name='MAX' | 
	 *             name='COUNT' | 
	 *             name='SUM' | 
	 *             name='MEDIAN' | 
	 *             name='FIRST' | 
	 *             name='LAST'
	 *         ) 
	 *         (attribute=AttributeWithoutAliasDefinition | expression=SelectExpressionWithoutAliasDefinition) 
	 *         alias=Alias?
	 *     )
	 */
	protected void sequence_Aggregation(ISerializationContext context, Aggregation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Alias returns Alias
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Alias(ISerializationContext context, Alias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.ALIAS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.ALIAS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAliasAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equalitiy)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualitiyParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicWithOnlyStringConstant returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AtomicWithOnlyStringConstant(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicWithOnlyStringConstantAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicWithoutAttributeRef returns BoolConstant
	 *
	 * Constraint:
	 *     (value='TRUE' | value='FALSE')
	 */
	protected void sequence_AtomicWithoutAttributeRef(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AtomicWithoutAttributeRef returns FloatConstant
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_AtomicWithoutAttributeRef(ISerializationContext context, FloatConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.FLOAT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.FLOAT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicWithoutAttributeRefAccess().getValueFLOATTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicWithoutAttributeRef returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_AtomicWithoutAttributeRef(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicWithoutAttributeRefAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicWithoutAttributeRef returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AtomicWithoutAttributeRef(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicWithoutAttributeRefAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AttributeRef
	 *     Or returns AttributeRef
	 *     Or.Or_1_0 returns AttributeRef
	 *     And returns AttributeRef
	 *     And.And_1_0 returns AttributeRef
	 *     Equalitiy returns AttributeRef
	 *     Equalitiy.Equality_1_0 returns AttributeRef
	 *     Comparison returns AttributeRef
	 *     Comparison.Comparision_1_0 returns AttributeRef
	 *     PlusOrMinus returns AttributeRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns AttributeRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns AttributeRef
	 *     MulOrDiv returns AttributeRef
	 *     MulOrDiv.MulOrDiv_1_0 returns AttributeRef
	 *     Primary returns AttributeRef
	 *     Atomic returns AttributeRef
	 *
	 * Constraint:
	 *     (value=AttributeWithoutAliasDefinition | value=AttributeWithNestedStatement)
	 */
	protected void sequence_Atomic(ISerializationContext context, AttributeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equalitiy returns BoolConstant
	 *     Equalitiy.Equality_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.Comparision_1_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     Atomic returns BoolConstant
	 *
	 * Constraint:
	 *     (value='TRUE' | value='FALSE')
	 */
	protected void sequence_Atomic(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FloatConstant
	 *     Or returns FloatConstant
	 *     Or.Or_1_0 returns FloatConstant
	 *     And returns FloatConstant
	 *     And.And_1_0 returns FloatConstant
	 *     Equalitiy returns FloatConstant
	 *     Equalitiy.Equality_1_0 returns FloatConstant
	 *     Comparison returns FloatConstant
	 *     Comparison.Comparision_1_0 returns FloatConstant
	 *     PlusOrMinus returns FloatConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns FloatConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns FloatConstant
	 *     MulOrDiv returns FloatConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns FloatConstant
	 *     Primary returns FloatConstant
	 *     Atomic returns FloatConstant
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_Atomic(ISerializationContext context, FloatConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.FLOAT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.FLOAT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueFLOATTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equalitiy returns IntConstant
	 *     Equalitiy.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparision_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     Atomic returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringConstant
	 *     Or returns StringConstant
	 *     Or.Or_1_0 returns StringConstant
	 *     And returns StringConstant
	 *     And.And_1_0 returns StringConstant
	 *     Equalitiy returns StringConstant
	 *     Equalitiy.Equality_1_0 returns StringConstant
	 *     Comparison returns StringConstant
	 *     Comparison.Comparision_1_0 returns StringConstant
	 *     PlusOrMinus returns StringConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns StringConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns StringConstant
	 *     MulOrDiv returns StringConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns StringConstant
	 *     Primary returns StringConstant
	 *     Atomic returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeDefinition returns AttributeDefinition
	 *
	 * Constraint:
	 *     (name=ID attributes+=Attribute+ datatypes+=DataType+ (attributes+=Attribute datatypes+=DataType)*)
	 */
	protected void sequence_AttributeDefinition(ISerializationContext context, AttributeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeWithNestedStatement returns AttributeWithNestedStatement
	 *
	 * Constraint:
	 *     (value=AttributeWithoutAliasDefinition nested=NestedStatement)
	 */
	protected void sequence_AttributeWithNestedStatement(ISerializationContext context, AttributeWithNestedStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.ATTRIBUTE_WITH_NESTED_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.ATTRIBUTE_WITH_NESTED_STATEMENT__VALUE));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.ATTRIBUTE_WITH_NESTED_STATEMENT__NESTED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.ATTRIBUTE_WITH_NESTED_STATEMENT__NESTED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeWithNestedStatementAccess().getValueAttributeWithoutAliasDefinitionParserRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getAttributeWithNestedStatementAccess().getNestedNestedStatementParserRuleCall_2_0(), semanticObject.getNested());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeWithoutAliasDefinition returns Attribute
	 *
	 * Constraint:
	 *     name=AttributeName
	 */
	protected void sequence_AttributeWithoutAliasDefinition(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.ATTRIBUTE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeWithoutAliasDefinitionAccess().getNameAttributeNameParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=AttributeName alias=Alias?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     (keyword1=ID keyword2=ID value1=ID keyword3=ID value2=ID)
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.COMMAND__KEYWORD1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.COMMAND__KEYWORD1));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.COMMAND__KEYWORD2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.COMMAND__KEYWORD2));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.COMMAND__VALUE1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.COMMAND__VALUE1));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.COMMAND__KEYWORD3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.COMMAND__KEYWORD3));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.COMMAND__VALUE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.COMMAND__VALUE2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommandAccess().getKeyword1IDTerminalRuleCall_0_0(), semanticObject.getKeyword1());
		feeder.accept(grammarAccess.getCommandAccess().getKeyword2IDTerminalRuleCall_1_0(), semanticObject.getKeyword2());
		feeder.accept(grammarAccess.getCommandAccess().getValue1IDTerminalRuleCall_2_0(), semanticObject.getValue1());
		feeder.accept(grammarAccess.getCommandAccess().getKeyword3IDTerminalRuleCall_3_0(), semanticObject.getKeyword3());
		feeder.accept(grammarAccess.getCommandAccess().getValue2IDTerminalRuleCall_4_0(), semanticObject.getValue2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparision
	 *     Or returns Comparision
	 *     Or.Or_1_0 returns Comparision
	 *     And returns Comparision
	 *     And.And_1_0 returns Comparision
	 *     Equalitiy returns Comparision
	 *     Equalitiy.Equality_1_0 returns Comparision
	 *     Comparison returns Comparision
	 *     Comparison.Comparision_1_0 returns Comparision
	 *
	 * Constraint:
	 *     (left=Comparison_Comparision_1_0 (op='>=' | op='<=' | op='<' | op='>') right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparision semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CreateParameters returns CreateParameters
	 *
	 * Constraint:
	 *     (
	 *         wrapper=STRING 
	 *         protocol=STRING 
	 *         transport=STRING 
	 *         datahandler=STRING 
	 *         (keys+=STRING values+=STRING)+ 
	 *         (keys+=STRING values+=STRING)?
	 *     )
	 */
	protected void sequence_CreateParameters(ISerializationContext context, CreateParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CreateSink1 returns CreateSink1
	 *
	 * Constraint:
	 *     (keyword=CreateKeyword attributes=AttributeDefinition pars=CreateParameters)
	 */
	protected void sequence_CreateSink1(ISerializationContext context, CreateSink1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_SINK1__KEYWORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_SINK1__KEYWORD));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_SINK1__ATTRIBUTES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_SINK1__ATTRIBUTES));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_SINK1__PARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_SINK1__PARS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateSink1Access().getKeywordCreateKeywordEnumRuleCall_0_0(), semanticObject.getKeyword());
		feeder.accept(grammarAccess.getCreateSink1Access().getAttributesAttributeDefinitionParserRuleCall_2_0(), semanticObject.getAttributes());
		feeder.accept(grammarAccess.getCreateSink1Access().getParsCreateParametersParserRuleCall_3_0(), semanticObject.getPars());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CreateStream1 returns CreateStream1
	 *
	 * Constraint:
	 *     (keyword=CreateKeyword attributes=AttributeDefinition pars=CreateParameters)
	 */
	protected void sequence_CreateStream1(ISerializationContext context, CreateStream1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_STREAM1__KEYWORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_STREAM1__KEYWORD));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_STREAM1__ATTRIBUTES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_STREAM1__ATTRIBUTES));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_STREAM1__PARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_STREAM1__PARS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateStream1Access().getKeywordCreateKeywordEnumRuleCall_0_0(), semanticObject.getKeyword());
		feeder.accept(grammarAccess.getCreateStream1Access().getAttributesAttributeDefinitionParserRuleCall_2_0(), semanticObject.getAttributes());
		feeder.accept(grammarAccess.getCreateStream1Access().getParsCreateParametersParserRuleCall_3_0(), semanticObject.getPars());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CreateStreamChannel returns CreateStreamChannel
	 *
	 * Constraint:
	 *     (keyword=CreateKeyword attributes=AttributeDefinition host=ID port=INT)
	 */
	protected void sequence_CreateStreamChannel(ISerializationContext context, CreateStreamChannel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_STREAM_CHANNEL__KEYWORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_STREAM_CHANNEL__KEYWORD));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_STREAM_CHANNEL__ATTRIBUTES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_STREAM_CHANNEL__ATTRIBUTES));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_STREAM_CHANNEL__HOST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_STREAM_CHANNEL__HOST));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_STREAM_CHANNEL__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_STREAM_CHANNEL__PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateStreamChannelAccess().getKeywordCreateKeywordEnumRuleCall_0_0(), semanticObject.getKeyword());
		feeder.accept(grammarAccess.getCreateStreamChannelAccess().getAttributesAttributeDefinitionParserRuleCall_2_0(), semanticObject.getAttributes());
		feeder.accept(grammarAccess.getCreateStreamChannelAccess().getHostIDTerminalRuleCall_4_0(), semanticObject.getHost());
		feeder.accept(grammarAccess.getCreateStreamChannelAccess().getPortINTTerminalRuleCall_6_0(), semanticObject.getPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CreateStreamFile returns CreateStreamFile
	 *
	 * Constraint:
	 *     (keyword=CreateKeyword attributes=AttributeDefinition filename=STRING type=ID)
	 */
	protected void sequence_CreateStreamFile(ISerializationContext context, CreateStreamFile semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_STREAM_FILE__KEYWORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_STREAM_FILE__KEYWORD));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_STREAM_FILE__ATTRIBUTES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_STREAM_FILE__ATTRIBUTES));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_STREAM_FILE__FILENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_STREAM_FILE__FILENAME));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_STREAM_FILE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_STREAM_FILE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateStreamFileAccess().getKeywordCreateKeywordEnumRuleCall_0_0(), semanticObject.getKeyword());
		feeder.accept(grammarAccess.getCreateStreamFileAccess().getAttributesAttributeDefinitionParserRuleCall_2_0(), semanticObject.getAttributes());
		feeder.accept(grammarAccess.getCreateStreamFileAccess().getFilenameSTRINGTerminalRuleCall_4_0(), semanticObject.getFilename());
		feeder.accept(grammarAccess.getCreateStreamFileAccess().getTypeIDTerminalRuleCall_6_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CreateView returns CreateView
	 *
	 * Constraint:
	 *     (name=ID select=NestedStatement)
	 */
	protected void sequence_CreateView(ISerializationContext context, CreateView semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_VIEW__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_VIEW__NAME));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.CREATE_VIEW__SELECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.CREATE_VIEW__SELECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateViewAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCreateViewAccess().getSelectNestedStatementParserRuleCall_3_0(), semanticObject.getSelect());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     (
	 *         value='INTEGER' | 
	 *         value='DOUBLE' | 
	 *         value='LONG' | 
	 *         value='FLOAT' | 
	 *         value='STRING' | 
	 *         value='BOOLEAN' | 
	 *         value='STARTTIMESTAMP' | 
	 *         value='ENDTIMESTAMP'
	 *     )
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Drop returns Command
	 *
	 * Constraint:
	 *     (keyword1='DROP' (keyword2='SINK' | keyword2='STREAM') value1=ID keyword3='IF'?)
	 */
	protected void sequence_Drop(ISerializationContext context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equalitiy returns Equality
	 *     Equalitiy.Equality_1_0 returns Equality
	 *
	 * Constraint:
	 *     (left=Equalitiy_Equality_1_0 (op='=' | op='!=') right=Comparison)
	 */
	protected void sequence_Equalitiy(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionComponent.ExpressionComponent_0_1 returns ExpressionComponent
	 *     ExpressionComponentConstantOrAttribute returns ExpressionComponent
	 *
	 * Constraint:
	 *     (value=AtomicWithoutAttributeRef | value=AttributeWithoutAliasDefinition)
	 */
	protected void sequence_ExpressionComponentConstantOrAttribute(ISerializationContext context, ExpressionComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionComponent.ExpressionComponent_1_1 returns ExpressionComponent
	 *     ExpressionComponentMapperOrConstant returns ExpressionComponent
	 *
	 * Constraint:
	 *     (value=ExpressionComponentMapperOrConstant_ExpressionComponent_0_1 | value=AtomicWithoutAttributeRef)
	 */
	protected void sequence_ExpressionComponentMapperOrConstant(ISerializationContext context, ExpressionComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionComponentOnlyAttribute returns ExpressionComponent
	 *
	 * Constraint:
	 *     value=AttributeWithoutAliasDefinition
	 */
	protected void sequence_ExpressionComponentOnlyAttribute(ISerializationContext context, ExpressionComponent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionComponentOnlyAttributeAccess().getValueAttributeWithoutAliasDefinitionParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionComponentOnlyConstant returns ExpressionComponent
	 *
	 * Constraint:
	 *     value=AtomicWithoutAttributeRef
	 */
	protected void sequence_ExpressionComponentOnlyConstant(ISerializationContext context, ExpressionComponent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionComponentOnlyConstantAccess().getValueAtomicWithoutAttributeRefParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionComponentOnlymapper returns ExpressionComponent
	 *
	 * Constraint:
	 *     value=ExpressionComponentOnlymapper_ExpressionComponent_1
	 */
	protected void sequence_ExpressionComponentOnlymapper(ISerializationContext context, ExpressionComponent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionComponentOnlymapperAccess().getExpressionComponentValueAction_1(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionComponent returns ExpressionComponent
	 *
	 * Constraint:
	 *     (value=ExpressionComponent_ExpressionComponent_0_1 | value=ExpressionComponent_ExpressionComponent_1_1)
	 */
	protected void sequence_ExpressionComponent(ISerializationContext context, ExpressionComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionsModel returns ExpressionsModel
	 *
	 * Constraint:
	 *     elements+=Expression
	 */
	protected void sequence_ExpressionsModel(ISerializationContext context, ExpressionsModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionComponentMapperOrConstant.ExpressionComponent_0_1 returns Mapper
	 *     ExpressionComponentOnlymapper.ExpressionComponent_1 returns Mapper
	 *     Mapper returns Mapper
	 *
	 * Constraint:
	 *     (name='DolToEur' value=SelectExpressionWithoutAliasDefinition)
	 */
	protected void sequence_Mapper(ISerializationContext context, Mapper semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.MAPPER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.MAPPER__NAME));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.EXPRESSION_COMPONENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapperAccess().getNameDolToEurKeyword_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMapperAccess().getValueSelectExpressionWithoutAliasDefinitionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     statements+=Statement+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulOrDiv
	 *     Or returns MulOrDiv
	 *     Or.Or_1_0 returns MulOrDiv
	 *     And returns MulOrDiv
	 *     And.And_1_0 returns MulOrDiv
	 *     Equalitiy returns MulOrDiv
	 *     Equalitiy.Equality_1_0 returns MulOrDiv
	 *     Comparison returns MulOrDiv
	 *     Comparison.Comparision_1_0 returns MulOrDiv
	 *     PlusOrMinus returns MulOrDiv
	 *     PlusOrMinus.Plus_1_0_0_0 returns MulOrDiv
	 *     PlusOrMinus.Minus_1_0_1_0 returns MulOrDiv
	 *     MulOrDiv returns MulOrDiv
	 *     MulOrDiv.MulOrDiv_1_0 returns MulOrDiv
	 *
	 * Constraint:
	 *     (left=MulOrDiv_MulOrDiv_1_0 (op='*' | op='/') right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, MulOrDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equalitiy returns Minus
	 *     Equalitiy.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparision_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equalitiy returns Plus
	 *     Equalitiy.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparision_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Bracket
	 *     Or returns Bracket
	 *     Or.Or_1_0 returns Bracket
	 *     And returns Bracket
	 *     And.And_1_0 returns Bracket
	 *     Equalitiy returns Bracket
	 *     Equalitiy.Equality_1_0 returns Bracket
	 *     Comparison returns Bracket
	 *     Comparison.Comparision_1_0 returns Bracket
	 *     PlusOrMinus returns Bracket
	 *     PlusOrMinus.Plus_1_0_0_0 returns Bracket
	 *     PlusOrMinus.Minus_1_0_1_0 returns Bracket
	 *     MulOrDiv returns Bracket
	 *     MulOrDiv.MulOrDiv_1_0 returns Bracket
	 *     Primary returns Bracket
	 *
	 * Constraint:
	 *     inner=Expression
	 */
	protected void sequence_Primary(ISerializationContext context, Bracket semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.BRACKET__INNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.BRACKET__INNER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getInnerExpressionParserRuleCall_0_2_0(), semanticObject.getInner());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NOT
	 *     Or returns NOT
	 *     Or.Or_1_0 returns NOT
	 *     And returns NOT
	 *     And.And_1_0 returns NOT
	 *     Equalitiy returns NOT
	 *     Equalitiy.Equality_1_0 returns NOT
	 *     Comparison returns NOT
	 *     Comparison.Comparision_1_0 returns NOT
	 *     PlusOrMinus returns NOT
	 *     PlusOrMinus.Plus_1_0_0_0 returns NOT
	 *     PlusOrMinus.Minus_1_0_1_0 returns NOT
	 *     MulOrDiv returns NOT
	 *     MulOrDiv.MulOrDiv_1_0 returns NOT
	 *     Primary returns NOT
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, NOT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CQLPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CQLPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SelectExpressionWithOnlyAttributeOrConstant returns SelectExpressionWithoutAliasDefinition
	 *
	 * Constraint:
	 *     (
	 *         expressions+=ExpressionComponentConstantOrAttribute 
	 *         ((operators+='+' | operators+='-' | operators+='*' | operators+='/') expressions+=ExpressionComponentConstantOrAttribute)*
	 *     )
	 */
	protected void sequence_SelectExpressionWithOnlyAttributeOrConstant(ISerializationContext context, SelectExpressionWithoutAliasDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectExpressionWithoutAliasDefinition returns SelectExpressionWithoutAliasDefinition
	 *
	 * Constraint:
	 *     (
	 *         expressions+=ExpressionComponentConstantOrAttribute 
	 *         ((operators+='+' | operators+='-' | operators+='*' | operators+='/') expressions+=ExpressionComponentConstantOrAttribute)* 
	 *         (
	 *             (
	 *                 expressions+=ExpressionComponentMapperOrConstant 
	 *                 (
	 *                     (operators+='+' | operators+='-' | operators+='*' | operators+='/') 
	 *                     (expressions+=ExpressionComponentConstantOrAttribute | expressions+=ExpressionComponentOnlymapper)
	 *                 )*
	 *             ) | 
	 *             (
	 *                 expressions+=ExpressionComponentOnlyAttribute 
	 *                 (
	 *                     (operators+='+' | operators+='-' | operators+='*' | operators+='/') 
	 *                     (expressions+=ExpressionComponentConstantOrAttribute | expressions+=ExpressionComponentOnlymapper)
	 *                 )+
	 *             )
	 *         )
	 *     )
	 */
	protected void sequence_SelectExpressionWithOnlyAttributeOrConstant_SelectExpressionWithoutAliasDefinition(ISerializationContext context, SelectExpressionWithoutAliasDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectExpression returns SelectExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 expressions+=ExpressionComponentMapperOrConstant 
	 *                 (
	 *                     (operators+='+' | operators+='-' | operators+='*' | operators+='/') 
	 *                     (expressions+=ExpressionComponentConstantOrAttribute | expressions+=ExpressionComponentOnlymapper)
	 *                 )*
	 *             ) | 
	 *             (
	 *                 expressions+=ExpressionComponentOnlyAttribute 
	 *                 (
	 *                     (operators+='+' | operators+='-' | operators+='*' | operators+='/') 
	 *                     (expressions+=ExpressionComponentConstantOrAttribute | expressions+=ExpressionComponentOnlymapper)
	 *                 )+
	 *             )
	 *         ) 
	 *         alias=Alias?
	 *     )
	 */
	protected void sequence_SelectExpression(ISerializationContext context, SelectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Select returns Select
	 *     NestedStatement returns Select
	 *
	 * Constraint:
	 *     (
	 *         name='SELECT' 
	 *         distinct='DISTINCT'? 
	 *         (
	 *             (attributes+=Attribute | aggregations+=Aggregation | expressions+=SelectExpression)+ 
	 *             attributes+=Attribute? 
	 *             ((aggregations+=Aggregation | expressions+=SelectExpression)? attributes+=Attribute?)*
	 *         )? 
	 *         sources+=Source+ 
	 *         sources+=Source* 
	 *         predicates=ExpressionsModel? 
	 *         (order+=Attribute+ order+=Attribute*)? 
	 *         having=ExpressionsModel?
	 *     )
	 */
	protected void sequence_Select(ISerializationContext context, Select semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Source returns Source
	 *
	 * Constraint:
	 *     (
	 *         (name=SourceName (unbounded=Window_Unbounded | time=Window_Timebased | tuple=Window_Tuplebased)? alias=Alias?) | 
	 *         (nested=NestedStatement alias=Alias)
	 *     )
	 */
	protected void sequence_Source(ISerializationContext context, Source semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         type=Select | 
	 *         type=StreamTo | 
	 *         type=Drop | 
	 *         type=CreateStream1 | 
	 *         type=CreateSink1 | 
	 *         type=CreateStreamChannel | 
	 *         type=CreateStreamFile | 
	 *         type=CreateView
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StreamTo returns StreamTo
	 *
	 * Constraint:
	 *     (name=ID (statement=Select | inputname=ID))
	 */
	protected void sequence_StreamTo(ISerializationContext context, StreamTo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Window_Timebased returns Window_Timebased
	 *
	 * Constraint:
	 *     (size=INT unit=ID (advance_size=INT advance_unit=ID)?)
	 */
	protected void sequence_Window_Timebased(ISerializationContext context, Window_Timebased semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Window_Tuplebased returns Window_Tuplebased
	 *
	 * Constraint:
	 *     (size=INT advance_size=INT? partition_attribute=Attribute?)
	 */
	protected void sequence_Window_Tuplebased(ISerializationContext context, Window_Tuplebased semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
