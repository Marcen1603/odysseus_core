/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.validation

import static org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*

import com.google.inject.Inject
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.And
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.Comparision
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.CqlPackage
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.Equality
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.Expression
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.Minus
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.MulOrDiv
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.NOT
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.Or
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.Plus
import de.uniol.inf.is.odysseus.parser.novel.cql.typing.ExpressionsType
import de.uniol.inf.is.odysseus.parser.novel.cql.typing.ExpressionsTypeProvider
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.Attribute
import de.uniol.inf.is.odysseus.parser.novel.cql.cql.Model

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CqlValidator extends AbstractCqlValidator 
{

	public static val WRONG_TYPE = "de.uniol.inf.is.odysseus.parser.novel.cql.WrongType";
	
	@Inject extension ExpressionsTypeProvider
	
	def private checkExpectedBoolean(Expression e, EReference ref)
	{
		checkExpectedType(e, ref, ExpressionsTypeProvider::boolType)
	}
	
	def private checkExpectedNumber(Expression e, EReference ref)
	{
		checkExpectedType(e, ref, ExpressionsTypeProvider::intType, ExpressionsTypeProvider::floatType)
	}
	
	
	def checkExpectedType(Expression e, EReference ref, ExpressionsType ... type) 
	{
		val actualType = getTypeAndNotNull(e, ref)
		if(!type.contains(actualType))
		{
			error("expected " +  e +" type, but was actually " + actualType, ref, WRONG_TYPE)
		}
	}
	
	def ExpressionsType getTypeAndNotNull(Expression e, EReference ref) 
	{
		var type = e?.typeFor
		if(type == null)
			error("null type", ref, WRONG_TYPE)
		return type	
	}

	@Check def checkType(Plus type)
	{ 
		checkExpectedNumber(type.left, CqlPackage.Literals::PLUS__LEFT)
		checkExpectedNumber(type.right, CqlPackage.Literals::PLUS__RIGHT)
	}
	
	@Check def checkType(MulOrDiv type)
	{ 
		checkExpectedNumber(type.left, CqlPackage.Literals::PLUS__LEFT)
		checkExpectedNumber(type.right, CqlPackage.Literals::PLUS__RIGHT)
	}
	
	@Check def checkType(Minus type)
	{ 
		checkExpectedNumber(type.left, CqlPackage.Literals::PLUS__LEFT)
		checkExpectedNumber(type.right, CqlPackage.Literals::PLUS__RIGHT)
	}
	
	@Check def checkType(NOT type)
	{
		checkExpectedBoolean(type.expression, CqlPackage.Literals::NOT__EXPRESSION)
	}
	
	@Check def checkType(And type)
	{
		checkExpectedBoolean(type.left, CqlPackage.Literals::AND__LEFT)
		checkExpectedBoolean(type.right, CqlPackage.Literals::AND__RIGHT)
	}
	
	@Check def checkType(Or type)
	{
		checkExpectedBoolean(type.left, CqlPackage.Literals::OR__LEFT)
		checkExpectedBoolean(type.right, CqlPackage.Literals::OR__RIGHT)
	}
	
	@Check def checkType(Equality type)
	{
		val left = getTypeAndNotNull(type.left, CqlPackage.Literals::EQUALITY__LEFT)
		val right = getTypeAndNotNull(type.right, CqlPackage.Literals::EQUALITY__RIGHT)
		checkExpectedSame(left, right)			
	}
	
	@Check def checkType(Comparision type)
	{
		val left = getTypeAndNotNull(type.left, CqlPackage.Literals::COMPARISION__LEFT)
		val right = getTypeAndNotNull(type.right, CqlPackage.Literals::COMPARISION__RIGHT)
		checkExpectedSame(left, right)			
		checkNotBoolean(left, CqlPackage.Literals::COMPARISION__LEFT)
		checkNotBoolean(left, CqlPackage.Literals::COMPARISION__RIGHT)
	}	
	
	@Check def checkType(Attribute type)
	{
		val list = ExpressionsTypeProvider::attributesDefinedBefore(type)
		println(type.previousSibling)
				
	}
	
	def checkExpectedSame(ExpressionsType left, ExpressionsType right) 
	{
		if(left != null && right != null && right != left)
			error("expected the same type, but was " + left + ", " + right,
				CqlPackage.Literals::EQUALITY.EIDAttribute, WRONG_TYPE
			)
	}
	
	def checkNotBoolean(ExpressionsType type, EReference ref)
	{
		if(type == ExpressionsTypeProvider::boolType)
			error("cannot be boolean", ref, WRONG_TYPE)
	}
}
