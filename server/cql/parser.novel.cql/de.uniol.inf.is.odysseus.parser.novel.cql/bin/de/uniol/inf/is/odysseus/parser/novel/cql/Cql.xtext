grammar de.uniol.inf.is.odysseus.parser.novel.cql.Cql with org.eclipse.xtext.common.Terminals

generate cql "http://www.uniol.de/inf/is/odysseus/parser/novel/cql/Cql"

Model: statements+=Statement*;
	
Statement:  (type=Select_Statement| type=Create_Statement) ';' ; 

Nested_Statement: '(' Select_Statement ')' ;

// Data types //////////////////////////////////////////////////////////

Atomic returns Expression:
	{IntConstant} value=INT |
	{DoubleConstant} value= FLOAT_NUMBER |
	{StringConstant} value=STRING |
	{BoolConstant} value=('TRUE' | 'FALSE')
	| {Attribute} value=[Attribute]
;

terminal FLOAT_NUMBER: ('1'..'9') ('0'..'9')* '.' ('0'..'9');

Alias: 
	name=ID
;

Source: 
	name=ID
;

Attribute: ((source=[Source] '.')? name=ID ); //| Function);
//TODO Validator: do not allow "Source1 AS Alias1.attr1"

enum FunctionType: SUM | ADD | MAX | MIN | COUNT | AVG | LAST | FIRST ;

//Function: functionType=FunctionType '(' value=Attribute ')' ;

// Expressions //////////////////////////////////////////////////////////

ExpressionsModel: {ExpressionsModel} elements+=Expression*;

Expression: Or;

Or returns Expression:
	And ({Or.left=current} 'OR' right=And)*
;

And returns Expression:
	Equalitiy ({And.left=current} 'AND' right=Equalitiy)*
;

Equalitiy returns Expression:
	Comparison (
		{Equality.left=current} op=('==' | '!=')
		right=Comparison	
	)*
;

Comparison returns Expression:
	PlusOrMinus (
		{Comparision.left=current} op=('>=' | '<=' | '<' | '>')
		right=PlusOrMinus
	)*
;

PlusOrMinus returns Expression:
	MulOrDiv (
		({Plus.left=current} '+' | {Minus.left=current} '-')
		right=MulOrDiv
	)*
;

MulOrDiv returns Expression:
	Primary (
		{MulOrDiv.left=current} op=('*' | '/')
		right=Primary
	)*
;

Primary returns Expression:
	({Bracket} '(' inner=Expression ')') |
	{NOT} 'NOT' expression=Primary |
	Atomic
;

//	Atomic (
//		{Plus.left=current} '+' | {Minus.left=current} '-' 
//		right=Atomic
//	)*

////////////////////////////////////////////////////////////////////////

Select_Statement:
	name='SELECT'
	('DISTINCT')?
	attributes+=Attribute+ (',' attributes+=Attribute)*
	'FROM'
	sources+=Source+ (',' sources+=Source)*
	('WHERE' (predicates=ExpressionsModel ))//| attribute=[Attribute] 'IN' '(' values+=Value ')'))?
//	(('ORDER' 'BY' | 'order' 'by') ordering+=[Attribute]+ ('ASC' | 'asc' | 'DESC' | 'desc')? )?
//	(('HAVING' | 'having') havingFunction=[Parameter] havingOperator=Operator havingValue=Value)?
//	';'
;

Operator:
	name=ID
;

Condition:
	left=[Attribute] right=Expression |
	right=Expression left=[Attribute]
;

//Parameter:
//	Attribute //| Function
//	(('AS' | 'as') alias=ID)?
//;

Value:
	name=ID
;

Scalar_Function:
	name=ID
//	('UCASE(' | 'ucase(' | 'LCASE(' | 'lcase(' | 'MID(' | 'mid(' |
//	 'LEN(' | 'len(' | 'ROUND(' | 'round(' | 'NOW(' | 'now(' |
//	 'FORMAT(' | 'format('
//	)
;

Create_Statement:
	name='CREATE'	
//	('CREATE' | 'create')
;
