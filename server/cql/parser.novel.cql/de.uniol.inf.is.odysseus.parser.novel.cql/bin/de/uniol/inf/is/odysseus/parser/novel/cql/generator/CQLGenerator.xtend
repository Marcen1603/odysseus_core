/*
 * generated by Xtext 2.10.0
 */
package de.uniol.inf.is.odysseus.parser.novel.cql.generator

import de.uniol.inf.is.odysseus.core.infoservice.InfoService
import de.uniol.inf.is.odysseus.core.infoservice.InfoServiceFactory
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFAttribute
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFDatatype
import de.uniol.inf.is.odysseus.core.sdf.schema.SDFSchema
import de.uniol.inf.is.odysseus.parser.novel.cql.builder.PQLBuilder
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AccessFramework
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AndPredicate
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Attribute
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.AttributeRef
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.BoolConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Bracket
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Comparision
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ComplexPredicate
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ComplexPredicateRef
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ComplexSelect
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Create
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateAccessFramework
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateChannelFormatViaFile
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateChannelFrameworkViaPort
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateDatabaseSink
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateDatabaseStream
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.CreateView
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Equality
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExistPredicate
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Expression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.ExpressionComponent
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.FloatConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Function
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.InPredicate
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.IntConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Matrix
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Minus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.MulOrDiv
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NOT
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.NestedSource
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.OrPredicate
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Plus
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.QuantificationPredicate
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.SchemaDefinition
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.SelectArgument
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.SelectExpression
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.SimpleSelect
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.SimpleSource
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Source
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Starthing
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Statement
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StreamTo
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.StringConstant
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.TimebasedWindow
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.TuplebasedWindow
import de.uniol.inf.is.odysseus.parser.novel.cql.cQL.Vector
import java.util.ArrayList
import java.util.Arrays
import java.util.Collection
import java.util.List
import java.util.Map
import java.util.Map.Entry
import java.util.Set
import java.util.stream.Collectors
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGenerator2
import org.eclipse.xtext.generator.IGeneratorContext
import de.uniol.inf.is.odysseus.database.connection.DatabaseConnectionDictionary
import de.uniol.inf.is.odysseus.core.server.planmanagement.QueryParseException
import de.uniol.inf.is.odysseus.parser.novel.cql.CQLParser
import java.util.Collections

/** Generates PQL text from a CQL text. */
class CQLGenerator implements IGenerator2
{
	static val private InfoService infoService = InfoServiceFactory.getInfoService("CQLGenerator");//TODO Produces INFO  RCPInfoServiceListener  - Generated PQL Query:
	
	//TODO Write uniform getter for the registry with dispatch methods. Makes it readable and easier to change
	//Data structures to hold information about attributes, sources, generated operators, etc.
	var private Map<String, String> 		registry_Operators = newHashMap
	var private Map<String, String> 		registry_StreamTo = newHashMap	
	var private Map<String, String> 		registry_Sinks = newHashMap
	var private Map<String, String> 		registryBackUp_Operators = newHashMap
	var private Map<String, List<String>> 	registry_NestedSelects = newHashMap
	var private Map<String, List<String>> 	registry_RenamedAttributes = newHashMap
	var private List<SourceStruct> 			registry_Sources = newArrayList
	var private List<String> 				registryBackUp_OperatorNames = newArrayList
	var private List<String> 				registry_OperatorNames = newArrayList
	var private Map<String, String> 		registry_Expressions = newHashMap
	var private List<String> 				registry_Aggregations = newArrayList
	var private Map<String, String>			registry_AttributeAliases = newHashMap
	
	var Map<SimpleSelect, List<SelectExpression>> queryAggregations = newHashMap
	var Map<SimpleSelect, List<SelectExpression>> queryExpressions = newHashMap
	/** Contains string representations of all attributes (inclusivley aggregations and expressions) mapped by their corresponding sources.*/
	var Map<SimpleSelect, Map<String, List<String>>> queryAttributes = newHashMap
	
	/** Contains all selected attributes for each registered query */
	var Map<SimpleSelect, List<String>> projectionAttributes = newHashMap
	/** Contains the corresponding sources to the attributes in projectionAttributes */
	var Map<SimpleSelect, List<String>> projectionSources = newHashMap
	var Map<String, Set<String>> registry_SubQuerySources = newHashMap
	
	
	//Counters to keep track of identifiers for operators, aggregations, expressions
	var private operatorCounter = 0
	var private aggregationCounter = 0
	var private expressionCounter = 0
	var private selfJoinCounter = 1
	//Holds a predicate or expressions string during its recursive generation
	var private String predicateString = null
	var private String expressionString = null
	var private firstJoinInQuery = true
	//Provides different names e.g. to identify valid names for aggregations and map functions 
	var private NameProvider nameProvider
	var private PQLBuilder builder = PQLBuilder.getInstance()
	
	var private List<String> querySources = newArrayList
	//
	var private List<SimpleSelect> registry_SimpleSelect = newArrayList
	
	val private String OP     = "operator_"
	val private String ASSIG1 = "="
	val private String ASSIG2 = ":="

	var List<String> predicateStringList = newArrayList

	def void clear()
	{
//		registry_StreamTo.clear()
//		registry_Sinks.clear()
		registry_OperatorNames.clear()
		registry_Operators.clear()
		registry_NestedSelects.clear()
		registry_Sources.clear()
		registry_Expressions.clear()
		registry_Aggregations.clear()
		registry_RenamedAttributes.clear()
		queryAggregations.clear()
		queryAttributes.clear()
		queryExpressions.clear()
		registry_SubQueries.clear()
		registry_SubQuerySources.clear()
		registry_SimpleSelect.clear()
		registry_existenceOperators.clear()
		renameAliases.clear()
		operatorCounter = 0
		aggregationCounter = 0
		expressionCounter = 0
		selfJoinCounter = 1
		predicateString = null
		expressionString = null
		firstJoinInQuery = true
		querySources = newArrayList
	}

	override afterGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context)  { clear() }
	override beforeGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) { clear() }
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		var i = 0 ;
		for(e : resource.allContents.toIterable.filter(typeof(Statement)))
		{
			fsa.generateFile(
				""+ i++,	
				e.parseStatement()
			)
		}
	}	

	def CharSequence parseStatement(Statement stmt)
	{
		if(stmt.type instanceof ComplexSelect)
		{
			var complexStatement = stmt.type as ComplexSelect
			if(complexStatement.operation !== null)
			{
				parseComplexSelect(complexStatement.left, complexStatement.right, complexStatement.operation)
			}								
			else
			{
				parseSimpleSelect(complexStatement.left)
			}
		}
		else if(stmt.type instanceof Create)
			parseCreate(stmt.type as Create)
		else if(stmt.type instanceof StreamTo)
			parseStreamTo(stmt.type as StreamTo)
		var model= createModel()
		infoService.info("Generated PQL Query:"+ System.getProperty("line.separator") + model)
		return model
	}

	def parseCreate(Create statement) 
	{
		if(statement.create instanceof CreateView)
			parseCreateView(statement.create as CreateView)
		else if(statement.create instanceof CreateAccessFramework)
			parseCreateAccessFramework(statement.create as CreateAccessFramework, statement.type)
		else if(statement.create instanceof CreateChannelFormatViaFile)
			parseCreateStreamFile(statement.create as CreateChannelFormatViaFile)
		else if(statement.create instanceof CreateChannelFrameworkViaPort)
			parseCreateStreamChannel(statement.create as CreateChannelFrameworkViaPort)
		else if(statement.create instanceof CreateDatabaseStream)
			parseCreateDatabaseStream(statement.create as CreateDatabaseStream)
		else if(statement.create instanceof CreateDatabaseSink)
			parseCreateDatabaseSink(statement.create as CreateDatabaseSink)
	}
	
	def String createModel()
	{
		var model = ''
		for(var i = 0; i < registry_OperatorNames.size; i++)
		{
			if(registry_OperatorNames.get(i).contains(VIEW))// := for which opertor?
				model += formatOutputString(registry_OperatorNames.get(i).replace(VIEW, '') + ASSIG2 + registry_Operators.get(registry_OperatorNames.get(i))) + System.getProperty("line.separator")
			else
				model += formatOutputString(registry_OperatorNames.get(i) + ASSIG1 + registry_Operators.get(registry_OperatorNames.get(i))) + System.getProperty("line.separator")
			for(Entry<String, List<String>> entry : registry_NestedSelects.entrySet)
			{
				if(entry.key.equals(registry_OperatorNames.get(i)))
				{
					var l = entry.value
					for(String alias : l)
						model += formatOutputString(alias + ASSIG1 + entry.key) + System.getProperty("line.separator")
				} 	
			}
		}
		return model
	}

	def private prepareParsingSelect(SimpleSelect select)
	{
		println("prepareParsingSelect()")
		if(!registry_SimpleSelect.contains(select))
		{
			var subQueries = registerAllSource(select)
			for(NestedSource subQuery : subQueries)
			{
				prepareParsingSelect(subQuery.statement.select)
				registry_SubQuerySources.put(subQuery.alias.name, queryAttributes.get(subQuery.statement.select).keySet)
			}
				
		    var Map<String, List<String>> attributes2 = newHashMap
	    	attributes2 = getSelectedAttributes(select, attributes2)
			var aggregations = extractAggregationsFromArgument(select.arguments)
			var expressions = extractSelectExpressionsFromArgument(select.arguments)
	    	if(aggregations !== null)
				queryAggregations.put(select, aggregations)
			if(expressions !== null)
				queryExpressions.put(select, expressions)
			if(attributes2 !== null)
				queryAttributes.put(select, attributes2)
				
			registry_SimpleSelect.add(select)
		}
	}
	
	def List<NestedSource> registerAllSource(SimpleSelect select)
	{
		var list = newArrayList
		for(Source source : select.sources)
		{
			var name = ''
			if(source instanceof SimpleSource)
			{
				if(!querySources.contains(name = (source as SimpleSource).name))
		        	querySources.add(name)
		        if(source.alias !== null && !getSource(source).aliases.contains(source.alias.name))
					registerSourceAlias(source)
			}
			else if(source instanceof NestedSource)
				list.add(source)
		}
		return list
	}
	
	def private CharSequence parseComplexSelect(SimpleSelect left, SimpleSelect right, String operator) 
	{
		parseSimpleSelect(left)
		var rightSelectOperatorName = getLastOperator()
		registry_SimpleSelect.clear()
		parseSimpleSelect(right)
		var leftSelectOperatorName = getLastOperator()
		return registerOperator(operator + '('+rightSelectOperatorName+','+leftSelectOperatorName+')')
	}
	
	var Map<SimpleSelect, String> registry_SubQueries = newHashMap
	
	/** Parse a select statement and returns its last operator name. */
	def parseSimpleSelect(SimpleSelect stmt)
	{
		prepareParsingSelect(stmt)
		var List<SimpleSelect> subQueries = newArrayList(registry_SimpleSelect)
		
		var CharSequence result
		firstJoinInQuery = true
		expressionCounter = 0
		aggregationCounter = 0
		expressionString = null
		registry_RenamedAttributes.clear()
		for(SimpleSelect subQuery : subQueries)
		{
			if(null === subQuery.predicates)
				if(subQuery.having !== null)
					result = parseSelectWithPredicate(subQuery)
				else
			 		result = parseSelectWithoutPredicate(subQuery)
			else
				result = parseSelectWithPredicate(subQuery)
			registry_SubQueries.put(subQuery, result.toString)
			//If the distinct key word was used, add it to the last operator in the query	
			if(stmt.distinct !== null)
			{
				var operator = registry_Operators.get(getLastOperator())
				operator = "DISTINCT(" + operator + ")"	
				//Update operator
				registry_Operators.put(result.toString, operator)
			}		
		}
	}

	enum Operator
	{
		MAP,
		AGGREGATE
	}	
	
	def private String parseOperator(Operator operator, SimpleSelect select)
	{
		var Object[] result = null
		var String operatorName = null
		switch(operator)
		{
			case MAP:
			{
				var expressions = queryExpressions.get(select)
				if(expressions !== null && !expressions.empty)
				{
					result = buildMapOperator(expressions)
					operatorName = result.get(1).toString
				}	
				
			}
			case AGGREGATE:
			{
				var aggregations = queryAggregations.get(select)
				if(aggregations !== null && !aggregations.empty)
				{
					result = buildAggregateOP(aggregations, select.order, select.sources)
					operatorName = registerOperator(result.get(1).toString)
				}
			}
		}
		return operatorName
	}
	
	def private CharSequence parseSelectWithoutPredicate(SimpleSelect select)
	{
		var String projectInput
		//Build additional operators for aggregatations, expressions, ...
		var String operator1 = parseOperator(Operator.MAP, select)
		var String operator2 = parseOperator(Operator.AGGREGATE, select)
	
		//Query corresponds to a select all	
		if(operator1 === null && operator2 === null && select.arguments.empty)
		{
			projectInput = buildJoin(select.sources).toString
			
			//Return a join over all query sources
			if(select.sources.size > 1)
				return registerOperator(projectInput)
			//Return a projection with one source
			else
				return registerOperator(buildProjection(select, projectInput))
		}
		//Arbitrary query with aggregations and/or expressions and/or simple attributes
		else
		{
			projectInput =  buildInput(select, operator1, operator2)
			return registerOperator(buildProjection(select, projectInput))
		}		
	}
	
	def private CharSequence parseSelectWithPredicate(SimpleSelect stmt)
	{
		//Check if query contains ComplexPredicates like EXISTS, ALL, ANY
		var List<Expression> predicates = newArrayList
		var List<Source>        sources = newArrayList
		if(stmt.predicates !== null)
		{
			predicates.add(0, stmt.predicates.elements.get(0))
			var complexPredicates = EcoreUtil2.getAllContentsOfType(stmt.predicates, ComplexPredicate)
			if(complexPredicates !== null && !complexPredicates.empty && complexPredicates.size > 1)
				throw new IllegalArgumentException('queries with more then one complex predicates are not supported')
		}
		
		if(stmt.having !== null)// extract predicates from having clause
			predicates.add(0, stmt.having.elements.get(0))
		sources.addAll(stmt.sources)
		
	    var String operator1 = parseOperator(Operator.MAP, stmt)
		var String operator2 = parseOperator(Operator.AGGREGATE, stmt)

		predicateStringList.clear()
		parsePredicate(predicates)
		var selectInput = buildInput(stmt, operator1, operator2).toString
		var predicate = parsePredicateString(predicateStringList)
		var select = ''
		if(!predicate.equals(''))
			select = registerOperator('''SELECT({predicate='«predicate»'},«selectInput»)''')
		else
		{
			var Map<String, String> newArgs = registry_existenceOperators.get(0)
			newArgs.put('input', newArgs.get('input')+',' + selectInput)
			registerOperator(builder.buildOperator("EXISTENCE", newArgs))
			return registerOperator(buildProjection(stmt, 'JOIN(' + getLastOperator() + ',' + selectInput + ')'))
		}
				
		registerExistenceOperator(selectInput, select)
		var attributes = newArrayList
		for(SelectArgument arg : stmt.arguments)
			if(arg.attribute !== null)
				attributes.add(arg.attribute)
				
		if(!checkIfSelectAll(attributes) || !queryAggregations.get(stmt).empty || !queryExpressions.get(stmt).empty)
			return registerOperator(buildProjection(stmt, select))
		return select
	}
	
	private def registerExistenceOperator(String selectInput, String select)
	{
		if(!registry_existenceOperators.empty)
		{
			println('registerExistenceOperator() -> selectInput= ' + selectInput)
			if(!select.equals(''))
			{
				for(Map<String, String> args : registry_existenceOperators)
				{
					var Map<String, String> newArgs = args
					newArgs.put('input', args.get('input')+',' + selectInput)
					registerOperator(builder.buildOperator("EXISTENCE", newArgs))
				}
				var t = registry_Operators.get(select)
				registry_Operators.put(select, t.substring(0, t.lastIndexOf('}')) + '},' + 'JOIN(' + getLastOperator() +',' + selectInput +'))')
				var lastOperator = registry_OperatorNames.get(registry_OperatorNames.size - 1)
				registry_OperatorNames.remove(lastOperator)
				registry_OperatorNames.add(registry_OperatorNames.size - 1, lastOperator)
			}
			else
			{
				for(Map<String, String> args : registry_existenceOperators)
				{
					var Map<String, String> newArgs = args
					newArgs.put('input', args.get('input')+','+selectInput)
					registerOperator(builder.buildOperator("EXISTENCE", newArgs))
				}	
			}				
		}
	} 
	
	def String parsePredicateString(List<String> predicateString)
	{
		if(predicateString.size > 0)
		{
			if(predicateString.get(0).equals('&&')
				|| predicateString.get(0).equals('||'))
				predicateString.remove(0)
			if(predicateString.get(predicateString.size - 1).equals('&&')
				|| predicateString.get(predicateString.size - 1).equals('||'))
				predicateString.remove(predicateString.size - 1)
		}
		var predicate = ''
		for(String pred : predicateString)
			predicate += pred
		return predicate
	}
	
	def private CharSequence buildPredicateString(CharSequence sequence)
	{
		lastPredicateElement = sequence
		predicateStringList.add(sequence.toString())
		return predicateString += sequence
	}
	
	var CharSequence lastPredicateElement = ''
	/**Builds a predicate string from a given {@link Expression}. */
	def private CharSequence parsePredicate(Expression e)
	{
		if(!e.eContents.empty)
		{
			switch e
			{
				OrPredicate:
				{
					parsePredicate(e.left)
					buildPredicateString('||')
					parsePredicate(e.right)
					
				}
				AndPredicate:
				{
					parsePredicate(e.left)
					buildPredicateString('&&')
					parsePredicate(e.right)
				}  
				Equality:
				{
					parsePredicate(e.left)
					if(e.op.equals("="))
						buildPredicateString('==')
					else
						buildPredicateString(e.op)
					parsePredicate(e.right)
				}
				Comparision:
				{
					parsePredicate(e.left)
					buildPredicateString(e.op)	  
					parsePredicate(e.right)	
				}
				Plus:
				{
					parsePredicate(e.left)
					buildPredicateString('+')
					parsePredicate(e.right)
				}
				Minus:
				{
					parsePredicate(e.left)
					buildPredicateString('-')
					parsePredicate(e.right)					
				}
				MulOrDiv:
				{
					parsePredicate(e.left)
					buildPredicateString(e.op)
					parsePredicate(e.right)
				}
				NOT:
				{
					buildPredicateString('!')
					parsePredicate(e.expression)
				}
				Bracket:
				{
					buildPredicateString('(') 
					parsePredicate(e.inner)
					buildPredicateString(')') 
				}
				AttributeRef: { buildPredicateString(getAttributename(e.value as Attribute)) }  	 
				ComplexPredicateRef:
				{
					/*
					 * ALLPredciate (false) --> type = NOT_EXISTS
					 * >=  --> <
					 * >   --> <=
					 * <=  --> >
					 * <   --> >=
					 * 
					 * ANYPredicate (false) --> type = EXISTS
					 * >=  --> >=
					 * >   --> >
					 * <=  --> <=
					 * <   --> <
					 * 
					 * IN type (false) --> type = EXISTS
					 * ==
					 * 
					 */
					var complexPredicate = e.value as ComplexPredicate
					var QuantificationPredicate quantification = null
					var ExistPredicate exists = null
					var InPredicate in = null
					if((quantification = complexPredicate.quantification) !== null)
					{
						var type = 'EXISTS'
						var operator = quantification.operator
						if(quantification.predicate.equalsIgnoreCase('ALL'))												
						{
							type = 'NOT_EXISTS'
							if(operator.equals('>='))
								operator = '<'
							else if(operator.equals('>'))
								operator = '<='
							else if(operator.equals('<='))
								operator = '>'
							else if(operator.equals('<'))
								operator = '>='
						}
						//save the current predicate
						var predicateStringListBackup = new ArrayList(predicateStringList)
						predicateStringList = newArrayList
						var predicateBackup = predicateString
						predicateString = ''
//						var attributeAliasesBackup = registry_AttributeAliases
//						registry_AttributeAliases = newHashMap
						
						
						var select = complexPredicate.select.select
						prepareParsingSelect(select)
						var predicate = ''
						if(select.predicates === null)
						{
							parseSelectWithoutPredicate(select)
							for(String attribute : projectionAttributes.get(select))
								predicate += quantification.attribute.name + operator + attribute + '&&'
							predicate = predicate.substring(0, predicate.lastIndexOf('&') - 1)
						}
						else
						{
							parseSelectWithPredicate(select)
							for(String attribute : projectionAttributes.get(select))
								predicate += quantification.attribute.name + operator + attribute + '&&'
							predicate = predicate.substring(0 , predicate.lastIndexOf('&') - 1)
						}
						
						var Map<String, String> args = newHashMap
						args.put('type', type+builder.ESC+builder.STRING_TYPE)
						args.put('input', getLastOperator())
						
						for(Entry<String ,List<String>> l : queryAttributes.get(select).entrySet)
							for(String s : l.value)
							{
								var attributename = s
								if(!attributename.contains('.'))
								{
									attributename = l.key + '.' + attributename
								}
								println(attributename)
								predicate = predicate.replace(attributename, attributename.replace('.', '_'))
							}
						
						
						args.put('predicate', predicate+builder.ESC+builder.STRING_TYPE)
						registry_existenceOperators.add(args)
												
						//restore predicate
						predicateString = predicateBackup
						predicateStringList = new ArrayList(predicateStringListBackup)
//						registry_AttributeAliases = attributeAliasesBackup
					}
					else if((exists = complexPredicate.exists) !== null)
					{
						var type = 'EXISTS'
						if(lastPredicateElement.equals('!'))
						{
							type = 'NOT_EXISTS'
							predicateStringList.remove(predicateStringList.size() - 1)	
							if(predicateStringList.size() - 1 > 0)
							{
								var index = predicateStringList.size() - 2
								var element = predicateStringList.get(index)
								if(element.equals('&&') || element.equals('||'))
									predicateStringList.remove(index)
							}
						}
						else if(lastPredicateElement.equals('&&') || lastPredicateElement.equals('||'))
						{
							if(predicateStringList.size > 0)
								predicateStringList.remove(predicateStringList.size() - 1)
						}
						
						//save the current predicate
						var predicateStringListBackup = new ArrayList(predicateStringList)
						predicateStringList = newArrayList
						var predicateBackup = predicateString
						predicateString = ''

						var Map<String, String> args = newHashMap
						args.put('type', type+builder.ESC+builder.STRING_TYPE)
						
						var subQuery = complexPredicate.select.select as SimpleSelect
						prepareParsingSelect(subQuery)
						parseSelectWithoutPredicate(subQuery)
						parsePredicate(complexPredicate.select.select.predicates.elements.get(0))
						
						println("exists() -> " + predicateString)
						
						for(Entry<String ,List<String>> l : queryAttributes.get(subQuery).entrySet)
							for(String s : l.value)
							{
								var attributename = s
								if(!attributename.contains('.'))
								{
									attributename = l.key + '.' + attributename
								}
								println(attributename)
								predicateString = predicateString.replace(attributename, attributename.replace('.', '_'))
							}
						
						println("exists() -> " + predicateString)
						args.put('predicate', predicateString+builder.ESC+builder.STRING_TYPE)
						args.put('input', getLastOperator())
						registry_existenceOperators.add(args)
						
						//restore predicate
						predicateString = predicateBackup
						predicateStringList = new ArrayList(predicateStringListBackup)
					}
					else if((in = complexPredicate.in) !== null)
					{
						var type = 'EXISTS'
						var operator = '=='
						//save the current predicate
						var predicateStringListBackup = new ArrayList(predicateStringList)
						predicateStringList = newArrayList
						var predicateBackup = predicateString
						predicateString = ''
						
						var select = complexPredicate.select.select
						prepareParsingSelect(select)
						var predicate = ''
						if(select.predicates === null)
						{
							parseSelectWithoutPredicate(select)
							println(projectionAttributes.get(select).toString)
							for(String attribute : projectionAttributes.get(select))
								predicate += in.attribute.name 
								+ operator
								 + attribute + '&&'
							predicate = predicate.substring(0, predicate.lastIndexOf('&') - 1)
						}
						else
						{
							parseSelectWithPredicate(select)
							println(projectionAttributes.get(select).toString)
							for(String attribute : projectionAttributes.get(select))
								predicate += in.attribute.name + 
								operator 
								+ attribute + '&&'
							predicate = predicate.substring(0 , predicate.lastIndexOf('&') - 1)
						}
						
						for(Entry<String ,List<String>> l : queryAttributes.get(select).entrySet)
							for(String s : l.value)
							{
								var attributename = s
								if(!attributename.contains('.'))
								{
									attributename = l.key + '.' + attributename
								}
								println(attributename)
								predicate = predicate.replace(attributename, attributename.replace('.', '_'))
							}
						
//						predicate = predicate.replace('\\.', '_')
						var Map<String, String> args = newHashMap
						args.put('type', type+builder.ESC+builder.STRING_TYPE)
						args.put('input', getLastOperator())
						args.put('predicate', predicate+builder.ESC+builder.STRING_TYPE)
						registry_existenceOperators.add(args)
												
						//restore predicate
						predicateString = predicateBackup
						predicateStringList = new ArrayList(predicateStringListBackup)
					}
				}
			}
		} 
		else
		{
			var str = ''
			switch e
			{
				IntConstant: 	str = e.value + ''
				FloatConstant:  str = e.value + ''
				StringConstant: str = '"' + e.value + '"'
				BoolConstant: 	str = e.value + ''
	
			}
			buildPredicateString(str)
		}
		return predicateString
	}
	
	private var List<Map<String, String>> registry_existenceOperators = newArrayList	
	
	def private CharSequence parsePredicate(List<Expression> expressions)//TODO something is wrong here
	{
		println('parsePredicate(List<Expressions>)')
		predicateString = ''
		for(var i = 0 ; i < expressions.size - 1; i++)
		{
			if(expressions.get(i) instanceof AttributeRef) {}
			else
			{
				predicateString = parsePredicate(expressions.get(i)).toString
				buildPredicateString('&&')
				println('parsePredicate()x -> ' + predicateString)
			}
		}
		predicateString = parsePredicate(expressions.get(expressions.size - 1)).toString
		println('parsePredicate() -> ' + predicateString)
		return predicateString
	}
		
	def private CharSequence parseSelectExpression(SelectExpression e)
	{
		println('parseSelectExpression() -> expression= ' + e)
		var str = ''
		for(var i = 0; i < e.expressions.size; i++)
		{
			var component = (e.expressions.get(i) as ExpressionComponent).value
			switch(component)
			{
				Function: 		str += component.name + '(' + parseSelectExpression((component.value as SelectExpression)) + ')'
				Attribute:		str += getAttributename(component.name)
				IntConstant: 	str += component.value + ''
				FloatConstant:  str += component.value + ''
				BoolConstant: 	str += component.value + ''//TODO Is a bool value feasible?
				StringConstant: str += '\"' + component.value + '\"'
				Vector: 		str += component.value
				Matrix:			str += component.value
			}
			if(i != e.expressions.size - 1)
				str += e.operators.get(i)
		}
		return str
	}	
	
	def CharSequence parseSelectExpressionType(List<Object> components)
	{
		var list = newArrayList
		for(Object comp :components)
		{
			if(comp instanceof IntConstant)
				list.add(SDFDatatype.INTEGER)
			else if(comp instanceof FloatConstant)
				list.add(SDFDatatype.FLOAT)
		}
		return ''
	}
	
	val String VIEW = 'VIEW_KEY_'
	
	def private CharSequence parseCreateView(CreateView view)
	{
		var select = view.select.select as SimpleSelect
		parseSimpleSelect(select)
		var lastOperator = getLastOperator()
		var operatorPlan = registry_Operators.get(getLastOperator())
		registry_Operators.remove(lastOperator)
		registry_OperatorNames.remove(lastOperator)
		registry_Operators.put(VIEW + view.getName(), operatorPlan)
		registry_OperatorNames.add(VIEW + view.getName())
		return view.getName()
	}
	
	
	private val SINK_INPUT_KEYWORD = '--INPUT--'
	def private CharSequence parseCreateAccessFramework(CreateAccessFramework create, String type)
	{
		var String operator
		switch(type.toUpperCase)
		{
			case 'STREAM': operator = 'ACCESS' 
			case 'SINK': operator = 'SENDER'
		}
		operator = buildCreate1(operator, create.pars, create.attributes.arguments, create.attributes.name).toString
		if(type.toUpperCase.equals('SINK'))
			if(!operator.contains(SINK_INPUT_KEYWORD))
				return registerOperator(operator, VIEW + create.attributes.name)
			else 
				registry_Sinks.put(VIEW + create.attributes.name, operator)
		else
			registerOperator(operator, VIEW + create.attributes.name)
		return ''
	}
	
	def private parseCreateDatabaseSink(CreateDatabaseSink sink) 
	{
		var Map<String, String> args = newHashMap
		args.put('connection', sink.database+builder.ESC+builder.STRING_TYPE)
		args.put('table', sink.table+builder.ESC+builder.STRING_TYPE)
		var type = ''
		if(CQLParser.databaseConnections.keySet.contains(sink.database))
			type = CQLParser.databaseConnections.get(sink.database)
		else
			throw new QueryParseException("Database connection " + sink.database + " could not be found");
		args.put('type', type+builder.ESC+builder.STRING_TYPE)
		args.put('input', SINK_INPUT_KEYWORD)
		if(sink.option !== null)
			if(sink.option.toUpperCase().equals("DROP"))
				args.put('drop', 'true'+builder.ESC+builder.STRING_TYPE)
			else
				args.put('truncate', 'true'+builder.ESC+builder.STRING_TYPE)
		var operator = builder.buildOperator("DATABASESINK", args)	
		registry_Sinks.put(sink.name, operator)
	}
	
	def private CharSequence extractSchema(SchemaDefinition schema)
	{
		var attributenames = newArrayList
		var datatypes = newArrayList
		for(var i = 0; i < schema.arguments.size - 1; i = i + 2)
		{
			attributenames.add(schema.arguments.get(i))
			datatypes.add(schema.arguments.get(i + 1))
		}
		return generateKeyValueString(attributenames, datatypes, ',')
	}
	
	def private int getTimeInMilliseconds(String time, int value)
	{
		switch(time.toUpperCase)
		{
		case 'MILLISECONDS',
		case 'MILLISECOND': return value
		case 'SECONDS',
		case 'SECOND': return value * 1000
		case 'MINUTES',
		case 'MINUTE': return value * (60 * 1000)
		case 'HOURS',
		case 'HOUR' : return value * (60 * 60 * 1000)
		case 'DAYS',
		case 'DAY' : return value * (24 * 60 * 60 * 1000)
		case 'WEEKS',
		case 'WEEK': return value * (7 * 24 * 60 * 60 * 1000)
		default: return 0
		}
	}
	
	def parseCreateDatabaseStream(CreateDatabaseStream stream) 
	{
		var Map<String, String> args = newHashMap
		args.put('connection',stream.database + builder.ESC+builder.STRING_TYPE)
		args.put('table',stream.table + builder.ESC+builder.STRING_TYPE)
		args.put('attributes', extractSchema(stream.attributes) + builder.ESC+builder.LIST_TYPE)
		var operator = ''
		var waitMillis = getTimeInMilliseconds(stream.unit.getName, stream.size).toString
		if(!waitMillis.equals('0.0'))
			args.put('waiteach', waitMillis+builder.ESC+builder.INT_TYPE)
		operator = builder.buildOperator("DATABASESOURCE", args)
		return registerOperator(operator, VIEW + stream.attributes.name)		
	}
	
	def private CharSequence parseCreateStreamFile(CreateChannelFormatViaFile file)
	{
		var Map<String, String> args = newHashMap
		args.put('source', file.attributes.name+builder.ESC+builder.STRING_TYPE)
		args.put('wrapper', 'GenericPull'+builder.ESC+builder.STRING_TYPE)
		args.put('protocol', file.type+builder.ESC+builder.STRING_TYPE)
		args.put('transport', 'File'+builder.ESC+builder.STRING_TYPE)
		args.put('dataHandler', 'Tuple'+builder.ESC+builder.STRING_TYPE)
		args.put('schema', extractSchema(file.attributes)+builder.ESC+builder.LIST_TYPE)
		args.put('options', '''['filename','«file.filename»'],['delimiter',';'],['textDelimiter',"'"]'''+builder.ESC+builder.LIST_TYPE)
		var operator = builder.buildOperator("ACCESS", args)	  
		return registerOperator(operator, VIEW + file.attributes.name)
	}
	
	def private CharSequence parseCreateStreamChannel(CreateChannelFrameworkViaPort channel) 
	{
		var Map<String, String> args = newHashMap
		args.put('source', channel.attributes.name+builder.ESC+builder.STRING_TYPE)
		args.put('wrapper', 'GenericPush'+builder.ESC+builder.STRING_TYPE)
		args.put('protocol', 'SizeByteBuffer' + builder.ESC+builder.STRING_TYPE)
		args.put('transport', 'NonBlockingTcp'+builder.ESC+builder.STRING_TYPE)
		args.put('dataHandler', 'Tuple'+builder.ESC+builder.STRING_TYPE)
		args.put('schema', extractSchema(channel.attributes)+builder.ESC+builder.LIST_TYPE)
		args.put('options', '''['port','«channel.port»'],['host', '«channel.host»']''' + builder.ESC+builder.LIST_TYPE)
		var operator = builder.buildOperator("ACCESS", args)	
		return registerOperator(operator, VIEW + channel.attributes.name)	
	}	
	
	def private parseStreamTo(StreamTo query)
	{
		var lastOperator = ''
		var sink = ''
		if(registry_Sinks.keySet.contains(VIEW + query.name))
			sink = registry_Sinks.get(VIEW + query.name)
		else if(registry_Sinks.keySet.contains(query.name))
			sink = registry_Sinks.get(query.name)
	
		if(query.statement !== null)
		{
			parseSimpleSelect(query.statement.select as SimpleSelect)
			lastOperator = getLastOperator()
		}		
		else
			lastOperator = query.inputname
	
		if(sink != '')
		{
			sink = sink.replace("--INPUT--", lastOperator)
			if(!registryBackUp_Operators.empty)
			{
				registry_Operators = registryBackUp_Operators
				registry_OperatorNames = registryBackUp_OperatorNames
				registryBackUp_Operators.clear()
				registryBackUp_OperatorNames.clear()
			}
			registry_Sinks.remove(query.name)
			registerOperator(sink, query.name)
		}
		else
		{ 	
			registry_StreamTo.put(query.name, query.name)
			registryBackUp_Operators = registry_Operators
			registry_Operators.clear()
			registryBackUp_OperatorNames = registry_OperatorNames
			registry_OperatorNames.clear()			
		}
	}
	
	def private String buildInput(SimpleSelect select, String ... operators)
	{
		var String map = null
		var String aggregate = null
		var sources = select.sources
		var String input = null
		
		if(operators !== null && operators.length > 0)
		{
			map = operators.get(0)
			if(operators.length > 1)
				aggregate = operators.get(1)
		}			
		
		println('buildSelectInput() --> mapOperator= ' + map + ', aggregateOperator= ' + aggregate)
		
		if(map !== null && aggregate !== null)
		{
			input = buildJoin(sources).toString//buildJoin(sources.stream.filter(e|e instanceof SimpleSource).map(e|(e as SimpleSource).name).collect(Collectors.toList)).toString
			println('groupByyy')
			if(registry_Operators.get(aggregate).contains('GROUP_BY'))
			{
				var groupAttributes = newArrayList
				var j = 0
				for(var i = 0; i < select.order.size; i++)
				{
					var groupAttribute = select.order.get(i).name
					groupAttributes.add(groupAttribute)
					groupAttributes.add(groupAttribute + '_groupAttribute#' + j)
					j++
				}
				var rename = '''RENAME({aliases=[«generateListString(groupAttributes)»], pairs='true'},«aggregate»)'''
				input = buildJoin(#[rename, input]).toString
				
			}
			else
				input = buildJoin(#[aggregate, buildJoin(sources).toString]).toString
		}
		else if(map !== null)
		{
			input = buildJoin(sources).toString
		}
		else if(aggregate !== null)
		{
			println(projectionAttributes.get(select).toString)
			println(registry_Aggregations.toString)
			//if(registry_Aggregations.containsAll(projectionAttributes.get(select)))
			if(registry_Aggregations.equals(projectionAttributes.get(select)))
				input = aggregate
			else
			{
				input = buildJoin(sources).toString//buildJoin(sources.stream.filter(e|e instanceof SimpleSource).map(e|(e as SimpleSource).name).collect(Collectors.toList)).toString
				println('groupByyy')
				if(registry_Operators.get(aggregate).contains('GROUP_BY'))
				{
					var groupAttributes = newArrayList
					var j = 0
					for(var i = 0; i < select.order.size; i++)
					{
						var groupAttribute = select.order.get(i).name
						groupAttributes.add(groupAttribute)
						groupAttributes.add(groupAttribute + '_groupAttribute#' + j)
						j++
					}
					var rename = '''RENAME({aliases=[«generateListString(groupAttributes)»], pairs='true'},«aggregate»)'''
					input = buildJoin(#[rename, input]).toString
				}
				else
					input = buildJoin(#[aggregate, input]).toString
			}
		}
		else
			input = buildJoin(sources).toString
		return input
	}
	
	def private CharSequence buildWindowOP(SimpleSource src)
	{
		if(src.window !== null)
		{
			var window = src.window
			if(window instanceof TimebasedWindow)
			{
				var var1 = if(window.advance_size != 0) window.advance_size.toString else '1'
				var var2 = if(window.advance_size != 0) window.advance_unit.getName else window.unit.getName
				return builder.buildTimebasedWindowOperator(window.size.toString, window.unit.getName, var1, var2, src.name)
			}
			else if(window instanceof TuplebasedWindow)
			{
				var var1 = if(window.advance_size != 0) window.advance_size else 1
				if(window.partition_attribute === null)
				{
					return  '''ELEMENTWINDOW
							   (
							   	{
									size = «window.size»,
									advance = «var1»
							   	},
							   	«src.name»
							   )'''
	
				}
				else
				{
					return  '''ELEMENTWINDOW
							   (
							   	{
									size = «window.size»,
									advance = «var1»,
									partition = '«window.partition_attribute.name»'
							   	},
							   	«src.name»
							   )'''
				}	
			}
		}
		return src.name
	}
	
	val EXPRESSSION_NAME_PREFIX = 'expression_'
	def private String getExpressionName() { return  EXPRESSSION_NAME_PREFIX + (expressionCounter++) }
	def private String getAggregationName(String name) { return  name + '_' + (aggregationCounter++) }

	def private String getProjectAttribute(String attribute)
	{
		if(attribute.contains(EXPRESSSION_NAME_PREFIX))
			return registry_Expressions.get(attribute)
		if(registry_Expressions.keySet.contains(attribute))
			return registry_Expressions.get(attribute)
		println('getProjectionAttribute() -> ' +attribute )
		println(registry_AttributeAliases.toString)
		if(attribute.contains('.'))
		{
			if(attribute.isAttributeAlias)
				return attribute
				
			var split = attribute.split('\\.')
			var realAttributename = split.get(1)
			var sourcename = split.get(0)
			var sourcealias = sourcename
			if(sourcename.isSourceAlias)
				sourcename = getSourcenameFromAlias(sourcealias)
			var aliases = getSource(sourcename).findbyName(realAttributename).aliases
			if(!aliases.empty)
				return aliases.get(aliases.size - 1)
			
			return attribute
		}
		return attribute
	} 
	
	def private Object[] buildMapOperator(List<SelectExpression> expressions) { return buildMapOperator(expressions, null) }
	
	def private Object[] buildMapOperator(List<SelectExpression> expressions, CharSequence input)
	{
		var expressionArgument = ''
		var List<String> expressionStrings = newArrayList()
		var List<String> attributeNames = newArrayList()
		for(var i = 0; i < expressions.size; i++)
		{
			var expressionName  = ''
			var expressionString = parseSelectExpression(expressions.get(i)).toString
//			var expressionType = MEP.instance.parse(expressionString).returnType.toString //parseSelectExpressionType(expressionComponents)
//			println("expressiontype:: " + expressionType)
			if(expressions.get(i).alias ===  null)
				expressionName = getExpressionName()
			else
				expressionName = expressions.get(i).alias.name	
			expressionStrings.add(expressionString)
			expressionStrings.add(expressionName)
			expressionStrings.add(',')
			var t = generateKeyValueString(expressionStrings)
			expressionArgument += t
			registry_Expressions.put(expressionName, t)
			if(i != expressions.size - 1) expressionArgument += ','
			expressionStrings.clear
			attributeNames.add(expressionName)
		}
//		Collections.sort(attributeNames)
		return #[attributeNames, '''MAP({expressions=[«expressionArgument»]},«input»)''']//TODO refactore
	}
	
	def private Object[] buildAggregateOP(List<SelectExpression> aggAttr, List<Attribute> orderAttr, CharSequence input)
	{
		var argsstr 			 = ''
		var List<String> args    = newArrayList
		var List<String> aliases = newArrayList
		var mapName = ''
		for(var i = 0; i < aggAttr.length; i++)
		{
			var aggregation = aggAttr.get(i).expressions.get(0).value as Function
			var attributename = ''
			var datatype = ''
			var components = (aggregation.value as SelectExpression).expressions
			if(components.size == 1)
			{
				var comp = components.get(0).value
				switch(comp)
				{
					Attribute:
					{
						attributename = getAttributename(comp.name)
						datatype = getDataTypeFrom(attributename)
					}
					Starthing: { attributename = '*' }
				}
			}
			else
			{
				var mapOperator = buildMapOperator(#[aggregation.value as SelectExpression], input)
				mapName = registerOperator(mapOperator.get(1) as CharSequence)
				attributename = (mapOperator.get(0) as List<String>).get(0)
				datatype = 'DOUBLE'
			}
			
			args.add(aggregation.name)
			args.add(attributename)
			var alias = ''
			if(aggAttr.get(i).alias !== null)
				alias = aggAttr.get(i).alias.name
			else
				alias = getAggregationName(aggregation.name)
			args.add(alias)
			aliases.add(alias)

			if(datatype != '') args.add(datatype)
			registry_Aggregations.add(alias)
			args.add(',')
			argsstr += generateKeyValueString(args)
			if(i != aggAttr.length - 1) argsstr += ','
			args.clear
		}
		//Generates the group by argument that is formed like ['attr1', attr2', ...]
		var groupby = ''
		if(!orderAttr.empty)
		{
			groupby += ',GROUP_BY=['
			groupby += generateListString(
				orderAttr.stream.map(e|getAttributename(e.name, null)).collect(Collectors.toList)
			) + ']'
		}
		return #[aliases, '''AGGREGATE({AGGREGATIONS=[«argsstr»]«groupby»}, «IF mapName != ''»«mapName»«ELSE»«»«input»«ENDIF»)''']
	}
	
	def private Object[] buildAggregateOP(List<SelectExpression> list, List<Attribute> list2, List<Source> srcs) { return buildAggregateOP(list, list2, buildJoin(srcs)) }
	
	def private CharSequence buildCreate1(String type, AccessFramework pars, List<String> attrs, String name)
	{
		var wrapper     = pars.wrapper
		var protocol    = pars.protocol
		var transport   = pars.transport
		var dataHandler = pars.datahandler
		var attributenames = newArrayList
		var datatypes = newArrayList
		for(var i = 0; i < attrs.size - 1; i = i + 2)
		{
			attributenames.add(attrs.get(i))
			datatypes.add(attrs.get(i + 1))
		}
		var args 		= generateKeyValueString(
							attributenames,
							datatypes,
							','
						  )
						  
		var options 	= generateKeyValueString(
							pars.keys,
							pars.values,
							','
						  )		
		var t = ''
		var s = ''
		var b = false
		if(type.equals("ACCESS"))
		{
			t = 'source'
			s = '''schema = [«args»],'''	
		}
		else
		{
			b = true
			t = 'sink'	
		}				  

		var input = "--INPUT--"
		if(registry_StreamTo.keySet.contains(name))
			input = registry_StreamTo.get(name)
						  
		var sink = '''«type»
				  (
					{	  
						«t»      = '«name»', 
						wrapper     = '«wrapper»',
						protocol    = '«protocol»',
						transport   = '«transport»',
						dataHandler = '«dataHandler»',
						«s»
						options =[«options»]
					 }
					 «IF b»,«input»«ENDIF»
				   )'''
		return sink
	}	
	
	def private buildJoin(List<Source> sources)
	{
		var String[] sourceStrings = newArrayOfSize(sources.size)
		var List<String> sourcenames = newArrayList
		
		var simpleSources = sources.stream.filter(e|e instanceof SimpleSource).map(e| e as SimpleSource).collect(Collectors.toList)
		var subQueries = sources.stream.filter(e|e instanceof NestedSource).map(e| e as NestedSource).collect(Collectors.toList)
		
		for(var i = 0; i < sources.size; i++)
		{
			var source = sources.get(i) 
			if(source instanceof NestedSource)
			{
				var query = registry_SimpleSelect.get(registry_SimpleSelect.size - 1) 
				var queryAttributess = queryAttributes.get(query)
				var subQuery = source.statement.select as SimpleSelect
				var subQueryAttributes = queryAttributes.get(subQuery)
				var lastOperator = registry_SubQueries.get(subQuery)
				var inputs = newArrayList
				var attributeAliases = getAttributeAliasesAsList()
				for(Entry<String, List<String>> entry : queryAttributess.entrySet)
				{
					var attributes = subQueryAttributes.get(entry.key)
					if(attributes !== null)
					{
						var aliasses = newArrayList
						for(String name : attributes)
							for(String name2 : entry.value)
							{
								var realName = name
								var realName2 = name2
								if(attributeAliases.contains(realName))
									realName = getAttributenameFromAlias(realName)
								if(attributeAliases.contains(realName2))
									realName2 = getAttributenameFromAlias(realName2)
								
								if(realName.contains('.'))
									realName = name.split('\\.').get(1)
								if(realName2.contains('.'))
									realName2 = realName2.split('\\.').get(1)
								
								if(realName.equals(realName2))
								{
									aliasses.add(name.replace('.', '_'))
									aliasses.add(name2)
								}
							}
						inputs.add(registerOperator('''RENAME({aliases=[«generateListString(aliasses)»], pairs='true'}, «lastOperator»)'''))						
					}
				}
				sourceStrings.set(i, buildJoin(inputs).toString)
			}
			else if(source instanceof SimpleSource)
			{
				// Reset sorucesDuringrename?
				println("buildJoin() --> SimpleSource")
				//Check for self join
				val sourcename = source.name
				val count = sourcenames.stream.filter(e|e.equals(sourcename)).count
				sourcenames.add(sourcename)
				sourcesDuringRename = sources 
				sourceStrings.set(i, 
					buildRenameOperatorX(
						buildWindowOP(source), source, count as int
					).toString
				)
			}
		}	
		return buildJoin(sourceStrings)
	}
	
	def List<String> computeSelfJoin(List<String> aliases, int selfJoin, int counter, SourceStruct sourceStruct, SimpleSource source)
	{
		if(selfJoin > 0 && counter != sourceStruct.attributes.size)
		{
			var newAliases = newArrayList
			for(String attributename : getAttributeNamesFrom(source.name))
			{
				if(!aliases.contains(attributename))
				{
					//Choose an alias for the self joined attribute
					var newAlias = source.name + '.' + attributename + '#' + selfJoin
					newAliases.add(attributename)
					newAliases.add(newAlias)
					aliases.add(attributename)
					aliases.add(newAlias)
				}
			}
		}
		return aliases
	}
	
	var List<String> renameAliases = newArrayList
	var List<String> processedSources = newArrayList
	var List<Source> sourcesDuringRename
	def CharSequence buildRenameOperatorX(CharSequence input, SimpleSource simpleSource, int selfJoin)
	{
		var source = getSource(simpleSource)
		var String sourcealias = null
		if(simpleSource.alias !== null)
			sourcealias = simpleSource.alias.name
		var listOfLists = newArrayList()
		
		for(var j = 0; j < source.attributes.size; j++)
		{
			var k = 0
			for(String attributealias : source.attributes.get(j).aliases)
			{
				var sourceFromAlias = registry_AttributeAliases.get(attributealias)
				println('buildRename() -> ' + attributealias + ',' + sourceFromAlias)
				if(sourceFromAlias.equals(sourcealias) || sourceFromAlias.equals(simpleSource.name))
				{
					var b = listOfLists.size <= k
					var List<String> list 
					if(b)
						list = newArrayList
					else 
						list = listOfLists.get(k)
					list.add(source.attributes.get(j).attributename)
					list.add(attributealias)
					if(b) listOfLists.add(list)
					k++
				}
			}
		}
		//self join			
		if(listOfLists.size > 1 || selfJoin > 0 || sourcealias !== null)
		{
			for(var j = 0; j < listOfLists.size; j++)
			{
				var list = listOfLists.get(j)
				for(var k = 0; k < source.attributes.size; k++)
					if(!list.contains(source.attributes.get(k).attributename))
					{
						var String alias = null
						var name =  source.attributes.get(k).attributename
						if(sourcealias !== null)
							if(j > 0 && listOfLists.size > 1) 
								alias = generateAlias(name, source.sourcename, j) 
							else 
								alias = sourcealias + '.' + name
						
						renameAliases.add(name)
						renameAliases.add(source.sourcename)
						renameAliases.add(alias)
						list.add(name)
						list.add(alias)
					}	
			}			
		}
		
		var renames = newArrayList
		processedSources.add(source.sourcename)
//		renames.add(source.sourcename)
		for(var j = 0; j < listOfLists.size; j++)
			renames.add(registerOperator('''RENAME({aliases=[«generateListString(listOfLists.get(j))»], pairs='true'}, «input»)'''))
		if(renames.size > 1)
			return buildJoin(renames)
		if(renames.size == 1)
			return renames.get(0)
		return input						
	}
	
	def private String generateAlias(String attributename, String sourcename, int number)
	{
		var alias = sourcename + '.' + attributename + '#' + (number)
		if(renameAliases.contains(alias))
			return alias = generateAlias(attributename, sourcename, number + 1)
		return alias
	}
	
/*
 * def CharSequence buildRenameOperatorX(CharSequence input, SimpleSource source, int selfJoin)
	{
		var List<String> aliases = newArrayList
		var sourcealias = if(source.alias !== null) source.alias.name else null
		var sourceStruct = getSource(source)
		var aliasedAttributes = newArrayList
		var counter = 0
		//Check for aliases
		for(AttributeStruct struct : sourceStruct.attributes)
		{
			for(String structAlias : struct.aliases)
			{				
				var correspondingSource = registry_AttributeAliases.get(structAlias)
				println("correspondingSource= " + correspondingSource)
				if(correspondingSource.contains('.'))
				{
					var split = correspondingSource.split("\\.")
					val realSourcename = split.get(0)
					if(sourcealias !== null)
					{
						println("selfJoin= " +  selfJoin)
						println("source= " + source.name)
						println("realSourcename= " + realSourcename)
						println("sourcealias !== null :: " + sourcealias + ', ' + source.name)
						if(realSourcename.equals(sourcealias) || realSourcename.equals(source.name))
						{
							var countSources = 0//sourcesDuringRename.stream.filter(e|e.name.equals(realSourcename)).count
							for(Source s1 : sourcesDuringRename)
								if(s1 instanceof SimpleSource)
									if(s1.name.equals(realSourcename))
										countSources++
							if(aliases.contains(struct.attributename) || (countSources > 1))
							{
//								throw new IllegalArgumentException("given attribute " + struct.attributename + " with alias " + structAlias + " cannot be referenced")
								if(selfJoin > 0 && counter != sourceStruct.attributes.size)
								{
									var newAliases = newArrayList
									for(String attributename : getAttributeNamesFrom(source.name))
									{
										if(!aliases.contains(attributename))
										{
											//Choose an alias for the self joined attribute
											var newAlias = source.name + '.' + attributename + '#' + selfJoin
											newAliases.add(attributename)
											newAliases.add(newAlias)
											aliases.add(attributename)
											aliases.add(newAlias)
										}
									}
								}
								var i = registerOperator('''RENAME({aliases=[«generateListString(aliases)»], pairs='true'}, «input»)''')
								aliases.clear()
								aliases.add(struct.attributename)
								aliases.add(structAlias)
								if(selfJoin > 0 && counter != sourceStruct.attributes.size)
								{
									var newAliases = newArrayList
									for(String attributename : getAttributeNamesFrom(source.name))
									{
										if(!aliases.contains(attributename))
										{
											//Choose an alias for the self joined attribute
											var newAlias = source.name + '.' + attributename + '#' + (selfJoin + 1)
											newAliases.add(attributename)
											newAliases.add(newAlias)
											aliases.add(attributename)
											aliases.add(newAlias)
										}
									}
								}
								var j = registerOperator('''RENAME({aliases=[«generateListString(aliases)»], pairs='true'}, «input»)''')
								return '''JOIN(«i»,«j»)'''													
							}
							else
							{
								aliases.add(struct.attributename)
								aliases.add(structAlias)
							}
							counter++
						}
					}
					else
					{
						println('buildRenameOperatorX() -> realSourcename= ' + realSourcename + ', source.name= ' + source.name)
						if(realSourcename.equals(source.name))
						{
							if(aliases.contains(struct.attributename))
							{
								
								
//								throw new IllegalArgumentException("given attribute " + struct.attributename + " cannot be referenced")
							}
							aliases.add(struct.attributename)
							aliases.add(structAlias)
							counter++
						}
						else if(realSourcename.isSourceAlias && getSourcenameFromAlias(realSourcename).equals(source.name))
						{
							if(aliases.contains(struct.attributename))
								throw new IllegalArgumentException("given attribute " + struct.attributename + " cannot be referenced")
							aliases.add(struct.attributename)
							aliases.add(structAlias)
							counter++
						}
						else
							throw new IllegalArgumentException("given attribute " + struct.attributename + " cannot be referenced")
					}
				}
				else
				{
					if(correspondingSource.equals(source.name))
					{
						if(aliases.contains(struct.attributename))
							throw new IllegalArgumentException("given attribute " + struct.attributename + " cannot be referenced")
						aliases.add(struct.attributename)
						aliases.add(structAlias)
						counter++
					}
				}
			}
			aliasedAttributes.add(struct.attributename)
		}
		if(selfJoin > 0 && counter != sourceStruct.attributes.size)
		{
			var newAliases = newArrayList
			for(String attributename : getAttributeNamesFrom(source.name))
			{
				if(!aliases.contains(attributename))
				{
					//Choose an alias for the self joined attribute
					var newAlias = source.name + '.' + attributename + '#' + selfJoin
					newAliases.add(attributename)
					newAliases.add(newAlias)
					aliases.add(attributename)
					aliases.add(newAlias)
				}
			}
		}
		//Build rename operator
		if(!aliases.empty)
			return registerOperator('''RENAME({aliases=[«generateListString(aliases)»], pairs='true'}, «input»)''')
		return input
	}
 */
	def private CharSequence buildJoin(String[] srcs)
	{
		var sourcenames = srcs
		if(sourcenames.size < 1)
			throw new IllegalArgumentException("Invalid number of source elements: There have to be at least two sources")
		if(sourcenames.size == 1)//Will only be considered if the first call of this method provides a single source
		{
			firstJoinInQuery = true
			return sourcenames.get(0)
		}
		var List<String> list = new ArrayList(Arrays.asList(sourcenames))
		if(list.size == 2)
		{
			firstJoinInQuery = true
			return '''JOIN(«sourcenames.get(0)»,«sourcenames.get(1)»)'''
		}
		list.remove(0)
		return '''JOIN(«sourcenames.get(0)»,«buildJoin(list)»)'''
	}

	def private CharSequence buildProjection(SimpleSelect select, CharSequence operator)
	{
		var attributes = projectionAttributes.get(select)
		var sources = projectionSources.get(select)
		
		//Add new aliases from the rename operation		
		for(var i = 0; i < renameAliases.size - 2; i = i + 3)
		{
			var attributename = renameAliases.get(i)
			var sourcename = renameAliases.get(i + 1)
			var alias = renameAliases.get(i + 2)
			getSource(sourcename).findbyName(attributename).aliases.add(alias)
		}
		
		var list = newArrayList
		var additionalSources = newArrayList
		for(var i = 0; i < attributes.size; i++)
		{
			var attribute1 = getProjectAttribute(attributes.get(i))
//			var attribute1 = getProjectAttribute(attributes.get(i - 1))
//			var attribute2= getProjectAttribute(attributes.get(i))
//			println(attribute1)
//			println(attribute2)
//			var source1 = sources.get(i - 1)
//			var source2 = sources.get(i)
//			if(attribute1.isAttributeAlias 
//				&& !attribute2.isAttributeAlias 
////				&& getAttributeFromAlias(attribute1).equals(attribute2)
//			)
//			{
//				if(source2 !== null 
//					&& source1 !== null 
//					&& !additionalSources.contains(source1)
//				)
//				{
//					if(source1.equals(source2))
//						additionalSources.add(source1)
//				}
//			}
//			if(!list.contains(attribute1))
				list.add(attribute1)
//			list.add(attribute2)
		}
//		
//		println('buildProjection() -> ' + additionalSources.toString)
//		var List<String> sourcesS = newArrayList
//		sourcesS.add(operator.toString)
//		for(String name : additionalSources)
//			for(Source src : select.sources)
//				if(src instanceof SimpleSource)
//					if(src.name.equals(name))
//						sourcesS.add(buildWindowOP(src).toString)
//		
		
		//Add new aliases from the rename operation		
		for(var i = 0; i < renameAliases.size - 2; i = i + 3)
		{
			var attributename = renameAliases.get(i)
			var sourcename = renameAliases.get(i + 1)
			var alias = renameAliases.get(i + 2)
			getSource(sourcename).findbyName(attributename).aliases.remove(alias)
		}
		
		var argument = generateListString(list)
		.replace("'['", "['")
		.replace("']'", "']")
		return '''MAP({expressions=[«argument»]},«operator»)'''			
	}
		
	def boolean checkIfSelectAll(List<Attribute> attributes)
	{
		if(attributes.empty) return true
		else
			for(Attribute attribute : attributes)
				if(!attribute.name.contains('.*'))
					return false
		return true
	}	
		
	def private String getLastOperator() { return if(registry_OperatorNames.size > 0)  registry_OperatorNames.get(registry_OperatorNames.size - 1) else null }
	
	//TODO rename method
	def public List<String> getAttributesFromSource(String attributename)
	{
		if(attributename.contains('.*'))
		{
			var String sourcename = attributename.split("\\.").get(0)
			var l = getAttributeNamesFrom(sourcename)
			return l 
		}
		return newArrayList
	}
	
	def public List<String> getSourceNames() { return registry_Sources.stream.map(e|e.sourcename).collect(Collectors.toList) }
	
	def public List<String> getSourceAliasesAsList()
	{
		var list = newArrayList
		for(List<String> l : getSourceAliases().values)
			list.addAll(l)
		return list
	}
		
	def private Map<String, List<String>> addToMap(Map<String, List<String>> map, String attribute, String realSourcename)
	{
        var attributeList = map.get(realSourcename)
        if(attributeList === null)
            attributeList = newArrayList
        if(!attributeList.contains(attribute))
            attributeList.add(attribute)
        map.put(realSourcename, attributeList)
        return map
	}	
		
	def private Object[] parseAttribute(Attribute attribute)
	{
        var String sourcename
        var String sourcealias
        var List<String> list
        var boolean subQuery
        if(attribute.name.contains('.'))
        {
           var split = attribute.name.split("\\.")
           sourcename = split.get(0)
           if(!getSourceNames().contains(sourcename))
           {
	           sourcealias = sourcename
               if((sourcename = getSourcenameFromAlias(sourcename)) === null 
               	&& registry_SubQuerySources.keySet.contains(split.get(0))
               )
               		subQuery = true
           }
           if(split.get(1).contains('*'))
           {
               list = newArrayList
               sourcename = split.get(0)
               if(sourcename.isSourceAlias)
               {
               		sourcealias = sourcename
               		sourcename = getSourcenameFromAlias(sourcename)
               }
               for(String str : getAttributeNamesFrom(sourcename))
                   list.add(str)
           }
        }
    	return #[attribute.name, sourcename, sourcealias, list, subQuery]
	}	
	
	def private List<SourceStruct> getSourceCandidates(Attribute attribute, List<Source> sources)
	{
		var containedBySources = newArrayList
		for(Source source1 : sources)
		{
			if(source1 instanceof SimpleSource)
			{
				for(SourceStruct source2 : registry_Sources)
				{
					if(source1.name.equals(source2.sourcename) && source2.containsAttribute(attribute.name)
						&& sources.stream.map(e|if(e instanceof SimpleSource) e.name).collect(Collectors.toList).contains(source2.sourcename)
					)
					{
						if(!containedBySources.contains(source2))
							containedBySources.add(source2)
						else
							if(!attribute.name.contains('.'))
								if(!isAttributeAlias(attribute.name))											
									throw new IllegalArgumentException(attribute.name)//TODO Add exception message
					}
				}
			}
			else
			{
				var subQueryAlias = (source1 as NestedSource).alias.name
				for(String source : registry_SubQuerySources.get(subQueryAlias))
				{
					for(SourceStruct source2 : registry_Sources)
					{
						var realName = attribute.name
						if(realName.contains('.'))
							realName = realName.split('\\.').get(1)
						if(source.equals(source2.sourcename)
							&& source2.containsAttribute(realName) ///!!!!
//							&& sources.stream.map(e|if(e instanceof SimpleSource) e.name).collect(Collectors.toList).contains(source2.sourcename)
						)
						{
							if(!containedBySources.contains(source2))
								containedBySources.add(source2)
							else
							{//TODO comment
								if(!attribute.name.contains('.'))
								{
									if(!isAttributeAlias(attribute.name))											
										throw new IllegalArgumentException(attribute.name)
								}
							}
						}
					}
				}
			}
		}
		return containedBySources
	}
		
	def private String registerAttributeAliases(Attribute attribute, String attributename, String realSourcename, String sourcenamealias, boolean isSubQuery)
	{
		println('registerAttributeAliases() -> attribute= ' + attributename + ', realSourcename= ' + realSourcename + ', sourcenameAlias= ' + sourcenamealias + ', isFormSubQuery= ' + isSubQuery)
		var simpleAttributename = if(attribute.alias !== null) attribute.name else attributename
		if(simpleAttributename.contains('.')) simpleAttributename = simpleAttributename.split("\\.").get(1)
		var alias = sourcenamealias
		for (AttributeStruct attr1 : getSource(realSourcename).attributes)
		{
			if (attr1.attributename.equals(simpleAttributename))
			{
				if (alias === null) alias = realSourcename
				if(attribute.alias !== null)
				{
					if(registry_AttributeAliases.entrySet.contains(attribute.alias.name))
						throw new IllegalArgumentException("given alias " + attribute.alias.name + " is ambiguous")
					if(!attr1.aliases.contains(attribute.alias.name))
					{
						attr1.aliases.add(attribute.alias.name)
						registry_AttributeAliases.put(attribute.alias.name, alias)
					}
					return attribute.alias.name
				}
				else if(attribute.alias === null && getSourceAliasesAsList().contains(alias))
				{
					if(!attr1.aliases.contains(attributename))
					{
						attr1.aliases.add(attributename)
						registry_AttributeAliases.put(attributename, alias)
					}
					return attributename
				}
			}
		}
		return null
	}	
	
	def private boolean isSame(String attribute1, String attribute2)
	{
		var name1 = attribute1
		var name2 = attribute2
		var source1 = ''
		var source2 = ''
		if(name1.contains('.'))
		{
			var split = name1.split('\\.')
			name1 = split.get(1)
			source1 = split.get(0)
		}
		
		if(name2.contains('.'))
		{
			var split = name2.split('\\.')
			name2 = split.get(1)
			source2 = split.get(0)
		}
		
		if(getAttributeAliasesAsList().contains(name1))
			name1 = getAttributeFromAlias(name1).attributename
		if(getAttributeAliasesAsList().contains(name2))
			name2 = getAttributeFromAlias(name2).attributename
		if(getSourceAliasesAsList().contains(source1))
			source1 = getSourcenameFromAlias(source1)
		if(getSourceAliasesAsList().contains(source2))
			source2 = getSourcenameFromAlias(source2)	
			
		if(name1.equals(name2))
			if(source1 == '' || source2 == '')
				return true
			else if(source1.equals(source2))
				return true
		return false
	}
	
	def private boolean contains(List<Attribute> list, Attribute attribute)
	{
		for(Attribute element : list)
			if(isSame(attribute.name, element.name))
				return true
		return false
	}	
		
	/** Returns all attributes with its corresponding sources from a select statement. */
	def private Map<String, List<String>> getSelectedAttributes(SimpleSelect select, Map<String, List<String>> var2)
	{
	    var map = var2
		var attributes = newArrayList
		var String[] attributeOrder = newArrayOfSize(select.arguments.size)
		var String[] sourceOrder = newArrayOfSize(select.arguments.size)
		//Get all attributes from select arguments		
		for(SelectArgument argument : select.arguments)
		{
			if(argument.attribute !== null)
				attributes.add(argument.attribute)
			else if(argument.expression !== null)//Attributes that are contained by functions or aggregations
			{
				var expressionAttributes = EcoreUtil2.getAllContentsOfType(argument.expression, Attribute)
				for(Attribute attribute : expressionAttributes)
					if(!attributes.stream.map(e|e.name).collect(Collectors.toList).contains(attribute.name))
						attributes.add(attribute)
						//TODO insert if(!contains(attributes, attribute)) attributes.add(attribute) here
			}
		}
		//Check if it's a select * query and add for each source its attributes.
		//Return the computed attribute set
		if(attributes.empty && EcoreUtil2.getAllContentsOfType(select, SelectExpression).empty)
		{
			var List<String> attributeOrderList = newArrayList
			var List<String> sourceOrderList = newArrayList
			for(Source source : select.sources)
	        	if(source instanceof SimpleSource)
	                for(String attribute : getAttributeNamesFrom(source.name))
	                {
		            	if(source.alias !== null)
		            	{
		            		var attributealias = source.alias.name + '.' + attribute
		            		getSource(source.name).findbyName(attribute).aliases.add(attributealias)
							registry_AttributeAliases.put(attributealias, source.alias.name) 
//							registerAttributeAliases(attribute, attributename, sourcename, sourcealias, isFromSubQuery)    
//							registerAttributeAliases(..) //TODO insert method here
							attributeOrderList.add(attributealias)
			                map = addToMap(map, attributealias, source.name)
		            	}
		            	else
		            		attributeOrderList.add(source.name + '.' + attribute)
		            	map = addToMap(map, attribute, source.name)
	            		sourceOrderList.add(source.name)
                	}
            attributeOrder = attributeOrderList
            sourceOrder = sourceOrderList
            projectionAttributes.put(select, attributeOrder)
            projectionSources.put(select, sourceOrder)
    		return map
        }
		//Get all attributes from predicates
		if(select.predicates !== null)
		{
			var list = EcoreUtil2.getAllContentsOfType(select.predicates, Attribute)
			for(Attribute attribute : list)
				if(attribute.name.contains('.'))
				{
					var split = attribute.name.split('\\.')
					var sourcename = split.get(0)
					var attributename = split.get(1)
					if(sourcename.isSourceAlias && !attributename.isAttributeAlias)
						registerAttributeAliases(attribute, attribute.name, getSourcenameFromAlias(sourcename), sourcename, false)
//					else
//						registerAttributeAliases(attribute, attributename, sourcename, null, false)
				}
//				if(!contains(attributes, attribute))
//				{
//							
//					attributes.add(attribute)
//				}
		}

		var i = 0
        //Iterate over all found attributes
		for(Attribute attribute : attributes)
		{
			//Compute source candidates for the current attribute
			var sourceCandidates = getSourceCandidates(attribute, select.sources)
			//Parse the current attribute and get its informations			
			var result = parseAttribute(attribute)
			var attributename = result.get(0) as String
			var sourcename = result.get(1) as String
			var sourcealias = result.get(2) as String
			var String attributealias
			var list = result.get(3) as List<String>
			var isFromSubQuery = result.get(4) as Boolean
			if(attribute.alias !== null)
				attributename = attribute.alias.name 
			
            if (sourceCandidates.size > 0) 
            {
            	if (sourceCandidates.size > 1 && sourcename === null) 
					throw new IllegalArgumentException("attribute " + attributename + " is ambiguous: possible sources are " + sourceCandidates.toString)
				
				if(sourceCandidates.size == 1) 
				{
				    sourcename = sourceCandidates.get(0).sourcename
					if (list !== null)
						for (String name : list)
							map = addToMap(map, name, sourcename)
				}
				map = addToMap(map, attributename, sourcename)
				if(isFromSubQuery)
					registerSourceAlias(sourcename, sourcealias)
				attributealias = registerAttributeAliases(attribute, attributename, sourcename, sourcealias, isFromSubQuery)
			}
			else 
			{
			    if(list !== null)
			    	for (String name : list)
			    	{
			    		map = addToMap(map, name, sourcename)
			    		registerAttributeAliases(attribute, sourcealias + '.' + name, sourcename, sourcealias, isFromSubQuery)
		    		}
			}
			//Place the current attribute in the right order
			attributeOrder = computeProjectionAttributes(attributeOrder, select, attribute, attributename, attributealias, sourcename)
			sourceOrder.set(i, sourcename)
			i++
		}
		attributeOrder = computeProjectionAttributes(attributeOrder, select, null, null, null, null)
		projectionAttributes.put(select, attributeOrder)
		projectionSources.put(select, sourceOrder)
		
		println("getSelectedAttributes() -> map= "+map.toString + ', order= ' + attributeOrder.toString)
		return map
	}
	
	def private String[] computeProjectionAttributes(String[] list, SimpleSelect select, Attribute attribute, String attributename, String attributealias, String sourcename)
	{
		expressionCounter=0
		aggregationCounter=0
		var i = 0
		var attributeOrder = list
		var Object candidate
		if(attribute !== null)
		{
			for(SelectArgument argument : select.arguments)
			{
				if((candidate = argument.attribute) !== null)
					if((candidate as Attribute).name.equals(attribute.name))
						if((candidate as Attribute).alias !== null)
							attributeOrder.set(i, (candidate as Attribute).alias.name)
						else if(attributealias !== null)
							attributeOrder.set(i, attributealias)
						else
						{
							if(attributename.contains('.'))
							{
								var split = attributename.split('\\.')
								var name = split.get(1)
								var source = split.get(0)
								var salias = source
								if(isSourceAlias(source))
									source = getSourcenameFromAlias(salias)
								if(name.equals('*'))
								{
									//TODO Query with stream1.*, stream.* would be overriden!
									var attributeOrderList = new ArrayList(attributeOrder.size)
									for(String str : getAttributeNamesFrom(source))
									{
										attributeOrderList.add(salias + '.' + str)
										i++
									}
									attributeOrder = attributeOrderList 
								}								
								else
									attributeOrder.set(i, attributename)
							}
							else
								attributeOrder.set(i, sourcename + '.' + attributename)
						}
						
				if((candidate = argument.expression) !== null)
				{
					if((candidate as SelectExpression).alias !== null)
						attributeOrder.set(i, (candidate as SelectExpression).alias.name)
					else
					{
						if((candidate as SelectExpression).expressions.size == 1)
						{
							var function = (candidate as SelectExpression).expressions.get(0) .value
							if(function instanceof Function)
								if(nameProvider.isAggregation(function.name))
									attributeOrder.set(i, getAggregationName(function.name))
								else
									attributeOrder.set(i, getExpressionName())
						}
						else
							attributeOrder.set(i, getExpressionName())
					}
				}
				i++ 
			}
		}
		else
		{
			for(SelectArgument argument : select.arguments)
			{
				if((candidate = argument.expression) !== null)
				{
					if((candidate as SelectExpression).alias !== null)
						attributeOrder.set(i, (candidate as SelectExpression).alias.name)
					else
					{
						if((candidate as SelectExpression).expressions.size == 1)
						{
							var function = (candidate as SelectExpression).expressions.get(0) .value
							if(function instanceof Function)
								if(nameProvider.isAggregation(function.name))
									attributeOrder.set(i, getAggregationName(function.name))
								else
									attributeOrder.set(i, getExpressionName())
						}
						else
							attributeOrder.set(i, getExpressionName())
					}
				}
				i++ 
			}
		}
		expressionCounter=0
		aggregationCounter=0
		return attributeOrder
	}
	
	def private SourceStruct getSource(String name)
	{
	    for(SourceStruct source : registry_Sources)
	       if(source.sourcename.equals(name))
	       		return source
	       else if(source.aliases.contains(name))
	       		return source
        throw new QueryParseException('given source ' + name + ' is not registered')
	}
	
	def private SourceStruct getSource(Source source)
	{
		if(source instanceof SimpleSource)
	    	return getSource(source.name)
	}
	
	def boolean isSelectAll(SimpleSelect select)
	{
		for(SelectArgument a : select.arguments)
			if(a.attribute !== null)
				return false
		return true
	}
	
	def List<SelectExpression> extractAggregationsFromArgument(List<SelectArgument> args)
	{
		var List<SelectExpression> list = newArrayList
		for(SelectArgument a : args)
			if(a.expression !== null)
				if(a.expression.expressions.size == 1)
				{
					var aggregation = a.expression.expressions.get(0) 
					var function = aggregation.value
					if(function instanceof Function)
					{
						if(nameProvider.isAggregation(function.name))
							list.add(a.expression)
					}
				}
		return list
	}
	
	def List<SelectExpression> extractSelectExpressionsFromArgument(List<SelectArgument> args)
	{
		var List<SelectExpression> list = newArrayList
		for(SelectArgument a : args)
			if(a.expression !== null)
			{
				if(a.expression.expressions.size == 1)
				{
					var aggregation = a.expression.expressions.get(0) 
					var function = aggregation.value
					if(function instanceof Function)
					{
						if(nameProvider.isMapper(function.name, parseSelectExpression(a.expression as SelectExpression).toString))
							list.add(a.expression)
					}
					else
						list.add(a.expression)
				}
				else
					list.add(a.expression)
			}
		return list
	}

	def private String generateKeyValueString(String ... s)
	{
		var str = "["
		if(s.length == 1) 
			return str += "'" + s.get(0) + "']"
		for(var i = 0; i < s.length - 2; i++)
			str += "'" + s.get(i) + "'" + s.get(s.length - 1)			
		return str += "'" + s.get(s.length - 2) + "']"
	}
		
	def private String generateKeyValueString(List<String> l1, List<String> l2, String s)
	{
		println('generateKeyValueString()= ' + l1.toString)
		println(l2.toString)
		println(s)
		var str = ''
		for(var i = 0; i < l1.size - 1; i++)// OUT of bounds...
			str += generateKeyValueString(l1.get(i), l2.get(i), s) + ","
		return (str += generateKeyValueString(l1.get(l1.size - 1), l2.get(l1.size - 1), s))
	}
	
	def private String generateListString(String s1) { return "'" + s1 + "'" }
	
	def private String generateListString(List<String> l1)
	{
		if(l1 !== null && !l1.empty)
		{
			var str = ''
			for(var i = 0; i < l1.size - 1; i++)
				str += generateListString(l1.get(i)) + ","
			return (str += generateListString(l1.get(l1.size - 1)))
		}
		return ''
	}
	
	def private CharSequence getID()
	{
		operatorCounter++
		return operatorCounter.toString
	}

	def private String registerOperator(CharSequence operator) 
	{ 
		return registerOperator(operator, OP + getID())
	}
	
	def private String registerOperator(CharSequence operator, String definition)
	{
		println("registerOperator() -> " + definition)
		if(!registry_OperatorNames.contains(definition))
		{
			registry_OperatorNames.add(definition.toString)
			registry_Operators.put(definition, operator.toString)
		}
		return definition
	}
	
	def private registerSourceAlias(Source src)
	{
	    if(src.alias !== null)
	    	getSource(src).aliases.add(src.alias.name)
	}
	
	def private registerSourceAlias(String sourcename, String sourcealias)
	{
		var source = getSource(sourcename)
		if(!source.aliases.contains(sourcealias))
			source.aliases.add(sourcealias)
	}
	
	def private void registerSources(Collection<SDFSchema> schema, boolean internal)
	{
		for(SDFSchema s : schema)
		{
			for(String sourcename : s.baseSourceNames)
			{
				if(getSourceNames().contains(sourcename))
				{
					var iter = registry_Sources.iterator
					while(iter.hasNext())
					{
						var next = iter.next
						if(next.sourcename.equals(sourcename))
							if(next.internal && !internal)
							{
								iter.remove
								var source = new SourceStruct()
								source.internal = internal
								source.sourcename = sourcename
								source.attributes = newArrayList()
								source.aliases = newArrayList()
								for(SDFAttribute attributename : s.attributes)
									if(sourcename.equals(attributename.sourceName))
									{
										var attribute = new AttributeStruct()
										attribute.attributename = attributename.attributeName 
										attribute.sourcename = sourcename
										attribute.datatype = attributename.datatype.toString	
										attribute.aliases = newArrayList()	
										attribute.prefixes = newArrayList()	
										source.attributes.add(attribute)
									}						
								registry_Sources.add(source)
							}
					}
				}
				else
				{
					var source = new SourceStruct()
					source.internal = internal
					source.sourcename = sourcename
					source.attributes = newArrayList()
					source.aliases = newArrayList()
					for(SDFAttribute attributename : s.attributes)
						if(sourcename.equals(attributename.sourceName))
						{
							var attribute = new AttributeStruct()
							attribute.attributename = attributename.attributeName 
							attribute.sourcename = sourcename
							attribute.datatype = attributename.datatype.toString	
							attribute.aliases = newArrayList()	
							attribute.prefixes = newArrayList()		
							source.attributes.add(attribute)
						}						
					registry_Sources.add(source)
				}
			}
		}
	}

	def void setNameProvider(NameProvider provider) { nameProvider = provider }
	def void setOtherSchemata(Collection<SDFSchema> schema) { registerSources(schema, false) }
	def void setCQLSchemata(Collection<SDFSchema> schema) { registerSources(schema, true) }
	
	def private CharSequence formatOutputString(String sequence)
	{
		var String str 
		var replacement1 = 'AXZTGHHAJJJSUEJJ23123123123'
		var replacement2 = 'BNHUEOLASJJKEOOS12312309203'
		if(sequence.contains(ASSIG2))
			str = sequence.replaceFirst(ASSIG2, replacement1)
		else
			str = sequence.replaceFirst(ASSIG1, replacement2)
		
		return str.replaceAll("\\s*[\\r\\n]+\\s*", "")
					   .trim()
					   .replace(" ","")
					   .replace(replacement2," "+ASSIG1+" ")
					   .replace(replacement1," "+ASSIG2+" ")
	}
	
	def public boolean isAttributeAlias(String attributename) { return getAttributeAliasesAsList().contains(attributename) }
	def public boolean isSourceAlias(String sourcename) { return getSourceAliasesAsList().contains(sourcename) }
	
	def public List<AttributeStruct> getAttributes()
	{
		var list = newArrayList
		for(SourceStruct source : registry_Sources)
			list.addAll(source.attributes)
		return list
	}

	def public Map<AttributeStruct, List<String>> getAttributeAliases()
	{
		var map = newHashMap
		for(SourceStruct source : registry_Sources)
			for(AttributeStruct attribute : source.attributes)
				if(!attribute.aliases.empty)
					map.put(attribute, attribute.aliases)
		return map
	} 

	def public List<String> getAttributeAliasesAsList()
	{
		var list = newArrayList
		for(List<String> l : getAttributeAliases().values)
			for(String alias : l)
				list.add(alias)	
		return list 
	} 

	def public Map<SourceStruct, List<String>> getSourceAliases()
	{
		var map = newHashMap
		for(SourceStruct source : registry_Sources)
				map.put(source, source.aliases)
		return map
	} 
	
	def public String getDataTypeFrom(Attribute attribute) { return getDataTypeFrom(attribute.name) }
	
	def public String getDataTypeFrom(String attribute) 
	{
		var attributename = attribute//getAttributename(attribute)
		println("getDataTypeFrom() -> attribute= " + attribute + ', attributename= ' + attributename )
		
		var sourcename = ''
		if(attribute.contains('.'))
		{
			var splitted = attribute.split("\\.")
			if(attribute.isAttributeAlias)
			{
				var sourceFromAlias = registry_AttributeAliases.get(attribute)
				if(sourceFromAlias.isSourceAlias)
					sourceFromAlias = getSourcenameFromAlias(sourceFromAlias)
				attributename = getAttributenameFromAlias(attributename)
				sourcename = sourceFromAlias
				for(AttributeStruct attr : getSource(sourcename).attributes)
			        if(attr.attributename.equals(attributename))
			            return attr.datatype
			}           
			sourcename = splitted.get(0)
			attributename = splitted.get(1)
			if(attributename.isAttributeAlias)
				attributename = getAttributenameFromAlias(attributename)
			if(sourcename.isSourceAlias)
				sourcename = getSourcenameFromAlias(sourcename)
		    for(AttributeStruct attr : getSource(sourcename).attributes)
		        if(attr.attributename.equals(attributename))
		            return attr.datatype		
		}
		else
		{
			if(attribute.isAttributeAlias)
			{
				var sourceFromAlias = registry_AttributeAliases.get(attribute)
				println('sourcealas= ' + sourceFromAlias)
				if(sourceFromAlias.isSourceAlias)
					sourceFromAlias = getSourcenameFromAlias(sourceFromAlias)
				attributename = getAttributenameFromAlias(attributename)
				if(attributename === null)
					attributename = attribute
				println('attributename= ' + attributename) 
				println('alisases -> ' + registry_AttributeAliases.toString)
				for(AttributeStruct attr : getSource(sourceFromAlias).attributes)
			        if(attr.attributename.equals(attributename))
			            return attr.datatype
            }
		}
		return null
	}
	
	def public String getSourcenameFromAlias(String sourcealias)
	{
		for(Entry<SourceStruct, List<String>> source : getSourceAliases().entrySet)
			if(source.value.contains(sourcealias))
				return source.key.sourcename
		return null								
	}
	
	def public AttributeStruct getAttributeFromAlias(String alias)
	{
		println(getAttributeAliases().toString)
	    for(Entry<AttributeStruct, List<String>> entry : getAttributeAliases().entrySet)
	    	if(entry.value.contains(alias))
	    		return entry.key
	    println("hhehe -> " + alias)
	    return null
	}
	
	def public String getAttributenameFromAlias(String alias)
	{
		var attribute = getAttributeFromAlias(alias)
		if(attribute !== null)
			return attribute.attributename
		if(this.registry_Aggregations.contains(alias) || this.registry_Expressions.keySet.contains(alias))
			return alias			
	}
	
	def public String getAttributename(String attributename, String sourcename)
	{
		println("getAttributename() -> attributename=" + attributename +", sourcename= " + sourcename)
		var String attribute 
		var String source
		if(sourcename !== null && !sourcename.equals(""))
		{
			var SourceStruct tmp
			attribute = attributename
			source = if((tmp = getSource(sourcename)) !== null) tmp.sourcename else null
		} 
		else if(attributename.contains("."))
		{
			var String[] split = attributename.split('\\.')
			attribute = split.get(1)
			source = split.get(0)
		}
		////
		if(source !== null)
		{
			var isAlias = isAttributeAlias(attribute)
			if(isSourceAlias(source))
				if(isAlias)
					return attribute
				else
				{
					var r = source + '.' + attribute
					if(getAttributeAliasesAsList().contains(r))	
						return r
					else
					{ 
						var sourcenameFromalias = getSourcenameFromAlias(source)
						var attributeAliases = getAliasFromAttributename(attribute, sourcenameFromalias)
						if(!attributeAliases.empty)
						{
							return attributeAliases.get(0)
						}
						else
						{
							return source + '.' + attribute
						}
					}
				}
			else
				if(isAlias)
					return attribute
				else
					return source + '.' + attribute
		}
		else
		{
			attribute = attributename
			if(registry_Aggregations.contains(attribute))
	            return attribute            
	        if(registry_Expressions.keySet.contains(attribute))
	            return registry_Expressions.get(attribute)
			if(isAttributeAlias(attribute))
				return attribute
				
			var containedBySources = newArrayList	
			var usedNames = newArrayList
			for(String name : querySources)
			{
			    if(!usedNames.contains(name))
			    {
			        usedNames.add(name)
				    var source2 = getSource(name)
				    for(AttributeStruct attr : source2.attributes)
					    if(attr.attributename.equals(attribute))
					        containedBySources.add(source2)
		        }
	        }
	        if(containedBySources.size == 1)
	        {
	        	var aliases = getAliasFromAttributename(attribute, containedBySources.get(0).sourcename)
	        	if(!aliases.empty)
	        		return aliases.get(0)
	        	var sourceStruct = getSource(containedBySources.get(0).sourcename)	
	        	if(!sourceStruct.aliases.empty)
	        		return sourceStruct.aliases.get(0) + '.' + attributename
	            return containedBySources.get(0).sourcename + '.' + attribute
            }
		}
				
		throw new IllegalArgumentException("attribute " + attribute + " could not be resolved" )		
	}
	
	//TODO Uniform methods with dispatch methods
	def public String getAttributename(Attribute attribute, String srcname) { return getAttributename(attribute.name, srcname)	}
	def public String getAttributename(Attribute attribute) { return getAttributename(attribute.name) }
	def public String getAttributename(String attribute) { return getAttributename(attribute, null) }
	
	def public List<String> getAliasFromAttributename(String name, String source) { return getSource(source).findbyName(name).aliases }
	
	/** Returns all {@link Attribute} elements from the corresponding source. */
	def public List<String> getAttributeNamesFrom(String srcname) 
	{
 		for(SourceStruct source : registry_Sources)
			if(source.sourcename.equals(srcname) || source.aliases.contains(srcname))
				return source.attributes.stream.map(e|e.attributename).collect(Collectors.toList);
	}
}