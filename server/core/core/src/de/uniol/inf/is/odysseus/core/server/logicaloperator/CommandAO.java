package de.uniol.inf.is.odysseus.core.server.logicaloperator;

import java.util.List;

import de.uniol.inf.is.odysseus.core.logicaloperator.LogicalOperatorCategory;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.annotations.LogicalOperator;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.annotations.Parameter;
import de.uniol.inf.is.odysseus.core.server.logicaloperator.builder.StringParameter;

/**
 * 
 * @author Henrik Surm
 * 
 */
@LogicalOperator(maxInputPorts = 1, minInputPorts = 1, name = "COMMAND", doc = "This operator sends commands to other operators.", category = { LogicalOperatorCategory.BASE })
public class CommandAO extends UnaryLogicalOp {

    private static final long serialVersionUID = -1992998023364461468L;
	private List<String> targets;
	private String command = null;

    public CommandAO() {
        super();
    }

    public CommandAO(CommandAO other) {
        super(other);
        
        this.targets = other.targets;
        this.command = other.command;
    }

    @Parameter(type = StringParameter.class, name = "targets", isList = true, doc = "Target operators where commands generated by this operator will be sent")
	public void setTargets(List<String> targets) 
	{
		this.targets = targets;
	}    
	
	public List<String> getTargets()
	{
		return targets;
	}
    
    @Override
    public AbstractLogicalOperator clone() {
        return new CommandAO(this);
    }

    @Parameter(type = StringParameter.class, optional = false, name = "command", doc = "The command to be executed. Each listener must be able to provide a command with this name. The command can also be specified by a Tuple/KeyValue-Element named \"Command\".")
	public void setCommand(String command) 
	{
		this.command = command;
	}        
    
	public String getCommand() 
	{
		return command;
	}

}
