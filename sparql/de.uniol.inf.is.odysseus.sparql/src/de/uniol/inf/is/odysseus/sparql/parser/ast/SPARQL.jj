/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. SPARQL.jj */
/*@egen*/// ARQ/SPARQL Grammar - native syntax for the query engine
// Author:  Andy Seaborne andy.seaborne@hp.com
// (c) Copyright 2004, 2005, 2006, 2007 Hewlett-Packard Development Company, LP
// All rights reserved.
// See end of file for details.
//
// Constraint expression is derived from Java : 
// example java1.2-a.jj grammer in JavaCC distribution
// Much modifed over time.

options
{
   //LOOKAHEAD = 6;
   //FORCE_LA_CHECK = true;
   JAVA_UNICODE_ESCAPE = true ;
   UNICODE_INPUT = false ;

	STATIC = false;
  DEBUG_PARSER          = true ;
 // DEBUG_TOKEN_MANAGER   = true ;

  IGNORE_CASE = true;
               
                 
                             
                                    
                                                              
//  DEBUG_PARSER = false;
  //DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(SPARQLParser)
/*
 * (c) Copyright 2004, 2005, 2006, 2007 Hewlett-Packard Development Company, LP
 * All rights reserved.
 */

package de.uniol.inf.is.odysseus.sparql.parser.ast;

import java.util.List;
import java.util.ArrayList;

import de.uniol.inf.is.odysseus.sourcedescription.sdf.description.*;

import de.uniol.inf.is.odysseus.logicaloperator.*;
import de.uniol.inf.is.odysseus.sparql.parser.helper.*;
import de.uniol.inf.is.odysseus.sparql.parser.*;
import de.uniol.inf.is.odysseus.sparql.*;

public class SPARQLParser extends SPARQLParserBase/*@bgen(jjtree)*/implements SPARQLParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTSPARQLParserState jjtree = new JJTSPARQLParserState();

/*@egen*/
}
PARSER_END(SPARQLParser)

ASTQuery CompilationUnit(): {/*@bgen(jjtree) CompilationUnit */
                              ASTCompilationUnit jjtn000 = new ASTCompilationUnit(JJTCOMPILATIONUNIT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ ASTQuery query;}
{/*@bgen(jjtree) CompilationUnit */
  try {
/*@egen*/
  query=Query() <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return query;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTQuery Query() : {/*@bgen(jjtree) Query */
  ASTQuery jjtn000 = new ASTQuery(JJTQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Query */
  try {
/*@egen*/
  (( Prologue()
  ( SelectQuery() | ConstructQuery() | DescribeQuery() | AskQuery() )) |
  CreateStatement())/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CreateStatement() :
{/*@bgen(jjtree) CreateStatement */
        ASTCreateStatement jjtn000 = new ASTCreateStatement(JJTCREATESTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	INode n;
}
{/*@bgen(jjtree) CreateStatement */
  try {
/*@egen*/
  ( < CREATE > | < ATTACH > | < ADD > )
    < STREAM > n=IRIref(){jjtn000.setStreamName(n.getName());}
  
  ( < FROM > | < WITH > )
  
  ( Socket() | Channel() | CSVSource())
 
  (< PERSISTENT > {jjtn000.setPersistent(true);})?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Socket() :
{/*@bgen(jjtree) Socket */
        ASTSocket jjtn000 = new ASTSocket(JJTSOCKET);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String host;
	Token portToken;
}
{/*@bgen(jjtree) Socket */
  try {
/*@egen*/
  < SOCKET >
// <PNAME_NS> allows a single colon
// it's dirty hack at the moment  
  host=Host() <PNAME_NS> portToken=<INTEGER>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
  	jjtn000.setHost(host);
  	jjtn000.setPort(Integer.parseInt(portToken.image));
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Channel() :
{/*@bgen(jjtree) Channel */
        ASTChannel jjtn000 = new ASTChannel(JJTCHANNEL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String host;
	Token portToken;
}
{/*@bgen(jjtree) Channel */
  try {
/*@egen*/
// <PNAME_NS> allows a single colon
// it's dirty hack at the moment
  < CHANNEL > host=Host() <PNAME_NS> portToken=<INTEGER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
	  	jjtn000.setHost(host);
	  	jjtn000.setPort(Integer.parseInt(portToken.image));
  	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String Host() :
{/*@bgen(jjtree) Host */
  ASTHost jjtn000 = new ASTHost(JJTHOST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token value;
  String retVal;
}
{/*@bgen(jjtree) Host */
  try {
/*@egen*/
  value = < IPADDRESS >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    retVal=value.image;
    return retVal;
  }
| retVal=Identifier()/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{return retVal;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CSVSource() :
{/*@bgen(jjtree) CSVSource */
  ASTCSVSource jjtn000 = new ASTCSVSource(JJTCSVSOURCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) CSVSource */
  try {
/*@egen*/
  < CSV > t = < STRING_LITERAL1 >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // without quotes
    jjtn000.setURL(t.image.substring(1, t.image.length() - 1));
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String Identifier() :
{/*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Identifier */
  try {
/*@egen*/
  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return t.image;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Prologue() : {/*@bgen(jjtree) Prologue */
  ASTPrologue jjtn000 = new ASTPrologue(JJTPROLOGUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Prologue */
  try {
/*@egen*/
  ( BaseDecl() ) ?
  ( PrefixDecl() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void BaseDecl() : {/*@bgen(jjtree) BaseDecl */
                    ASTBaseDecl jjtn000 = new ASTBaseDecl(JJTBASEDECL);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ INode base; }
{/*@bgen(jjtree) BaseDecl */
  try {
/*@egen*/
  <BASE> base = IRI_REF()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setBaseURI(base.getName()) ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void PrefixDecl() : {/*@bgen(jjtree) PrefixDecl */
                      ASTPrefixDecl jjtn000 = new ASTPrefixDecl(JJTPREFIXDECL);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t ; INode iri ; }
{/*@bgen(jjtree) PrefixDecl */
    try {
/*@egen*/
    <PREFIX> t = <PNAME_NS> iri = IRI_REF()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/
      { jjtn000.putPrefix(t.image, iri.getName()) ; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// ---- Query type clauses

void SelectQuery() : {/*@bgen(jjtree) SelectQuery */
                       ASTSelectQuery jjtn000 = new ASTSelectQuery(JJTSELECTQUERY);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/ Variable v = null; Aggregation agg; List<SourceInfo> sources= new ArrayList<SourceInfo>();}
{/*@bgen(jjtree) SelectQuery */
  try {
/*@egen*/
  <SELECT>
    //{ getQuery().setQuerySelectType() ; }
  ( <DISTINCT> { jjtn000.setDistinct(true);}
  | <REDUCED> { jjtn000.setDistinct(true); } // reduced is used in the way of distinct
  )?
  (
    (( v = Var() 
    	{ 
    		jjtn000.addResultVar(v) ;
    		jjtn000.addVarOrAgg(0);
    	} 
      )
    |
     ( agg = Aggregation() 
   		{ 	jjtn000.addAggregation(agg);
   			jjtn000.addVarOrAgg(1);
   		} 
   	  )
    )+
    { jjtn000.setResultStar(false) ; }
  |
    <STAR> { jjtn000.setResultStar(true) ; }
  )

  [ FromClause(sources) {jjtn000.setSources(sources);}]
  WhereClause()
  [ GroupBy() ]
  /* [ Having() ] */
  SolutionModifier()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ConstructQuery() : {/*@bgen(jjtree) ConstructQuery */
                          ASTConstructQuery jjtn000 = new ASTConstructQuery(JJTCONSTRUCTQUERY);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ List<SourceInfo > sources = new ArrayList<SourceInfo >();}
{/*@bgen(jjtree) ConstructQuery */
  try {
/*@egen*/
  <CONSTRUCT>
//    { getQuery().setQueryConstructType() ;
//      setInConstructTemplate(true) ; }
  ConstructTemplate()
//    { setInConstructTemplate(false) ;
//      getQuery().setQueryResultStar(false) ;
//      getQuery().setConstructTemplate(t) ; }
  [ FromClause(sources) ]
  WhereClause()
  SolutionModifier()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DescribeQuery() : {/*@bgen(jjtree) DescribeQuery */
                         ASTDescribeQuery jjtn000 = new ASTDescribeQuery(JJTDESCRIBEQUERY);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/ INode n ; List<SourceInfo > sources = new ArrayList<SourceInfo >();}
{/*@bgen(jjtree) DescribeQuery */
  try {
/*@egen*/
  <DESCRIBE>
  (
    ( n = VarOrIRIref() )+
  |
    <STAR>
  )
  [ FromClause(sources) ]
  ( WhereClause() )?
  SolutionModifier()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AskQuery() : {/*@bgen(jjtree) AskQuery */
                   ASTAskQuery jjtn000 = new ASTAskQuery(JJTASKQUERY);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/List<SourceInfo > sources = new ArrayList<SourceInfo >();}
{/*@bgen(jjtree) AskQuery */
  try {
/*@egen*/
  <ASK>
  [ FromClause(sources) ]
  WhereClause()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// ----

// This non terminal defines a FROM-part in a sparql query.
// It can contain persistent rdf sources or rdf streams but
// not both.

void FromClause(List<SourceInfo> sources) : {/*@bgen(jjtree) FromClause */
  ASTFromClause jjtn000 = new ASTFromClause(JJTFROMCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FromClause */
  try {
/*@egen*/
  ( DatastreamClause(sources))/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// NOT USED AT THE MOMENT
//void DatasetClause(List<SourceInfo> sources) : {SourceInfo si;}
//{
//  ( <FROM> si=DefaultGraphClause() {sources.add(si);}
//  | <FROM> si=NamedGraphClause(){sources.add(si);}
//   )+
//}


// =============== BEGIN STREAM ===================
// This is the new part to define some data streams
// FROM STREAM and FROM NAMED STREAM


void DatastreamClause(List<SourceInfo> sources) : {/*@bgen(jjtree) DatastreamClause */
                                                   ASTDatastreamClause jjtn000 = new ASTDatastreamClause(JJTDATASTREAMCLAUSE);
                                                   boolean jjtc000 = true;
                                                   jjtree.openNodeScope(jjtn000);
/*@egen*/SourceInfo si;}
{/*@bgen(jjtree) DatastreamClause */
  try {
/*@egen*/
  ( <FROM> si=StreamClause(){sources.add(si);})+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
// ================ END STREAM ====================

// NOT USED AT THE MOMENT
//void DefaultGraphClause() : { Node n ; }
//{
//  <GRAPH>
//  n = SourceSelector()
//  {
//    // This checks for duplicates
//    getQuery().addGraphURI(n.getURI()) ;
//  }
//}

// NOT USED AT THE MOMENT
//void NamedGraphClause() : { Node n ; }
//{
//  <NAMED> <GRAPH>
//  n = SourceSelector()
//  {
//    // This checks for duplicates
//    getQuery().addNamedGraphURI(n.getURI()) ;
//  }
//}


// =============== BEGIN STREAM ===================
// This is a default stream clause
// FROM STREAM
SourceInfo StreamClause() : 
{/*@bgen(jjtree) StreamClause */
    ASTStreamClause jjtn000 = new ASTStreamClause(JJTSTREAMCLAUSE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/ 
    INode streamName;
    WindowAO window = null;
    AccessAO access;
    boolean named = false;
}
{/*@bgen(jjtree) StreamClause */
  try {
/*@egen*/
  <STREAM> [<NAMED>{named=true;}]
  streamName = SourceSelector()
  (window = Window())?/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    SDFSource sdfSource = new SDFSource(streamName.getName(), SPARQLAccessSourceTypes.RDF);
	access = new AccessAO(sdfSource);

	SourceInfo si = new SourceInfo(streamName.getName(), access, window);
	si.setDefaultStream(!named);

	return si;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


Aggregation Aggregation() : {/*@bgen(jjtree) Aggregation */
                             ASTAggregation jjtn000 = new ASTAggregation(JJTAGGREGATION);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/Variable v; Aggregation agg ;}
{/*@bgen(jjtree) Aggregation */
        try {
/*@egen*/
	(<AVG> <LPAREN> v = Var() <RPAREN>
		{ 	agg = new Aggregation(v, AggregateFunctionName.AVG); } |
	 <MIN> <LPAREN> v = Var() <RPAREN>
		{ 	agg = new Aggregation(v, AggregateFunctionName.MIN); } |
	 <MAX> <LPAREN> v = Var() <RPAREN>
	 	{ 	agg = new Aggregation(v, AggregateFunctionName.MAX); } |
	 <SUM> <LPAREN> v = Var() <RPAREN>
	 	{ 	agg = new Aggregation(v, AggregateFunctionName.SUM); } |
	 <COUNT> <LPAREN> v = Var() <RPAREN>
	 	{ 	agg = new Aggregation(v, AggregateFunctionName.COUNT); }
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return agg;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

WindowAO Window() : {/*@bgen(jjtree) Window */
                     ASTWindow jjtn000 = new ASTWindow(JJTWINDOW);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/WindowAO window = null;}
{/*@bgen(jjtree) Window */
  try {
/*@egen*/

  ( LOOKAHEAD(SlidingTimeWindow()) window = SlidingTimeWindow() | window = SlidingTupelWindow() )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return window;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

WindowAO SlidingTimeWindow() : 
{/*@bgen(jjtree) SlidingTimeWindow */
    ASTSlidingTimeWindow jjtn000 = new ASTSlidingTimeWindow(JJTSLIDINGTIMEWINDOW);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    WindowAO window = null;
    long range = 1;
    long delta = 1;
}
{/*@bgen(jjtree) SlidingTimeWindow */
  try {
/*@egen*/
  <WINDOW> <RANGE> range = ValueSpecification()
  (	<ADVANCE> delta = ValueSpecification() )?/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    window = new WindowAO(WindowType.TIME);
    window.setWindowSize(range);
    window.setWindowAdvance(delta);
    return window;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

WindowAO SlidingTupelWindow() :
{/*@bgen(jjtree) SlidingTupelWindow */
        ASTSlidingTupelWindow jjtn000 = new ASTSlidingTupelWindow(JJTSLIDINGTUPELWINDOW);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
  	WindowAO window = null;
  	Token rangeToken = null;
  	Token deltaToken = null;
  	long range = 1;
  	long delta = 1;
}
{/*@bgen(jjtree) SlidingTupelWindow */
  try {
/*@egen*/
  <WINDOW> <ELEMS> rangeToken = <INTEGER> (< ADVANCE > deltaToken = < INTEGER >)?/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {

    range = Long.parseLong(rangeToken.toString());
    if(deltaToken != null){      delta = Long.parseLong(deltaToken.toString());
    }
    window = new WindowAO(WindowType.TUPLE);
    window.setWindowSize(range);
    window.setWindowAdvance(delta);
    return window;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//ElementSimpleWindow FixedWindow() : 
//{
//    ElementSimpleWindow fw = null;
//    ElementValueSpecification vs = null;
//}
//{
//  <WINDOW> <RANGE> vs = ValueSpecification() <FIXED>
//  {
//    fw = new ElementSimpleWindow(WindowType.JUMPING_TIME_WINDOW);
//    fw.setRange(vs.getValue(), vs.getTimeunit());
//    fw.setDelta(vs.getValue(), vs.getTimeunit());
//    return fw;
//  }
//}

//ElementPredicateWindow PWindow() : {ElementPredicateWindow epw = null; ElementWindow ew = null;}
//{
//  epw = StartEndPWindow() ew = WindowNotPWindow()
//  {epw.setReducingWindow(ew);
//   return epw;}
//}

//ElementStartEndPredicateWindow StartEndPWindow() : 
//{
//    ElementStartEndPredicateWindow sepw = new ElementStartEndPredicateWindow();
//    ElementStartEndPredicate start = null;
//    Element startFilter = null;
//    ElementStartEndPredicate end = null;
//    Element endFilter = null;}
//{
//  <PWINDOW> <START> start = StartEndPredicate() [<DOT> startFilter = Filter()]
//  <END> end = StartEndPredicate() [<DOT> endFilter = Filter()]
//    { start.setFilter((ElementFilter)startFilter);
//      end.setFilter((ElementFilter)endFilter);
//      sepw.setStart(start);
//      sepw.setEnd(end);
//      return sepw;
//    }
//}

WindowAO WindowNotPWindow() : {/*@bgen(jjtree) WindowNotPWindow */
                               ASTWindowNotPWindow jjtn000 = new ASTWindowNotPWindow(JJTWINDOWNOTPWINDOW);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/WindowAO window= null;}
{/*@bgen(jjtree) WindowNotPWindow */
  try {
/*@egen*/
  ( LOOKAHEAD(2)window = SlidingTimeWindow() | window = SlidingTupelWindow() )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
 	{ 	  return window; 	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 	
}

//ElementStartEndPredicate StartEndPredicate() : 
//{ElementStartEndPredicate sep = new ElementStartEndPredicate();
// Triple t = null;
// Node subjectNode = null;
// Node predicateNode = null;
// Node objectNode = null;
//}
//{
//  (subjectNode = VarOrIRIref() | subjectNode = BlankNode()) predicateNode = VarOrIRIref() 
//    ( objectNode = PWindowGraphTerm() | objectNode = VarOrIRIref())
//    { t = new Triple(subjectNode, predicateNode, objectNode); 
//      sep.setTriple(t);
//      return sep;
//    }
//}

//Node PWindowGraphTerm() : {Node n = null;}
//{
//  (n = IRIref() | n = RDFLiteral() | n = NumericLiteral() | n = BooleanLiteral())
//  { return n; }
//}

long ValueSpecification() : 
{/*@bgen(jjtree) ValueSpecification */
    ASTValueSpecification jjtn000 = new ASTValueSpecification(JJTVALUESPECIFICATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token size = null;
    int factor = 1;
}
{/*@bgen(jjtree) ValueSpecification */
  try {
/*@egen*/
  size = <INTEGER> [factor = Timeunit()]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { long longValue = Long.parseLong(size.toString());
	return longValue * factor;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
This rule returns the factor to multiply with to get a window size in milliseconds.
E. g. a window size of 2 hours is equal to a size of 7200000 milliseconds.
*/
int Timeunit() : {/*@bgen(jjtree) Timeunit */
                  ASTTimeunit jjtn000 = new ASTTimeunit(JJTTIMEUNIT);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/int factor = 1;}
{/*@bgen(jjtree) Timeunit */
  try {
/*@egen*/
  (<MS> {factor = 1;}
  | <S>  {factor = 1000;}  
  | <MINUTE> {factor = 60000;}
  | <HOUR> {factor = 3600000;} 
  | <DAY> {factor  = 86400000;}
  | <WEEK> {factor = 604800000;}
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return factor;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
// ================ END STREAM ====================

INode SourceSelector() : {/*@bgen(jjtree) SourceSelector */
                          ASTSourceSelector jjtn000 = new ASTSourceSelector(JJTSOURCESELECTOR);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/INode iri;}
{/*@bgen(jjtree) SourceSelector */
  try {
/*@egen*/
  iri = IRI_REF()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { 
    return iri;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void WhereClause() : {/*@bgen(jjtree) WhereClause */
  ASTWhereClause jjtn000 = new ASTWhereClause(JJTWHERECLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) WhereClause */
   try {
/*@egen*/
   <WHERE> GroupGraphPattern()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void GroupBy() : {/*@bgen(jjtree) GroupBy */
                   ASTGroupBy jjtn000 = new ASTGroupBy(JJTGROUPBY);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ INode v; }
{/*@bgen(jjtree) GroupBy */
        try {
/*@egen*/
	<GROUP> <BY> <LPAREN> ( v = Var() {jjtn000.addVariable((Variable)v);} )+ <RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SolutionModifier() : {/*@bgen(jjtree) SolutionModifier */
  ASTSolutionModifier jjtn000 = new ASTSolutionModifier(JJTSOLUTIONMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SolutionModifier */
  try {
/*@egen*/
  ( OrderClause() )?
  ( LimitOffsetClauses() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void LimitOffsetClauses() : {/*@bgen(jjtree) LimitOffsetClauses */
  ASTLimitOffsetClauses jjtn000 = new ASTLimitOffsetClauses(JJTLIMITOFFSETCLAUSES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) LimitOffsetClauses */
  try {
/*@egen*/
  // SPARQL does not care about the order here.
  // SQL (where implemented) does (it's LIMIT then OFFSET generally)
  // But that is counter intuitive as it's applied the other way round
  (
    LimitClause() (OffsetClause())?
  |
    OffsetClause() (LimitClause())?
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void OrderClause() : {/*@bgen(jjtree) OrderClause */
  ASTOrderClause jjtn000 = new ASTOrderClause(JJTORDERCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) OrderClause */
  try {
/*@egen*/
  <ORDER> <BY> ( OrderCondition() )+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void OrderCondition() :
{/*@bgen(jjtree) OrderCondition */
  ASTOrderCondition jjtn000 = new ASTOrderCondition(JJTORDERCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ int direction = 0 ; INode v = null ; }
{/*@bgen(jjtree) OrderCondition */
  try {
/*@egen*/
  (
    ( // These are for clarity in the HTML
      ( <ASC> 
      | <DESC> )
      BrackettedExpression()
    )
  |
    ( Constraint()
    | v = Var() //{ expr = asExpr(v) ; } 
    )
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void LimitClause() : {/*@bgen(jjtree) LimitClause */
                       ASTLimitClause jjtn000 = new ASTLimitClause(JJTLIMITCLAUSE);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t ; }
{/*@bgen(jjtree) LimitClause */
  try {
/*@egen*/
  <LIMIT> t = <INTEGER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void OffsetClause() : {/*@bgen(jjtree) OffsetClause */
                        ASTOffsetClause jjtn000 = new ASTOffsetClause(JJTOFFSETCLAUSE);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t ; }
{/*@bgen(jjtree) OffsetClause */
  try {
/*@egen*/
  <OFFSET> t = <INTEGER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// ---- General Graph Pattern 

void GroupGraphPattern() : {/*@bgen(jjtree) GroupGraphPattern */
                             ASTGroupGraphPattern jjtn000 = new ASTGroupGraphPattern(JJTGROUPGRAPHPATTERN);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ WindowAO window; }
{/*@bgen(jjtree) GroupGraphPattern */
  try {
/*@egen*/
    
  <LBRACE>
  // Ensure two BGP's can't be next to each other
  // Done by seeing if there is a non-BGP and recursing
  // if there is an intermediate
  (
    TriplesBlock()
  )?
  (
    ( GraphPatternNotTriples() | Filter() )
    (<DOT>)?

    (
      TriplesBlock()
    )?
  )*

  ( window=WindowNotPWindow(){jjtn000.setWindowAO(window);})?
  <RBRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void TriplesBlock() : {/*@bgen(jjtree) TriplesBlock */
  ASTTriplesBlock jjtn000 = new ASTTriplesBlock(JJTTRIPLESBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  List<List<Triple >> triples = new ArrayList<List<Triple>>();
  List<Triple> curSubjTriples; 
}
{/*@bgen(jjtree) TriplesBlock */
  try {
/*@egen*/
  curSubjTriples= TriplesSameSubject()  {
    triples.add(curSubjTriples);  }
  ( <DOT> ( curSubjTriples=TriplesSameSubject()
  			{triples.add(curSubjTriples);}
  			)
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  //( <DOT>)?
  {
    jjtn000.setTriples(triples);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// @@ Ready to be deleted
// Element GroupGraphPattern() : { Element el = null ; ElementTriplesBlock acc = null ; }
// {
//     { ElementGroup elg = new ElementGroup() ; }
//   <LBRACE>
//       { startGroup(elg) ; }
//   // Ensure two BGP's can't be next to each other
//   // Done by seeing if there is a non-BGP and recursing
//   // if there is an intermediate
//   (
//     { acc = new ElementTriplesBlock() ;
//       startTriplesBlock(acc) ;
//     }
//     el = TriplesBlock(acc)
//     { endTriplesBlock(acc) ;
//       elg.addElement(el) ; } 
//   )?
//   (
//     ( el = GraphPatternNotTriples() | el = Filter() )
//     { elg.addElement(el) ; }
//     (<DOT>)?
// 
//     (
//       { acc = new ElementTriplesBlock() ;
//         startTriplesBlock(acc) ;
//       }
//       el = TriplesBlock(acc)
//       { endTriplesBlock(acc) ;
//         elg.addElement(el) ; } 
//     )?
//   )*
//       { endGroup(elg) ; }
//   <RBRACE>
//     { return elg ; }
// }

// Element GroupGraphPattern() : {}
// {
//     { ElementGroup elg = new ElementGroup() ; }
//   <LBRACE>
//       { startGroup(elg) ; }
//     GraphPatternElement(elg)
//       { endGroup(elg) ; }
//   <RBRACE>
//     { return elg ; }
// }
// 
// 
// // Without {}
// // If the recusion is removed can roll GraphPatternElement into GroupGraphPattern()
// 
// void GraphPatternElement(ElementGroup elg) : 
//     { Element el = null ; ElementTriplesBlock acc = null ; }
// {
//   // Ensure two BGP's can't be next to each other
//   // Done by seeing if there is a non-BGP and recursing
//   // if there is an intermediate
//   (
//     { acc = new ElementTriplesBlock() ;
//       startTriplesBlock(acc) ;
//     }
//     el = TriplesBlock(acc)
//     { endTriplesBlock(acc) ;
//       elg.addElement(el) ; } 
//   )?
//   (
//     ( el = GraphPatternNotTriples()
//     | el = Filter()                 
//     )
//     { elg.addElement(el) ; }
//     (<DOT>)?
//     GraphPatternElement(elg)
//   )?
// }
// 
// 
// Element TriplesBlock(ElementTriplesBlock acc) : { }
// {
//   { if ( acc == null )
//       acc = new ElementTriplesBlock() ;
//   }
//   TriplesSameSubject(acc)
//   ( <DOT> (TriplesBlock(acc))? )?
//     { return acc ; }
// }


// -----

void GraphPatternNotTriples() : {/*@bgen(jjtree) GraphPatternNotTriples */
  ASTGraphPatternNotTriples jjtn000 = new ASTGraphPatternNotTriples(JJTGRAPHPATTERNNOTTRIPLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) GraphPatternNotTriples */
 try {
/*@egen*/
 (
   OptionalGraphPattern()
 |
   // "GroupPattern" or "GroupPattern" union "GroupPattern"
   GroupOrUnionGraphPattern()
 |
   GraphGraphPattern()

 )/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// ---- Definitions of each pattern element

void OptionalGraphPattern() : {/*@bgen(jjtree) OptionalGraphPattern */
  ASTOptionalGraphPattern jjtn000 = new ASTOptionalGraphPattern(JJTOPTIONALGRAPHPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) OptionalGraphPattern */
  try {
/*@egen*/ <OPTIONAL> GroupGraphPattern()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void GraphGraphPattern() : {/*@bgen(jjtree) GraphGraphPattern */
                             ASTGraphGraphPattern jjtn000 = new ASTGraphGraphPattern(JJTGRAPHGRAPHPATTERN);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ INode n; }
{/*@bgen(jjtree) GraphGraphPattern */
  try {
/*@egen*/
  <GRAPH> n=VarOrIRIref(){jjtn000.setGraphTerm(n);} GroupGraphPattern()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// G (union G)* can be a single group pattern
// or a group pattern as part of an union.
void GroupOrUnionGraphPattern() :
{/*@bgen(jjtree) GroupOrUnionGraphPattern */
  ASTGroupOrUnionGraphPattern jjtn000 = new ASTGroupOrUnionGraphPattern(JJTGROUPORUNIONGRAPHPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) GroupOrUnionGraphPattern */
  try {
/*@egen*/
  GroupGraphPattern()
  ( <UNION>
    
  GroupGraphPattern()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void Filter() : {/*@bgen(jjtree) Filter */
  ASTFilter jjtn000 = new ASTFilter(JJTFILTER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Filter */
  try {
/*@egen*/
  <FILTER> Constraint()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Constraint() : {/*@bgen(jjtree) Constraint */
                      ASTConstraint jjtn000 = new ASTConstraint(JJTCONSTRAINT);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ SimpleNode n; }
{/*@bgen(jjtree) Constraint */
  try {
/*@egen*/
  ( n=BrackettedExpression()/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                            }
/*@egen*/{jjtn000.setString(n.toString());}
  | n=BuiltInCall()/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/{jjtn000.setString(n.toString());}
  | n=FunctionCall()/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/{jjtn000.setString(n.toString());}
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


SimpleNode FunctionCall() : {/*@bgen(jjtree) FunctionCall */
                              ASTFunctionCall jjtn000 = new ASTFunctionCall(JJTFUNCTIONCALL);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token fName; SimpleNode argList;}
{/*@bgen(jjtree) FunctionCall */
  try {
/*@egen*/
  fName=<IDENTIFIER> argList=ArgList()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
  	jjtn000.setString(fName.image + argList.toString());
  	return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

SimpleNode ArgList() :
{/*@bgen(jjtree) ArgList */
        ASTArgList jjtn000 = new ASTArgList(JJTARGLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/ 
	String str = "";
	SimpleNode expr;
}
{/*@bgen(jjtree) ArgList */
  try {
/*@egen*/
  (
    <NIL>
  |
   // Was <LPAREN> ( Expression() (<COMMA> Expression() )* )? <RPAREN>
    <LPAREN>
      expr=Expression(){str+= "(" + expr.toString();}
      (<COMMA> expr=Expression() {str += ", " + expr.toString();} )*
    <RPAREN> {str+= ")";}
   )/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   
   {
   	jjtn000.setString(str);
   	return jjtn000;
   }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// -------- Construct patterns

void ConstructTemplate() : {/*@bgen(jjtree) ConstructTemplate */
  ASTConstructTemplate jjtn000 = new ASTConstructTemplate(JJTCONSTRUCTTEMPLATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ConstructTemplate */
  try {
/*@egen*/
  <LBRACE>
    (ConstructTriples())?
  <RBRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ConstructTriples() : {/*@bgen(jjtree) ConstructTriples */
  ASTConstructTriples jjtn000 = new ASTConstructTriples(JJTCONSTRUCTTRIPLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ConstructTriples */
    try {
/*@egen*/
    TriplesSameSubject()
    (<DOT> (ConstructTriples())? )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// -------- Triple lists with property and object lists

List<Triple> TriplesSameSubject() :
{/*@bgen(jjtree) TriplesSameSubject */
  ASTTriplesSameSubject jjtn000 = new ASTTriplesSameSubject(JJTTRIPLESSAMESUBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  List<Triple > triples = new ArrayList<Triple>();
  INode subject;
  PropertiesAndObjects paos;
}
{/*@bgen(jjtree) TriplesSameSubject */
  try {
/*@egen*/
  (
	  subject = VarOrTerm()
	  paos=PropertyListNotEmpty()
	  /*|
	  // Any of the triple generating syntax elements
	  subject = TriplesNode()
	  paos=PropertyList()*/
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    for(INode curProp: paos.getProperties()){
      for(INode curObject: paos.getObjects(curProp)){
      	triples.add(new Triple(subject, curProp, curObject));  
      }
    }
    
    return triples;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

PropertiesAndObjects PropertyListNotEmpty() :
{/*@bgen(jjtree) PropertyListNotEmpty */
  ASTPropertyListNotEmpty jjtn000 = new ASTPropertyListNotEmpty(JJTPROPERTYLISTNOTEMPTY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ PropertiesAndObjects paos = new PropertiesAndObjects();
  INode predicate ;
  List<INode > objects;
}
{/*@bgen(jjtree) PropertyListNotEmpty */
  try {
/*@egen*/
  predicate = Verb()
  objects=ObjectList()  {
    paos.putPropertyAndObjects(predicate, objects);  }
  (<SEMICOLON> (predicate = Verb() objects=ObjectList()  	{
  	  paos.putPropertyAndObjects(predicate, objects);  	}
  )? )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return paos;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

PropertiesAndObjects PropertyList() : {/*@bgen(jjtree) PropertyList */
                                        ASTPropertyList jjtn000 = new ASTPropertyList(JJTPROPERTYLIST);
                                        boolean jjtc000 = true;
                                        jjtree.openNodeScope(jjtn000);
/*@egen*/ PropertiesAndObjects paos;}
{/*@bgen(jjtree) PropertyList */
  try {
/*@egen*/
  ( paos=PropertyListNotEmpty()  {
    return paos;  } ) ?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// // Recursive
// void PropertyListNotEmpty(Node s, TripleCollector acc) : { Node p ; }
// {
//   p = Verb()
//   ObjectList(s, p, acc)
//   (<SEMICOLON> PropertyList(s, acc) ) ?
// #ifdef ARQ
//   |
//   Reification(s, acc)
// #endif
// }

// // Recursive
// void ObjectList(Node s, Node p, TripleCollector acc): { Node o ; } 
// {
//     { int mark = acc.mark() ; }
//   o = GraphNode(acc) 
//     { insert(acc, mark, s, p, o) ; }
//   ( <COMMA> ObjectList(s, p , acc) )?
// }

List<INode> ObjectList():
{/*@bgen(jjtree) ObjectList */
  ASTObjectList jjtn000 = new ASTObjectList(JJTOBJECTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  List<INode > objects = new ArrayList<INode >();
  INode obj;
}
{/*@bgen(jjtree) ObjectList */
  try {
/*@egen*/
  obj=Object()  {
    objects.add(obj);  }
  ( <COMMA> obj=Object()  {
    objects.add(obj);  }
   )*/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   {
     return objects;   }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

INode Object(): {/*@bgen(jjtree) Object */
                 ASTObject jjtn000 = new ASTObject(JJTOBJECT);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/INode object;}
{/*@bgen(jjtree) Object */
  try {
/*@egen*/
  object = GraphNode()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return object;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

INode Verb() : {/*@bgen(jjtree) Verb */
                ASTVerb jjtn000 = new ASTVerb(JJTVERB);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/INode p ; Token t;}
{/*@bgen(jjtree) Verb */
  try {
/*@egen*/
//   ( p = VarOrBlankNodeOrIRIref() | <KW_A> { p = nRDFtype ; } )
  ( p = VarOrIRIref() | t=<KW_A>{ p = new Literal("rdf:type");}  )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return p ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// -------- Triple expansions

// Anything that can stand in a node slot and which is
// a number of triples

INode TriplesNode() : {/*@bgen(jjtree) TriplesNode */
                        ASTTriplesNode jjtn000 = new ASTTriplesNode(JJTTRIPLESNODE);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/ INode n ; }
{/*@bgen(jjtree) TriplesNode */
  try {
/*@egen*/
  Collection()
 |
  BlankNodePropertyList()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void BlankNodePropertyList() : {/*@bgen(jjtree) BlankNodePropertyList */
  ASTBlankNodePropertyList jjtn000 = new ASTBlankNodePropertyList(JJTBLANKNODEPROPERTYLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) BlankNodePropertyList */
  try {
/*@egen*/
  <LBRACKET>
  PropertyListNotEmpty()
  <RBRACKET>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
// ------- RDF collections

void Collection() :
    {/*@bgen(jjtree) Collection */
     ASTCollection jjtn000 = new ASTCollection(JJTCOLLECTION);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/INode graphNode;}
{/*@bgen(jjtree) Collection */
  try {
/*@egen*/
  <LPAREN>
  (
    graphNode = GraphNode()
  ) +
  // Not * here - "()" is handled separately.
  <RPAREN>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// -------- Nodes in a graph pattern or template

INode GraphNode() : {/*@bgen(jjtree) GraphNode */
                      ASTGraphNode jjtn000 = new ASTGraphNode(JJTGRAPHNODE);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ INode n ; }
{/*@bgen(jjtree) GraphNode */
  try {
/*@egen*/
  n = VarOrTerm()/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ { return n ; }
 |
  n = TriplesNode()/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ { return n ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

INode VarOrTerm() : {/*@bgen(jjtree) VarOrTerm */
                     ASTVarOrTerm jjtn000 = new ASTVarOrTerm(JJTVARORTERM);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/INode n = null ; }
{/*@bgen(jjtree) VarOrTerm */
  try {
/*@egen*/
  ( n = Var() | n = GraphTerm() )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return n ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// Property (if no bNodes) + DESCRIBE
INode VarOrIRIref() : {/*@bgen(jjtree) VarOrIRIref */
                       ASTVarOrIRIref jjtn000 = new ASTVarOrIRIref(JJTVARORIRIREF);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/INode n = null ; }
{/*@bgen(jjtree) VarOrIRIref */
  try {
/*@egen*/
  ( n = Var() | n = IRIref() )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return n ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// // GRAPH and property if including blank nodes are properties.
// Node VarOrBlankNodeOrIRIref() : {Node n = null ; }
// {
//   ( n = Var() | n = BlankNode() | n = IRIref() )
//   { return n ; }
// }

Variable Var() : {/*@bgen(jjtree) Var */
                   ASTVar jjtn000 = new ASTVar(JJTVAR);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t ;}
{/*@bgen(jjtree) Var */
    try {
/*@egen*/
    ( t = <VAR1> | t = <VAR2> )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new Variable(t.image) ; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

INode GraphTerm() : {/*@bgen(jjtree) GraphTerm */
                      ASTGraphTerm jjtn000 = new ASTGraphTerm(JJTGRAPHTERM);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ INode n ; }
{/*@bgen(jjtree) GraphTerm */
  try {
/*@egen*/
  n = IRIref()/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ { return n ; }
| n = RDFLiteral()/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ { return n ; }
| n = NumericLiteral()/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { return n ; }
| n = BooleanLiteral()/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { return n ; }
| n = BlankNode()/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ { return n ; }
  //  <LPAREN> <RPAREN>     { return nRDFnil ; }
| <NIL>/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn000, true);
         jjtc000 = false;
       }
/*@egen*/{return BlankNode.NIL;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// -------- Constraint syntax

SimpleNode Expression() : {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Expression */
  try {
/*@egen*/
  ConditionalOrExpression()/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/{return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode ConditionalOrExpression() : {/*@bgen(jjtree) ConditionalOrExpression */
  ASTConditionalOrExpression jjtn000 = new ASTConditionalOrExpression(JJTCONDITIONALOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ConditionalOrExpression */
  try {
/*@egen*/
  ConditionalAndExpression()
  ( <SC_OR> ConditionalAndExpression()
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  
  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode ConditionalAndExpression() : {/*@bgen(jjtree) ConditionalAndExpression */
  ASTConditionalAndExpression jjtn000 = new ASTConditionalAndExpression(JJTCONDITIONALANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ConditionalAndExpression */
  try {
/*@egen*/
  ValueLogical()
  ( <SC_AND> ValueLogical()
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode ValueLogical() : {/*@bgen(jjtree) ValueLogical */
  ASTValueLogical jjtn000 = new ASTValueLogical(JJTVALUELOGICAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ValueLogical */
  try {
/*@egen*/
  RelationalExpression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode RelationalExpression() : {/*@bgen(jjtree) RelationalExpression */
                                      ASTRelationalExpression jjtn000 = new ASTRelationalExpression(JJTRELATIONALEXPRESSION);
                                      boolean jjtc000 = true;
                                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) RelationalExpression */
  try {
/*@egen*/
  NumericExpression()
  (
    t=<EQ> NumericExpression()
  | t=<NE> NumericExpression()
  | t=<LT> NumericExpression()
  | t=<GT> NumericExpression()
  | t=<LE> NumericExpression()
  | t=<GE> NumericExpression()
  )?

  {
    if(t != null){      jjtn000.setCompareOperator(t.image);
    }  }/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode NumericExpression () : {/*@bgen(jjtree) NumericExpression */
  ASTNumericExpression jjtn000 = new ASTNumericExpression(JJTNUMERICEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NumericExpression */
  try {
/*@egen*/
  AdditiveExpression()/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/{return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode AdditiveExpression() :
{/*@bgen(jjtree) AdditiveExpression */
  ASTAdditiveExpression jjtn000 = new ASTAdditiveExpression(JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ String str = "";
  SimpleNode tempExpr;
  INode lit;
}
{/*@bgen(jjtree) AdditiveExpression */
  try {
/*@egen*/
  tempExpr=MultiplicativeExpression()  {
    str += tempExpr.toString();  }
  ( <PLUS> tempExpr = MultiplicativeExpression(){str += " + " + tempExpr.toString();}
  | <MINUS> tempExpr = MultiplicativeExpression(){str += " - " + tempExpr.toString();}
  | lit=NumericLiteralPositive(){str += lit.getName();}
  | lit=NumericLiteralNegative(){str += lit.getName();}
  )*

  {
    jjtn000.setString(str);  }/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode MultiplicativeExpression() :
{/*@bgen(jjtree) MultiplicativeExpression */
  ASTMultiplicativeExpression jjtn000 = new ASTMultiplicativeExpression(JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  String str = "";
  SimpleNode tempExpr;
}
{/*@bgen(jjtree) MultiplicativeExpression */
  try {
/*@egen*/
  tempExpr=UnaryExpression(){str += tempExpr.toString();}
  ( <STAR> tempExpr=UnaryExpression(){str+=" * " + tempExpr.toString();}
  | <SLASH> tempExpr=UnaryExpression(){str += "/" + tempExpr.toString();}
//   | <REM>   expr2 = UnaryExpression()
//     { expr1 = new E_Modulus(expr1, expr2) ; }
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
  	jjtn000.setString(str);
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode UnaryExpression() : 
{/*@bgen(jjtree) UnaryExpression */
        ASTUnaryExpression jjtn000 = new ASTUnaryExpression(JJTUNARYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String str = "";
	SimpleNode tempExpr;
}
{/*@bgen(jjtree) UnaryExpression */
  try {
/*@egen*/
  /*<BANG> tempExpr=PrimaryExpression(){str+=tempExpr.toString();}*/
  /*|*/ 
  <PLUS> tempExpr=PrimaryExpression()/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                     }
/*@egen*/{str += " + " + tempExpr.toString();} 
  | <MINUS> tempExpr=PrimaryExpression()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/{str += " - " + tempExpr.toString();}
  | tempExpr=PrimaryExpression(){str+= tempExpr.toString();}/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
  	jjtn000.setString(str);
  	return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode PrimaryExpression() : 
{/*@bgen(jjtree) PrimaryExpression */
        ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(JJTPRIMARYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	SimpleNode expr;
	String str;
	INode node;
}
{/*@bgen(jjtree) PrimaryExpression */
  try {
/*@egen*/
  ( expr=BrackettedExpression(){jjtn000.setString(expr.toString());}
  | expr=BuiltInCall(){jjtn000.setString(expr.toString());}
  | expr=IRIrefOrFunction(){jjtn000.setString(expr.toString());}

// NOT  | gn = VarOrTerm()           { return asExpr(gn) ; }
// Because of IRIrefOrFunction vs <NIL> and blank nodes
  | node=RDFLiteral(){jjtn000.setString(node.getName());}
  | node=NumericLiteral(){jjtn000.setString(node.getName());}
  | node=BooleanLiteral(){jjtn000.setString(node.getName());}
  | node=Var(){jjtn000.setString(node.getName());}
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode BrackettedExpression() : 
{/*@bgen(jjtree) BrackettedExpression */
  ASTBrackettedExpression jjtn000 = new ASTBrackettedExpression(JJTBRACKETTEDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) BrackettedExpression */
    try {
/*@egen*/
    <LPAREN> Expression() <RPAREN>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ // String is set directly in ASTBrackettedExpression.toString()
    {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

SimpleNode BuiltInCall() : 
{/*@bgen(jjtree) BuiltInCall */
        ASTBuiltInCall jjtn000 = new ASTBuiltInCall(JJTBUILTINCALL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String str = "";
	SimpleNode node;
	SimpleNode node2;
	Variable var;
}
{/*@bgen(jjtree) BuiltInCall */
    try {
/*@egen*/
//	t = < IDENTIFIER > {str += t.image + "(";}
//	(LOOKAHEAD(<LPAREN> Expression()) <LPAREN> (node=Expression() {str += node.toString();} 
//			   (<COMMA> node=Expression() {str += "," + node.toString();})*) 
//			   <RPAREN> 
//	|LOOKAHEAD(<LPAREN> <RPAREN>) <LPAREN> <RPAREN> ) {str += ")";}

    // STR
    <STR> <LPAREN> node=Expression() <RPAREN>/*@bgen(jjtree)*/
                                              {
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                              }
/*@egen*/ {jjtn000.setString("str(" + node.toString() + ")");}
  | // Lang
    <LANG> <LPAREN> node=Expression() <RPAREN>/*@bgen(jjtree)*/
                                               {
                                                 jjtree.closeNodeScope(jjtn000, true);
                                                 jjtc000 = false;
                                               }
/*@egen*/ {jjtn000.setString("lang(" + node.toString() + ")");}
  |// Langmatches
    <LANGMATCHES>
       <LPAREN> node=Expression() <COMMA> node2=Expression() <RPAREN>/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn000, true);
         jjtc000 = false;
       }
/*@egen*/
       {jjtn000.setString("langMatches(" + node.toString() + ", " + node2.toString() + ")");}

  | // Datatype
    <DTYPE> <LPAREN> node=Expression() <RPAREN>/*@bgen(jjtree)*/
                                               {
                                                 jjtree.closeNodeScope(jjtn000, true);
                                                 jjtc000 = false;
                                               }
/*@egen*/{jjtn000.setString("datatype(" + node.toString() + ")");}

  | <BOUND> <LPAREN> var=Var() <RPAREN>/*@bgen(jjtree)*/
                                       {
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                       }
/*@egen*/{jjtn000.setString("bound(" + var.getName() + ")");}
  | <SAME_TERM> <LPAREN> node=Expression() <COMMA> node2=Expression() <RPAREN>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {jjtn000.setString("sameTerm(" + node.toString() + ", " + node2.toString() + ")");}

  | <IS_IRI> <LPAREN> node=Expression() <RPAREN>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {jjtn000.setString("isIRI(" + node.toString() + ")");}

  | <IS_URI> <LPAREN> node=Expression() <RPAREN>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{jjtn000.setString("isURI(" + node.toString() + ")");}
	
  | <IS_BLANK> <LPAREN> node=Expression() <RPAREN>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{jjtn000.setString("isBlank(" + node.toString() + ")");}
	
  | <IS_LITERAL> <LPAREN> node=Expression() <RPAREN>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{jjtn000.setString("isLiteral(" + node.toString() + ")");}
	
  | // Regular expression matcher
    node=RegexExpression(){jjtn000.setString(node.toString());}/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    
    {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

SimpleNode RegexExpression() :
{/*@bgen(jjtree) RegexExpression */
  ASTRegexExpression jjtn000 = new ASTRegexExpression(JJTREGEXEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) RegexExpression */
    try {
/*@egen*//* String is produced directly in ASTRegexExpression.toString() */
    <REGEX> <LPAREN>
      Expression()
      <COMMA>
      Expression()
      ( <COMMA> Expression() ) ?
    <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// The case of "q:name()" or just "q:name"
// by expanding out FunctionCall()

SimpleNode IRIrefOrFunction() :
{/*@bgen(jjtree) IRIrefOrFunction */
        ASTIRIrefOrFunction jjtn000 = new ASTIRIrefOrFunction(JJTIRIREFORFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	INode n;
	SimpleNode function;
}
{/*@bgen(jjtree) IRIrefOrFunction */
  try {
/*@egen*/
  (
  	n=IRIref() {jjtn000.setString(n.getName());}
  | 
   	function=FunctionCall(){jjtn000.setString(function.toString());}
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  //{str+=n.getName();}( argList=ArgList(){str += argList.toString();} )?
  
  //{return jjtThis;}
  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

INode RDFLiteral() : 
{/*@bgen(jjtree) RDFLiteral */
        ASTRDFLiteral jjtn000 = new ASTRDFLiteral(JJTRDFLITERAL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String name;
	String lang;
	INode n;
	
	Literal lit;
}
{/*@bgen(jjtree) RDFLiteral */
  try {
/*@egen*/
  name=String(){lit = new Literal(name);}
  // Optional lang tag and datatype.
  ( <AT> lang=String() {lit.setLanguage(lang);})?
  ( <DATATYPE> n=IRIref() {lit.setDatatype(n.getName());})?/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  
  {return lit;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


INode NumericLiteral() : {/*@bgen(jjtree) NumericLiteral */
                           ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/ INode n ; }
{/*@bgen(jjtree) NumericLiteral */
  try {
/*@egen*/
  (
    n = NumericLiteralUnsigned()
  | n = NumericLiteralPositive()
  | n = NumericLiteralNegative()
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return n ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

INode NumericLiteralUnsigned() : {/*@bgen(jjtree) NumericLiteralUnsigned */
                                   ASTNumericLiteralUnsigned jjtn000 = new ASTNumericLiteralUnsigned(JJTNUMERICLITERALUNSIGNED);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t ; }
{/*@bgen(jjtree) NumericLiteralUnsigned */
  try {
/*@egen*/
  t = <INTEGER>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ { return new Literal(t.image) ; }
| t = <DECIMAL>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ { return new Literal(t.image) ; }
| t = <DOUBLE>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ { return new Literal(t.image) ; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

INode NumericLiteralPositive() : {/*@bgen(jjtree) NumericLiteralPositive */
                                   ASTNumericLiteralPositive jjtn000 = new ASTNumericLiteralPositive(JJTNUMERICLITERALPOSITIVE);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t ; }
{/*@bgen(jjtree) NumericLiteralPositive */
  try {
/*@egen*/
  t = <INTEGER_POSITIVE>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { return new Literal(t.image) ; }
| t = <DECIMAL_POSITIVE>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { return new Literal(t.image) ; }
| t = <DOUBLE_POSITIVE>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ { return new Literal(t.image) ; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

INode NumericLiteralNegative() : {/*@bgen(jjtree) NumericLiteralNegative */
                                   ASTNumericLiteralNegative jjtn000 = new ASTNumericLiteralNegative(JJTNUMERICLITERALNEGATIVE);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t ; }
{/*@bgen(jjtree) NumericLiteralNegative */
  try {
/*@egen*/
  t = <INTEGER_NEGATIVE>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { return new Literal(t.image) ; }
| t = <DECIMAL_NEGATIVE>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { return new Literal(t.image) ; }
| t = <DOUBLE_NEGATIVE>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ { return new Literal(t.image) ; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


INode BooleanLiteral() : {/*@bgen(jjtree) BooleanLiteral */
  ASTBooleanLiteral jjtn000 = new ASTBooleanLiteral(JJTBOOLEANLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BooleanLiteral */
  try {
/*@egen*/
  <TRUE>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return new Literal("true");  }
 |
  <FALSE>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return new Literal("false");  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/  
}

String String() : {/*@bgen(jjtree) String */
                    ASTString jjtn000 = new ASTString(JJTSTRING);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t ; String lex ; }
{/*@bgen(jjtree) String */
  try {
/*@egen*/
  ( t = <STRING_LITERAL1> { lex = stripQuotes(t.image) ; }
  | t = <STRING_LITERAL2> { lex = stripQuotes(t.image) ; }
  | t = <STRING_LITERAL_LONG1> { lex = stripQuotes(t.image) ; }
  | t = <STRING_LITERAL_LONG2> { lex = stripQuotes(t.image) ; }
  )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      lex = unescapeStr(lex, t.beginLine, t.beginColumn) ;
      return lex ;
    }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

INode IRIref() : {/*@bgen(jjtree) IRIref */
                   ASTIRIref jjtn000 = new ASTIRIref(JJTIRIREF);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ INode n; }
{/*@bgen(jjtree) IRIref */
  try {
/*@egen*/
  n = IRI_REF()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ { return n ; }
|
  n = PrefixedName()/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { return n ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

Literal PrefixedName() : {/*@bgen(jjtree) PrefixedName */
                           ASTPrefixedName jjtn000 = new ASTPrefixedName(JJTPREFIXEDNAME);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t ; }
{/*@bgen(jjtree) PrefixedName */
  try {
/*@egen*/
  ( t = <PNAME_LN>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new Literal(t.image); }
  |
    t = <PNAME_NS>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new Literal(t.image); }
  )/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

BlankNode BlankNode() : {/*@bgen(jjtree) BlankNode */
                          ASTBlankNode jjtn000 = new ASTBlankNode(JJTBLANKNODE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null ; }
{/*@bgen(jjtree) BlankNode */
  try {
/*@egen*/
  t = <BLANK_NODE_LABEL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new BlankNode(t.image); }
|
//  <LBRACKET> <RBRACKET> { return createBNode() ; }
  <ANON>/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/ { return createBlankNode() ; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

IRI IRI_REF() : {/*@bgen(jjtree) IRI_REF */
                  ASTIRI_REF jjtn000 = new ASTIRI_REF(JJTIRI_REF);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t ; String formatted = null;}
{/*@bgen(jjtree) IRI_REF */
  try {
/*@egen*/
  // we don't need leading "<" and trailing ">"
  (t = <IRIref> {formatted = t.image.substring(1, t.image.length() - 1);} | t = <PNAME_LN> {formatted = t.image;})/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return new IRI(formatted); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// ------------------------------------------
// Tokens

// Comments and whitespace

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN: { <#WS: " " | "\t" | "\n" | "\r" | "\f"> }

SPECIAL_TOKEN :
{ <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }

// Main tokens */

TOKEN:
{
   // Includes # for relative URIs
   <IRIref: "<" (~[ ">","<", "\"", "{", "}", "^", "\\", "|", "`",
                      "\u0000"-" "])* ">" >
| <PNAME_NS: (<PN_PREFIX>)? ":">
| <PNAME_LN: <PNAME_NS> <PN_LOCAL> >
| <BLANK_NODE_LABEL: "_:" <PN_LOCAL> >
| <VAR1: "?" <VARNAME> >
| <VAR2: "$" <VARNAME> >
| <LANGTAG: <AT> (<A2Z>)+("-" (<A2ZN>)+)* >
| <#A2Z: ["a"-"z","A"-"Z"]>
| <#A2ZN: ["a"-"z","A"-"Z","0"-"9"]>
}

// -------------------------------------------------
// Keyworks : includes operators that are words and should be
// before general things like IDENTIFIER which swallow almost
// anything

TOKEN : { <KW_A: "a" > }

TOKEN [IGNORE_CASE] :
{
// Prologue
   < BASE: "base" >
| < PREFIX: "prefix" >

// Result forms
| < SELECT: "select" >
| < DISTINCT: "distinct" >
| < REDUCED: "reduced" >
| < DESCRIBE: "describe" >
| < CONSTRUCT: "construct" >
| < ASK: "ask" >

| < LIMIT: "limit" >
| < OFFSET: "offset" >
| < ORDER: "order" >
| < BY: "by" >
| < GROUP: "group">

| < ASC: "asc" >
| < DESC: "desc" >

// Aggregation Functions
| < AVG: "avg" >
| < MAX: "max" >
| < MIN: "min" >
| < SUM: "sum" >
| < COUNT: "count" >

// Dataset
| < NAMED: "named" >
| < FROM: "from" >
| < STREAM: "stream" >
| < PERSISTENT: "persistent" >

| < CREATE : "create" >
| < ATTACH: "attach" >
| < ADD: "add" >
| < WITH: "with">
| < CSV: "csv">
| < CHANNEL: "channel">
| < #DIGIT : [ "0"-"9" ] >
| < IPADDRESS : < DIGIT > (< DIGIT >)? (< DIGIT >)? "." < DIGIT > (< DIGIT >)? (< DIGIT >)? "." < DIGIT > (< DIGIT >)? (< DIGIT >)? "." < DIGIT > (< DIGIT >)? (< DIGIT >)? >
| < SOCKET: "socket">

// Window
| < WINDOW: "window" >
| < RANGE: "range" >
| < SLIDE: "slide" >
| < ADVANCE: "advance" >
| < FIXED: "fixed" >
| < ELEMS: "elems" > 
| < PWINDOW: "pwindow" >
| < START: "start" >
| < END: "end" >

// Timeunit
| < MS: "MS" >
| < S: "S" >
| < MINUTE: "minute" >
| < HOUR: "hour" >
| < DAY: "day" >
| < WEEK: "week" >
| < MONTH: "month" >
| < YEAR: "year" >

// Graph pattern operators 
| < WHERE: "where" >
| < AND: "and" >
| < GRAPH: "graph" >
| < OPTIONAL: "optional" >
| < UNION: "union" >






| < FILTER: "filter" >

// Expression operators
| < BOUND: "bound" >
| < STR: "str" >
// |  < URI:         "uri" >
| < DTYPE: "datatype" >
| < LANG: "lang" >
| < LANGMATCHES: "langmatches" >
//|  < IS_IRI:      ("isIRI"|"isURI") >
| < IS_URI: "isURI" >
| < IS_IRI: "isIRI" >
| < IS_BLANK: "isBlank" >
| < IS_LITERAL: "isLiteral" >
| < REGEX: "regex" >
| < SAME_TERM: "sameTerm" >

| <TRUE: "true" >
| <FALSE: "false" >
}

// -------------------------------------------------

TOKEN :
{
  < #DIGITS: (["0"-"9"])+>
| < INTEGER: <DIGITS> >
| < DECIMAL: ( <DIGITS> "." (<DIGITS>)* | "." <DIGITS> ) >
| < DOUBLE: // Required exponent.
      (
        (["0"-"9"])+ "." (["0"-"9"])* <EXPONENT>
        | "." (["0"-"9"])+ (<EXPONENT>)
        | (["0"-"9"])+ <EXPONENT>
      )
      >

| < INTEGER_POSITIVE: <PLUS> <INTEGER> >
| < DECIMAL_POSITIVE: <PLUS> <DECIMAL> >
| < DOUBLE_POSITIVE: <PLUS> <DOUBLE> >

| < INTEGER_NEGATIVE: <MINUS> <INTEGER> >
| < DECIMAL_NEGATIVE: <MINUS> <DECIMAL> >
| < DOUBLE_NEGATIVE: <MINUS> <DOUBLE> >

| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < #QUOTE_3D: "\"\"\"">
| < #QUOTE_3S: "'''">
| <ECHAR: "\\" ( "t"|"b"|"n"|"r"|"f"|"\\"|"\""|"'") >
| < STRING_LITERAL1:
      // Single quoted string
      "'" ( (~["'","\\","\n","\r"]) | <ECHAR> )* "'" >
| < STRING_LITERAL2:
    // Double quoted string
      "\"" ( (~["\"","\\","\n","\r"]) | <ECHAR> )* "\"" >
| < STRING_LITERAL_LONG1:
     <QUOTE_3S>
      ( ("'" | "''")? (~["'","\\"] | <ECHAR> ))*
     <QUOTE_3S> >

| < STRING_LITERAL_LONG2:
     <QUOTE_3D>
      ( ("\"" | "\"\"")? (~["\"","\\"] | <ECHAR> ))*
     <QUOTE_3D> >

| < IDENTIFIER :
    (< LETTER >)+
    (
      < DIGIT >
    | < LETTER >
    | < SPECIAL_CHARS >
    )* >
| < #LETTER : [ "a"-"z", "A"-"Z" ] >
| < #SPECIAL_CHARS :
    ":"
  | "_"
  | "."
  | "*" >
}

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >

| <NIL: <LPAREN> (<WS>|<SINGLE_LINE_COMMENT>)* <RPAREN> >

| < LBRACE: "{" >
| < RBRACE: "}" >

| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < ANON: <LBRACKET> (<WS>|<SINGLE_LINE_COMMENT>)* <RBRACKET> >

| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

// Operator

TOKEN :
{
  < EQ: "=" >
| < NE: "!=" >
| < GT: ">" >
| < LT: "<" >
| < LE: "<=" > // Maybe: | "=>" >
| < GE: ">=" > // Maybe: | "=<" >

| < BANG: "!" >
| < TILDE: "~" >
//| < COLON: ":" >

| < SC_OR: "||" >
| < SC_AND: "&&" >

| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >

//| < AMP: "&" >
//| < REM: "%" >

| < DATATYPE: "^^">
| < AT: "@">
}

// See XML chars.txt for notes

TOKEN:
{
  // XML 1.1 NCNameStartChar without "_"
  <#PN_CHARS_BASE:
          ["A"-"Z"] | ["a"-"z"] |
          ["\u00c0"-"\u00d6"] | ["\u00d8"-"\u00f6"] | ["\u00f8"-"\u02ff"] |
          ["\u0370"-"\u037d"] | ["\u037f"-"\u1fff"] |
          ["\u200c"-"\u200d"] | ["\u2070"-"\u218f"] | ["\u2c00"-"\u2fef"] |
          ["\u3001"-"\ud7ff"] | ["\uf900"-"\ufffd"]
          >
          // [#x10000-#xEFFFF]
|
  <#PN_CHARS_U: <PN_CHARS_BASE> | "_" >
|
// No DOT
  <#PN_CHARS: (<PN_CHARS_U> | "-" | ["0"-"9"] | "\u00b7" |
              ["\u0300"-"\u036f"] | ["\u203f"-"\u2040"] ) >
|
  // No leading "_", no trailing ".", can have dot inside prefix name.
  <#PN_PREFIX: <PN_CHARS_BASE> ((<PN_CHARS>|".")* <PN_CHARS>)? >
|
  // With a leading "_", no dot at end of local name.
  <#PN_LOCAL: (<PN_CHARS_U> | ["0"-"9"]) ((<PN_CHARS>|".")* <PN_CHARS>)? >
|
  // NCNAME without "-" and ".", allowing leading digits.
  <#VARNAME: ( <PN_CHARS_U> | ["0"-"9"] )
             ( <PN_CHARS_U> | ["0"-"9"] | "\u00b7" |
               ["\u0300"-"\u036f"] | ["\u203f"-"\u2040"] )* >
}

// Catch-all tokens.  Must be last.  
// Any non-whitespace.  Causes a parser exception, rather than a
// token manager error (with hidden line numbers).
// Only bad IRIs (e.g. spaces) now give unhelpful parse errors.
TOKEN:
{
  <#UNKNOWN: (~[" ","\t","\n","\r","\f" ])+ >
}

/*
 * (c) Copyright 2004, 2005, 2006, 2007 Hewlett-Packard Development Company, LP
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
# Local Variables:
# tab-width: 4
# indent-tabs-mode: nil
# comment-default-style: "//"
# End:
*/
