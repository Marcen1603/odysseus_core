/*******************************************************************************
 * Copyright 2012 The Odysseus Team
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
/* Generated By:JJTree&JavaCC: Do not edit this line. SPARQLParser.java */
/*
 * (c) Copyright 2004, 2005, 2006, 2007 Hewlett-Packard Development Company, LP
 * All rights reserved.
 */

package de.uniol.inf.is.odysseus.sparql.parser.ast;

import java.util.List;
import java.util.ArrayList;

import de.uniol.inf.is.odysseus.core.server.logicaloperator.*;
import de.uniol.inf.is.odysseus.sparql.parser.helper.*;
import de.uniol.inf.is.odysseus.sparql.parser.*;
import de.uniol.inf.is.odysseus.sparql.*;
@ SuppressWarnings("all") public class SPARQLParser extends SPARQLParserBase/*@bgen(jjtree)*/implements SPARQLParserTreeConstants, SPARQLParserConstants {/*@bgen(jjtree)*/
  protected JJTSPARQLParserState jjtree = new JJTSPARQLParserState();

  final public ASTQuery CompilationUnit() throws ParseException {
    trace_call("CompilationUnit");
    try {
                             /*@bgen(jjtree) CompilationUnit */
                              ASTCompilationUnit jjtn000 = new ASTCompilationUnit(JJTCOMPILATIONUNIT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);ASTQuery query;
      try {
        query = Query();
        jj_consume_token(0);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return query;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CompilationUnit");
    }
  }

  final public ASTQuery Query() throws ParseException {
    trace_call("Query");
    try {
                    /*@bgen(jjtree) Query */
  ASTQuery jjtn000 = new ASTQuery(JJTQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BASE:
        case PREFIX:
        case SELECT:
        case DESCRIBE:
        case CONSTRUCT:
        case ASK:
          Prologue();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SELECT:
            SelectQuery();
            break;
          case CONSTRUCT:
            ConstructQuery();
            break;
          case DESCRIBE:
            DescribeQuery();
            break;
          case ASK:
            AskQuery();
            break;
          default:
            jj_la1[0] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case CREATE:
        case ATTACH:
        case ADD:
          CreateStatement();
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Query");
    }
  }

  final public void CreateStatement() throws ParseException {
    trace_call("CreateStatement");
    try {
 /*@bgen(jjtree) CreateStatement */
        ASTCreateStatement jjtn000 = new ASTCreateStatement(JJTCREATESTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);INode n;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CREATE:
          jj_consume_token(CREATE);
          break;
        case ATTACH:
          jj_consume_token(ATTACH);
          break;
        case ADD:
          jj_consume_token(ADD);
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(STREAM);
        n = IRIref();
                          jjtn000.setStreamName(n.getName());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FROM:
          jj_consume_token(FROM);
          break;
        case WITH:
          jj_consume_token(WITH);
          break;
        default:
          jj_la1[3] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SOCKET:
          Socket();
          break;
        case CHANNEL:
          Channel();
          break;
        case CSV:
          CSVSource();
          break;
        default:
          jj_la1[4] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PERSISTENT:
          jj_consume_token(PERSISTENT);
                   jjtn000.setPersistent(true);
          break;
        default:
          jj_la1[5] = jj_gen;
          ;
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("CreateStatement");
    }
  }

  final public void Socket() throws ParseException {
    trace_call("Socket");
    try {
 /*@bgen(jjtree) Socket */
        ASTSocket jjtn000 = new ASTSocket(JJTSOCKET);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String host;
        Token portToken;
      try {
        jj_consume_token(SOCKET);
        // <PNAME_NS> allows a single colon
        // it's dirty hack at the moment  
          host = Host();
        jj_consume_token(PNAME_NS);
        portToken = jj_consume_token(INTEGER);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        jjtn000.setHost(host);
        jjtn000.setPort(Integer.parseInt(portToken.image));
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("Socket");
    }
  }

  final public void Channel() throws ParseException {
    trace_call("Channel");
    try {
 /*@bgen(jjtree) Channel */
        ASTChannel jjtn000 = new ASTChannel(JJTCHANNEL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String host;
        Token portToken;
      try {
        jj_consume_token(CHANNEL);
        host = Host();
        jj_consume_token(PNAME_NS);
        portToken = jj_consume_token(INTEGER);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
                jjtn000.setHost(host);
                jjtn000.setPort(Integer.parseInt(portToken.image));
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("Channel");
    }
  }

  final public String Host() throws ParseException {
    trace_call("Host");
    try {
 /*@bgen(jjtree) Host */
  ASTHost jjtn000 = new ASTHost(JJTHOST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token value;
  String retVal;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IPADDRESS:
          value = jj_consume_token(IPADDRESS);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    retVal=value.image;
    {if (true) return retVal;}
          break;
        case IDENTIFIER:
          retVal = Identifier();
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
 {if (true) return retVal;}
          break;
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Host");
    }
  }

  final public void CSVSource() throws ParseException {
    trace_call("CSVSource");
    try {
 /*@bgen(jjtree) CSVSource */
  ASTCSVSource jjtn000 = new ASTCSVSource(JJTCSVSOURCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
      try {
        jj_consume_token(CSV);
        t = jj_consume_token(STRING_LITERAL1);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    // without quotes
    jjtn000.setURL(t.image.substring(1, t.image.length() - 1));
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("CSVSource");
    }
  }

  final public String Identifier() throws ParseException {
    trace_call("Identifier");
    try {
 /*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
      try {
        t = jj_consume_token(IDENTIFIER);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Identifier");
    }
  }

  final public void Prologue() throws ParseException {
    trace_call("Prologue");
    try {
                   /*@bgen(jjtree) Prologue */
  ASTPrologue jjtn000 = new ASTPrologue(JJTPROLOGUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BASE:
          BaseDecl();
          break;
        default:
          jj_la1[7] = jj_gen;
          ;
        }
        label_1:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PREFIX:
            ;
            break;
          default:
            jj_la1[8] = jj_gen;
            break label_1;
          }
          PrefixDecl();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("Prologue");
    }
  }

  final public void BaseDecl() throws ParseException {
    trace_call("BaseDecl");
    try {
                   /*@bgen(jjtree) BaseDecl */
                    ASTBaseDecl jjtn000 = new ASTBaseDecl(JJTBASEDECL);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);INode base;
      try {
        jj_consume_token(BASE);
        base = IRI_REF();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.setBaseURI(base.getName()) ;
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("BaseDecl");
    }
  }

  final public void PrefixDecl() throws ParseException {
    trace_call("PrefixDecl");
    try {
                     /*@bgen(jjtree) PrefixDecl */
                      ASTPrefixDecl jjtn000 = new ASTPrefixDecl(JJTPREFIXDECL);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);Token t ; INode iri ;
      try {
        jj_consume_token(PREFIX);
        t = jj_consume_token(PNAME_NS);
        iri = IRI_REF();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtn000.putPrefix(t.image, iri.getName()) ;
      } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
      } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
      }
    } finally {
      trace_return("PrefixDecl");
    }
  }

// ---- Query type clauses
  final public void SelectQuery() throws ParseException {
    trace_call("SelectQuery");
    try {
 /*@bgen(jjtree) SelectQuery */
  ASTSelectQuery jjtn000 = new ASTSelectQuery(JJTSELECTQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Variable v = null;
  Aggregation agg;
  List<SourceInfo> sources= new ArrayList<SourceInfo>();
  IRI fileURL;
      try {
        jj_consume_token(SELECT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTO:
          jj_consume_token(INTO);
          jj_consume_token(FILE);
          fileURL = IRI_REF();
                                              jjtn000.setFileURL(fileURL);
          break;
        default:
          jj_la1[9] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DISTINCT:
        case REDUCED:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DISTINCT:
            jj_consume_token(DISTINCT);
                 jjtn000.setDistinct(true);
            break;
          case REDUCED:
            jj_consume_token(REDUCED);
                jjtn000.setDistinct(true);
            break;
          default:
            jj_la1[10] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[11] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR1:
        case VAR2:
        case AVG:
        case MAX:
        case MIN:
        case SUM:
        case COUNT:
          label_2:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case VAR1:
            case VAR2:
              v = Var();
                jjtn000.addResultVar(v) ;
                jjtn000.addVarOrAgg(0);
              break;
            case AVG:
            case MAX:
            case MIN:
            case SUM:
            case COUNT:
              agg = Aggregation();
                        jjtn000.addAggregation(agg);
                        jjtn000.addVarOrAgg(1);
              break;
            default:
              jj_la1[12] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case VAR1:
            case VAR2:
            case AVG:
            case MAX:
            case MIN:
            case SUM:
            case COUNT:
              ;
              break;
            default:
              jj_la1[13] = jj_gen;
              break label_2;
            }
          }
      jjtn000.setResultStar(false) ;
          break;
        case STAR:
          jj_consume_token(STAR);
             jjtn000.setResultStar(true) ;
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FROM:
          FromClause(sources);
                         jjtn000.setSources(sources);
          break;
        default:
          jj_la1[15] = jj_gen;
          ;
        }
        WhereClause();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GROUP:
          GroupBy();
          break;
        default:
          jj_la1[16] = jj_gen;
          ;
        }
        SolutionModifier();
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("SelectQuery");
    }
  }

  final public void ConstructQuery() throws ParseException {
    trace_call("ConstructQuery");
    try {
                         /*@bgen(jjtree) ConstructQuery */
                          ASTConstructQuery jjtn000 = new ASTConstructQuery(JJTCONSTRUCTQUERY);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);List<SourceInfo > sources = new ArrayList<SourceInfo >();
      try {
        jj_consume_token(CONSTRUCT);
        ConstructTemplate();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FROM:
          FromClause(sources);
          break;
        default:
          jj_la1[17] = jj_gen;
          ;
        }
        WhereClause();
        SolutionModifier();
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("ConstructQuery");
    }
  }

  final public void DescribeQuery() throws ParseException {
    trace_call("DescribeQuery");
    try {
                        /*@bgen(jjtree) DescribeQuery */
                         ASTDescribeQuery jjtn000 = new ASTDescribeQuery(JJTDESCRIBEQUERY);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);INode n ; List<SourceInfo > sources = new ArrayList<SourceInfo >();
      try {
        jj_consume_token(DESCRIBE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
          label_3:
          while (true) {
            n = VarOrIRIref();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IRIref:
            case PNAME_NS:
            case PNAME_LN:
            case VAR1:
            case VAR2:
              ;
              break;
            default:
              jj_la1[18] = jj_gen;
              break label_3;
            }
          }
          break;
        case STAR:
          jj_consume_token(STAR);
          break;
        default:
          jj_la1[19] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FROM:
          FromClause(sources);
          break;
        default:
          jj_la1[20] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHERE:
          WhereClause();
          break;
        default:
          jj_la1[21] = jj_gen;
          ;
        }
        SolutionModifier();
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("DescribeQuery");
    }
  }

  final public void AskQuery() throws ParseException {
    trace_call("AskQuery");
    try {
                   /*@bgen(jjtree) AskQuery */
                   ASTAskQuery jjtn000 = new ASTAskQuery(JJTASKQUERY);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);List<SourceInfo > sources = new ArrayList<SourceInfo >();
      try {
        jj_consume_token(ASK);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FROM:
          FromClause(sources);
          break;
        default:
          jj_la1[22] = jj_gen;
          ;
        }
        WhereClause();
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("AskQuery");
    }
  }

// ----

// This non terminal defines a FROM-part in a sparql query.
// It can contain persistent rdf sources or rdf streams but
// not both.
  final public void FromClause(List<SourceInfo> sources) throws ParseException {
    trace_call("FromClause");
    try {
                                             /*@bgen(jjtree) FromClause */
  ASTFromClause jjtn000 = new ASTFromClause(JJTFROMCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        DatastreamClause(sources);
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("FromClause");
    }
  }

// NOT USED AT THE MOMENT
//void DatasetClause(List<SourceInfo> sources) : {SourceInfo si;}
//{
//  ( <FROM> si=DefaultGraphClause() {sources.add(si);}
//  | <FROM> si=NamedGraphClause(){sources.add(si);}
//   )+
//}


// =============== BEGIN STREAM ===================
// This is the new part to define some data streams
// FROM STREAM and FROM NAMED STREAM
  final public void DatastreamClause(List<SourceInfo> sources) throws ParseException {
    trace_call("DatastreamClause");
    try {
                                                   /*@bgen(jjtree) DatastreamClause */
                                                   ASTDatastreamClause jjtn000 = new ASTDatastreamClause(JJTDATASTREAMCLAUSE);
                                                   boolean jjtc000 = true;
                                                   jjtree.openNodeScope(jjtn000);SourceInfo si;
      try {
        label_4:
        while (true) {
          jj_consume_token(FROM);
          si = StreamClause();
                             sources.add(si);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FROM:
            ;
            break;
          default:
            jj_la1[23] = jj_gen;
            break label_4;
          }
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("DatastreamClause");
    }
  }

// ================ END STREAM ====================

// NOT USED AT THE MOMENT
//void DefaultGraphClause() : { Node n ; }
//{
//  <GRAPH>
//  n = SourceSelector()
//  {
//    // This checks for duplicates
//    getQuery().addGraphURI(n.getURI()) ;
//  }
//}

// NOT USED AT THE MOMENT
//void NamedGraphClause() : { Node n ; }
//{
//  <NAMED> <GRAPH>
//  n = SourceSelector()
//  {
//    // This checks for duplicates
//    getQuery().addNamedGraphURI(n.getURI()) ;
//  }
//}


// =============== BEGIN STREAM ===================
// This is a default stream clause
// FROM STREAM
  final public SourceInfo StreamClause() throws ParseException {
    trace_call("StreamClause");
    try {
 /*@bgen(jjtree) StreamClause */
    ASTStreamClause jjtn000 = new ASTStreamClause(JJTSTREAMCLAUSE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);INode streamName;
    WindowAO window = null;
    AccessAO access;
    boolean named = false;
      try {
        jj_consume_token(STREAM);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NAMED:
          jj_consume_token(NAMED);
                    named=true;
          break;
        default:
          jj_la1[24] = jj_gen;
          ;
        }
        streamName = SourceSelector();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WINDOW:
          window = Window();
          break;
        default:
          jj_la1[25] = jj_gen;
          ;
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        access = new AccessAO(streamName.getName(), SPARQLAccessSourceTypes.RDF, null);

        SourceInfo si = new SourceInfo(streamName.getName(), access, window);
        si.setDefaultStream(!named);

        {if (true) return si;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StreamClause");
    }
  }

  final public Aggregation Aggregation() throws ParseException {
    trace_call("Aggregation");
    try {
                             /*@bgen(jjtree) Aggregation */
                             ASTAggregation jjtn000 = new ASTAggregation(JJTAGGREGATION);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Variable v; Aggregation agg ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AVG:
          jj_consume_token(AVG);
          jj_consume_token(LPAREN);
          v = Var();
          jj_consume_token(RPAREN);
                        agg = new Aggregation(v, AggregateFunctionName.AVG);
          break;
        case MIN:
          jj_consume_token(MIN);
          jj_consume_token(LPAREN);
          v = Var();
          jj_consume_token(RPAREN);
                        agg = new Aggregation(v, AggregateFunctionName.MIN);
          break;
        case MAX:
          jj_consume_token(MAX);
          jj_consume_token(LPAREN);
          v = Var();
          jj_consume_token(RPAREN);
                        agg = new Aggregation(v, AggregateFunctionName.MAX);
          break;
        case SUM:
          jj_consume_token(SUM);
          jj_consume_token(LPAREN);
          v = Var();
          jj_consume_token(RPAREN);
                        agg = new Aggregation(v, AggregateFunctionName.SUM);
          break;
        case COUNT:
          jj_consume_token(COUNT);
          jj_consume_token(LPAREN);
          v = Var();
          jj_consume_token(RPAREN);
                        agg = new Aggregation(v, AggregateFunctionName.COUNT);
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         {if (true) return agg;}
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Aggregation");
    }
  }

  final public WindowAO Window() throws ParseException {
    trace_call("Window");
    try {
                     /*@bgen(jjtree) Window */
                     ASTWindow jjtn000 = new ASTWindow(JJTWINDOW);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);WindowAO window = null;
      try {
        if (jj_2_1(2147483647)) {
          window = SlidingTimeWindow();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WINDOW:
            window = SlidingTupelWindow();
            break;
          default:
            jj_la1[27] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return window;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Window");
    }
  }

  final public WindowAO SlidingTimeWindow() throws ParseException {
    trace_call("SlidingTimeWindow");
    try {
 /*@bgen(jjtree) SlidingTimeWindow */
    ASTSlidingTimeWindow jjtn000 = new ASTSlidingTimeWindow(JJTSLIDINGTIMEWINDOW);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);WindowAO window = null;
    long range = 1;
    long delta = 1;
      try {
        jj_consume_token(WINDOW);
        jj_consume_token(RANGE);
        range = ValueSpecification();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ADVANCE:
          jj_consume_token(ADVANCE);
          delta = ValueSpecification();
          break;
        default:
          jj_la1[28] = jj_gen;
          ;
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    window = new WindowAO(WindowType.TIME);
    window.setWindowSize(range);
    window.setWindowAdvance(delta);
    {if (true) return window;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SlidingTimeWindow");
    }
  }

  final public WindowAO SlidingTupelWindow() throws ParseException {
    trace_call("SlidingTupelWindow");
    try {
 /*@bgen(jjtree) SlidingTupelWindow */
        ASTSlidingTupelWindow jjtn000 = new ASTSlidingTupelWindow(JJTSLIDINGTUPELWINDOW);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);WindowAO window = null;
        Token rangeToken = null;
        Token deltaToken = null;
        long range = 1;
        long delta = 1;
      try {
        jj_consume_token(WINDOW);
        jj_consume_token(ELEMS);
        rangeToken = jj_consume_token(INTEGER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ADVANCE:
          jj_consume_token(ADVANCE);
          deltaToken = jj_consume_token(INTEGER);
          break;
        default:
          jj_la1[29] = jj_gen;
          ;
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    range = Long.parseLong(rangeToken.toString());
    if(deltaToken != null){
      delta = Long.parseLong(deltaToken.toString());
    }
    window = new WindowAO(WindowType.TUPLE);
    window.setWindowSize(range);
    window.setWindowAdvance(delta);
    {if (true) return window;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SlidingTupelWindow");
    }
  }

//ElementSimpleWindow FixedWindow() : 
//{
//    ElementSimpleWindow fw = null;
//    ElementValueSpecification vs = null;
//}
//{
//  <WINDOW> <RANGE> vs = ValueSpecification() <FIXED>
//  {
//    fw = new ElementSimpleWindow(WindowType.JUMPING_TIME_WINDOW);
//    fw.setRange(vs.getValue(), vs.getTimeunit());
//    fw.setDelta(vs.getValue(), vs.getTimeunit());
//    return fw;
//  }
//}

//ElementPredicateWindow PWindow() : {ElementPredicateWindow epw = null; ElementWindow ew = null;}
//{
//  epw = StartEndPWindow() ew = WindowNotPWindow()
//  {epw.setReducingWindow(ew);
//   return epw;}
//}

//ElementStartEndPredicateWindow StartEndPWindow() : 
//{
//    ElementStartEndPredicateWindow sepw = new ElementStartEndPredicateWindow();
//    ElementStartEndPredicate start = null;
//    Element startFilter = null;
//    ElementStartEndPredicate end = null;
//    Element endFilter = null;}
//{
//  <PWINDOW> <START> start = StartEndPredicate() [<DOT> startFilter = Filter()]
//  <END> end = StartEndPredicate() [<DOT> endFilter = Filter()]
//    { start.setFilter((ElementFilter)startFilter);
//      end.setFilter((ElementFilter)endFilter);
//      sepw.setStart(start);
//      sepw.setEnd(end);
//      return sepw;
//    }
//}
  final public WindowAO WindowNotPWindow() throws ParseException {
    trace_call("WindowNotPWindow");
    try {
                               /*@bgen(jjtree) WindowNotPWindow */
                               ASTWindowNotPWindow jjtn000 = new ASTWindowNotPWindow(JJTWINDOWNOTPWINDOW);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);WindowAO window= null;
      try {
        if (jj_2_2(2)) {
          window = SlidingTimeWindow();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WINDOW:
            window = SlidingTupelWindow();
            break;
          default:
            jj_la1[30] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return window;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("WindowNotPWindow");
    }
  }

//ElementStartEndPredicate StartEndPredicate() : 
//{ElementStartEndPredicate sep = new ElementStartEndPredicate();
// Triple t = null;
// Node subjectNode = null;
// Node predicateNode = null;
// Node objectNode = null;
//}
//{
//  (subjectNode = VarOrIRIref() | subjectNode = BlankNode()) predicateNode = VarOrIRIref() 
//    ( objectNode = PWindowGraphTerm() | objectNode = VarOrIRIref())
//    { t = new Triple(subjectNode, predicateNode, objectNode); 
//      sep.setTriple(t);
//      return sep;
//    }
//}

//Node PWindowGraphTerm() : {Node n = null;}
//{
//  (n = IRIref() | n = RDFLiteral() | n = NumericLiteral() | n = BooleanLiteral())
//  { return n; }
//}
  final public long ValueSpecification() throws ParseException {
    trace_call("ValueSpecification");
    try {
 /*@bgen(jjtree) ValueSpecification */
    ASTValueSpecification jjtn000 = new ASTValueSpecification(JJTVALUESPECIFICATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token size = null;
    int factor = 1;
      try {
        size = jj_consume_token(INTEGER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MS:
        case S:
        case MINUTE:
        case HOUR:
        case DAY:
        case WEEK:
          factor = Timeunit();
          break;
        default:
          jj_la1[31] = jj_gen;
          ;
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    long longValue = Long.parseLong(size.toString());
        {if (true) return longValue * factor;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ValueSpecification");
    }
  }

/**
This rule returns the factor to multiply with to get a window size in milliseconds.
E. g. a window size of 2 hours is equal to a size of 7200000 milliseconds.
*/
  final public int Timeunit() throws ParseException {
    trace_call("Timeunit");
    try {
                  /*@bgen(jjtree) Timeunit */
                  ASTTimeunit jjtn000 = new ASTTimeunit(JJTTIMEUNIT);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);int factor = 1;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MS:
          jj_consume_token(MS);
         factor = 1;
          break;
        case S:
          jj_consume_token(S);
          factor = 1000;
          break;
        case MINUTE:
          jj_consume_token(MINUTE);
              factor = 60000;
          break;
        case HOUR:
          jj_consume_token(HOUR);
            factor = 3600000;
          break;
        case DAY:
          jj_consume_token(DAY);
           factor  = 86400000;
          break;
        case WEEK:
          jj_consume_token(WEEK);
            factor = 604800000;
          break;
        default:
          jj_la1[32] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return factor;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Timeunit");
    }
  }

// ================ END STREAM ====================
  final public INode SourceSelector() throws ParseException {
    trace_call("SourceSelector");
    try {
                          /*@bgen(jjtree) SourceSelector */
                          ASTSourceSelector jjtn000 = new ASTSourceSelector(JJTSOURCESELECTOR);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);INode iri;
      try {
        iri = IRI_REF();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return iri;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SourceSelector");
    }
  }

  final public void WhereClause() throws ParseException {
    trace_call("WhereClause");
    try {
                      /*@bgen(jjtree) WhereClause */
  ASTWhereClause jjtn000 = new ASTWhereClause(JJTWHERECLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        jj_consume_token(WHERE);
        GroupGraphPattern();
      } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
      } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
      }
    } finally {
      trace_return("WhereClause");
    }
  }

  final public void GroupBy() throws ParseException {
    trace_call("GroupBy");
    try {
                  /*@bgen(jjtree) GroupBy */
                   ASTGroupBy jjtn000 = new ASTGroupBy(JJTGROUPBY);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);INode v;
      try {
        jj_consume_token(GROUP);
        jj_consume_token(BY);
        jj_consume_token(LPAREN);
        label_5:
        while (true) {
          v = Var();
                                           jjtn000.addVariable((Variable)v);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case VAR1:
          case VAR2:
            ;
            break;
          default:
            jj_la1[33] = jj_gen;
            break label_5;
          }
        }
        jj_consume_token(RPAREN);
      } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
      } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
      }
    } finally {
      trace_return("GroupBy");
    }
  }

  final public void SolutionModifier() throws ParseException {
    trace_call("SolutionModifier");
    try {
                           /*@bgen(jjtree) SolutionModifier */
  ASTSolutionModifier jjtn000 = new ASTSolutionModifier(JJTSOLUTIONMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ORDER:
          OrderClause();
          break;
        default:
          jj_la1[34] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LIMIT:
        case OFFSET:
          LimitOffsetClauses();
          break;
        default:
          jj_la1[35] = jj_gen;
          ;
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("SolutionModifier");
    }
  }

  final public void LimitOffsetClauses() throws ParseException {
    trace_call("LimitOffsetClauses");
    try {
                             /*@bgen(jjtree) LimitOffsetClauses */
  ASTLimitOffsetClauses jjtn000 = new ASTLimitOffsetClauses(JJTLIMITOFFSETCLAUSES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LIMIT:
          LimitClause();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OFFSET:
            OffsetClause();
            break;
          default:
            jj_la1[36] = jj_gen;
            ;
          }
          break;
        case OFFSET:
          OffsetClause();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LIMIT:
            LimitClause();
            break;
          default:
            jj_la1[37] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("LimitOffsetClauses");
    }
  }

  final public void OrderClause() throws ParseException {
    trace_call("OrderClause");
    try {
                      /*@bgen(jjtree) OrderClause */
  ASTOrderClause jjtn000 = new ASTOrderClause(JJTORDERCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        jj_consume_token(ORDER);
        jj_consume_token(BY);
        label_6:
        while (true) {
          OrderCondition();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case VAR1:
          case VAR2:
          case ASC:
          case DESC:
          case BOUND:
          case STR:
          case DTYPE:
          case LANG:
          case LANGMATCHES:
          case IS_URI:
          case IS_IRI:
          case IS_BLANK:
          case IS_LITERAL:
          case REGEX:
          case SAME_TERM:
          case IDENTIFIER:
          case LPAREN:
            ;
            break;
          default:
            jj_la1[39] = jj_gen;
            break label_6;
          }
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("OrderClause");
    }
  }

  final public void OrderCondition() throws ParseException {
    trace_call("OrderCondition");
    try {
 /*@bgen(jjtree) OrderCondition */
  ASTOrderCondition jjtn000 = new ASTOrderCondition(JJTORDERCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int direction = 0 ; INode v = null ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASC:
        case DESC:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASC:
            jj_consume_token(ASC);
            break;
          case DESC:
            jj_consume_token(DESC);
            break;
          default:
            jj_la1[40] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          BrackettedExpression();
          break;
        case VAR1:
        case VAR2:
        case BOUND:
        case STR:
        case DTYPE:
        case LANG:
        case LANGMATCHES:
        case IS_URI:
        case IS_IRI:
        case IS_BLANK:
        case IS_LITERAL:
        case REGEX:
        case SAME_TERM:
        case IDENTIFIER:
        case LPAREN:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BOUND:
          case STR:
          case DTYPE:
          case LANG:
          case LANGMATCHES:
          case IS_URI:
          case IS_IRI:
          case IS_BLANK:
          case IS_LITERAL:
          case REGEX:
          case SAME_TERM:
          case IDENTIFIER:
          case LPAREN:
            Constraint();
            break;
          case VAR1:
          case VAR2:
            v = Var();
            break;
          default:
            jj_la1[41] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("OrderCondition");
    }
  }

  final public void LimitClause() throws ParseException {
    trace_call("LimitClause");
    try {
                      /*@bgen(jjtree) LimitClause */
                       ASTLimitClause jjtn000 = new ASTLimitClause(JJTLIMITCLAUSE);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);Token t ;
      try {
        jj_consume_token(LIMIT);
        t = jj_consume_token(INTEGER);
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("LimitClause");
    }
  }

  final public void OffsetClause() throws ParseException {
    trace_call("OffsetClause");
    try {
                       /*@bgen(jjtree) OffsetClause */
                        ASTOffsetClause jjtn000 = new ASTOffsetClause(JJTOFFSETCLAUSE);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);Token t ;
      try {
        jj_consume_token(OFFSET);
        t = jj_consume_token(INTEGER);
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("OffsetClause");
    }
  }

// ---- General Graph Pattern 
  final public void GroupGraphPattern() throws ParseException {
    trace_call("GroupGraphPattern");
    try {
                            /*@bgen(jjtree) GroupGraphPattern */
                             ASTGroupGraphPattern jjtn000 = new ASTGroupGraphPattern(JJTGROUPGRAPHPATTERN);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);WindowAO window;
      try {
        jj_consume_token(LBRACE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case TRUE:
        case FALSE:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case NIL:
        case ANON:
          TriplesBlock();
          break;
        default:
          jj_la1[43] = jj_gen;
          ;
        }
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case GRAPH:
          case OPTIONAL:
          case FILTER:
          case LBRACE:
            ;
            break;
          default:
            jj_la1[44] = jj_gen;
            break label_7;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case GRAPH:
          case OPTIONAL:
          case LBRACE:
            GraphPatternNotTriples();
            break;
          case FILTER:
            Filter();
            break;
          default:
            jj_la1[45] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DOT:
            jj_consume_token(DOT);
            break;
          default:
            jj_la1[46] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
          case BLANK_NODE_LABEL:
          case VAR1:
          case VAR2:
          case TRUE:
          case FALSE:
          case INTEGER:
          case DECIMAL:
          case DOUBLE:
          case INTEGER_POSITIVE:
          case DECIMAL_POSITIVE:
          case DOUBLE_POSITIVE:
          case INTEGER_NEGATIVE:
          case DECIMAL_NEGATIVE:
          case DOUBLE_NEGATIVE:
          case STRING_LITERAL1:
          case STRING_LITERAL2:
          case STRING_LITERAL_LONG1:
          case STRING_LITERAL_LONG2:
          case NIL:
          case ANON:
            TriplesBlock();
            break;
          default:
            jj_la1[47] = jj_gen;
            ;
          }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WINDOW:
          window = WindowNotPWindow();
                              jjtn000.setWindowAO(window);
          break;
        default:
          jj_la1[48] = jj_gen;
          ;
        }
        jj_consume_token(RBRACE);
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("GroupGraphPattern");
    }
  }

  final public void TriplesBlock() throws ParseException {
    trace_call("TriplesBlock");
    try {
                       /*@bgen(jjtree) TriplesBlock */
  ASTTriplesBlock jjtn000 = new ASTTriplesBlock(JJTTRIPLESBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);List<List<Triple >> triples = new ArrayList<List<Triple>>();
  List<Triple> curSubjTriples;
      try {
        curSubjTriples = TriplesSameSubject();
    triples.add(curSubjTriples);
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DOT:
            ;
            break;
          default:
            jj_la1[49] = jj_gen;
            break label_8;
          }
          jj_consume_token(DOT);
          curSubjTriples = TriplesSameSubject();
                         triples.add(curSubjTriples);
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setTriples(triples);
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("TriplesBlock");
    }
  }

// @@ Ready to be deleted
// Element GroupGraphPattern() : { Element el = null ; ElementTriplesBlock acc = null ; }
// {
//     { ElementGroup elg = new ElementGroup() ; }
//   <LBRACE>
//       { startGroup(elg) ; }
//   // Ensure two BGP's can't be next to each other
//   // Done by seeing if there is a non-BGP and recursing
//   // if there is an intermediate
//   (
//     { acc = new ElementTriplesBlock() ;
//       startTriplesBlock(acc) ;
//     }
//     el = TriplesBlock(acc)
//     { endTriplesBlock(acc) ;
//       elg.addElement(el) ; } 
//   )?
//   (
//     ( el = GraphPatternNotTriples() | el = Filter() )
//     { elg.addElement(el) ; }
//     (<DOT>)?
// 
//     (
//       { acc = new ElementTriplesBlock() ;
//         startTriplesBlock(acc) ;
//       }
//       el = TriplesBlock(acc)
//       { endTriplesBlock(acc) ;
//         elg.addElement(el) ; } 
//     )?
//   )*
//       { endGroup(elg) ; }
//   <RBRACE>
//     { return elg ; }
// }

// Element GroupGraphPattern() : {}
// {
//     { ElementGroup elg = new ElementGroup() ; }
//   <LBRACE>
//       { startGroup(elg) ; }
//     GraphPatternElement(elg)
//       { endGroup(elg) ; }
//   <RBRACE>
//     { return elg ; }
// }
// 
// 
// // Without {}
// // If the recusion is removed can roll GraphPatternElement into GroupGraphPattern()
// 
// void GraphPatternElement(ElementGroup elg) : 
//     { Element el = null ; ElementTriplesBlock acc = null ; }
// {
//   // Ensure two BGP's can't be next to each other
//   // Done by seeing if there is a non-BGP and recursing
//   // if there is an intermediate
//   (
//     { acc = new ElementTriplesBlock() ;
//       startTriplesBlock(acc) ;
//     }
//     el = TriplesBlock(acc)
//     { endTriplesBlock(acc) ;
//       elg.addElement(el) ; } 
//   )?
//   (
//     ( el = GraphPatternNotTriples()
//     | el = Filter()                 
//     )
//     { elg.addElement(el) ; }
//     (<DOT>)?
//     GraphPatternElement(elg)
//   )?
// }
// 
// 
// Element TriplesBlock(ElementTriplesBlock acc) : { }
// {
//   { if ( acc == null )
//       acc = new ElementTriplesBlock() ;
//   }
//   TriplesSameSubject(acc)
//   ( <DOT> (TriplesBlock(acc))? )?
//     { return acc ; }
// }


// -----
  final public void GraphPatternNotTriples() throws ParseException {
    trace_call("GraphPatternNotTriples");
    try {
                                 /*@bgen(jjtree) GraphPatternNotTriples */
  ASTGraphPatternNotTriples jjtn000 = new ASTGraphPatternNotTriples(JJTGRAPHPATTERNNOTTRIPLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPTIONAL:
          OptionalGraphPattern();
          break;
        case LBRACE:
          GroupOrUnionGraphPattern();
          break;
        case GRAPH:
          GraphGraphPattern();
          break;
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
      } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
      }
    } finally {
      trace_return("GraphPatternNotTriples");
    }
  }

// ---- Definitions of each pattern element
  final public void OptionalGraphPattern() throws ParseException {
    trace_call("OptionalGraphPattern");
    try {
                               /*@bgen(jjtree) OptionalGraphPattern */
  ASTOptionalGraphPattern jjtn000 = new ASTOptionalGraphPattern(JJTOPTIONALGRAPHPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        jj_consume_token(OPTIONAL);
        GroupGraphPattern();
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("OptionalGraphPattern");
    }
  }

  final public void GraphGraphPattern() throws ParseException {
    trace_call("GraphGraphPattern");
    try {
                            /*@bgen(jjtree) GraphGraphPattern */
                             ASTGraphGraphPattern jjtn000 = new ASTGraphGraphPattern(JJTGRAPHGRAPHPATTERN);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);INode n;
      try {
        jj_consume_token(GRAPH);
        n = VarOrIRIref();
                          jjtn000.setGraphTerm(n);
        GroupGraphPattern();
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("GraphGraphPattern");
    }
  }

// G (union G)* can be a single group pattern
// or a group pattern as part of an union.
  final public void GroupOrUnionGraphPattern() throws ParseException {
    trace_call("GroupOrUnionGraphPattern");
    try {
 /*@bgen(jjtree) GroupOrUnionGraphPattern */
  ASTGroupOrUnionGraphPattern jjtn000 = new ASTGroupOrUnionGraphPattern(JJTGROUPORUNIONGRAPHPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        GroupGraphPattern();
        label_9:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case UNION:
            ;
            break;
          default:
            jj_la1[51] = jj_gen;
            break label_9;
          }
          jj_consume_token(UNION);
          GroupGraphPattern();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("GroupOrUnionGraphPattern");
    }
  }

  final public void Filter() throws ParseException {
    trace_call("Filter");
    try {
                 /*@bgen(jjtree) Filter */
  ASTFilter jjtn000 = new ASTFilter(JJTFILTER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        jj_consume_token(FILTER);
        Constraint();
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("Filter");
    }
  }

  final public void Constraint() throws ParseException {
    trace_call("Constraint");
    try {
                     /*@bgen(jjtree) Constraint */
                      ASTConstraint jjtn000 = new ASTConstraint(JJTCONSTRAINT);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);SimpleNode n;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          n = BrackettedExpression();
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                             jjtn000.setString(n.toString());
          break;
        case BOUND:
        case STR:
        case DTYPE:
        case LANG:
        case LANGMATCHES:
        case IS_URI:
        case IS_IRI:
        case IS_BLANK:
        case IS_LITERAL:
        case REGEX:
        case SAME_TERM:
          n = BuiltInCall();
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                    jjtn000.setString(n.toString());
          break;
        case IDENTIFIER:
          n = FunctionCall();
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                     jjtn000.setString(n.toString());
          break;
        default:
          jj_la1[52] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("Constraint");
    }
  }

  final public SimpleNode FunctionCall() throws ParseException {
    trace_call("FunctionCall");
    try {
                             /*@bgen(jjtree) FunctionCall */
                              ASTFunctionCall jjtn000 = new ASTFunctionCall(JJTFUNCTIONCALL);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);Token fName; SimpleNode argList;
      try {
        fName = jj_consume_token(IDENTIFIER);
        argList = ArgList();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        jjtn000.setString(fName.image + argList.toString());
        {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FunctionCall");
    }
  }

  final public SimpleNode ArgList() throws ParseException {
    trace_call("ArgList");
    try {
 /*@bgen(jjtree) ArgList */
        ASTArgList jjtn000 = new ASTArgList(JJTARGLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String str = "";
        SimpleNode expr;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NIL:
          jj_consume_token(NIL);
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          expr = Expression();
                        str+= "(" + expr.toString();
          label_10:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[53] = jj_gen;
              break label_10;
            }
            jj_consume_token(COMMA);
            expr = Expression();
                                  str += ", " + expr.toString();
          }
          jj_consume_token(RPAREN);
              str+= ")";
          break;
        default:
          jj_la1[54] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
        jjtn000.setString(str);
        {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ArgList");
    }
  }

// -------- Construct patterns
  final public void ConstructTemplate() throws ParseException {
    trace_call("ConstructTemplate");
    try {
                            /*@bgen(jjtree) ConstructTemplate */
  ASTConstructTemplate jjtn000 = new ASTConstructTemplate(JJTCONSTRUCTTEMPLATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        jj_consume_token(LBRACE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case TRUE:
        case FALSE:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case NIL:
        case ANON:
          ConstructTriples();
          break;
        default:
          jj_la1[55] = jj_gen;
          ;
        }
        jj_consume_token(RBRACE);
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("ConstructTemplate");
    }
  }

  final public void ConstructTriples() throws ParseException {
    trace_call("ConstructTriples");
    try {
                           /*@bgen(jjtree) ConstructTriples */
  ASTConstructTriples jjtn000 = new ASTConstructTriples(JJTCONSTRUCTTRIPLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        TriplesSameSubject();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          jj_consume_token(DOT);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
          case BLANK_NODE_LABEL:
          case VAR1:
          case VAR2:
          case TRUE:
          case FALSE:
          case INTEGER:
          case DECIMAL:
          case DOUBLE:
          case INTEGER_POSITIVE:
          case DECIMAL_POSITIVE:
          case DOUBLE_POSITIVE:
          case INTEGER_NEGATIVE:
          case DECIMAL_NEGATIVE:
          case DOUBLE_NEGATIVE:
          case STRING_LITERAL1:
          case STRING_LITERAL2:
          case STRING_LITERAL_LONG1:
          case STRING_LITERAL_LONG2:
          case NIL:
          case ANON:
            ConstructTriples();
            break;
          default:
            jj_la1[56] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[57] = jj_gen;
          ;
        }
      } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
      } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
      }
    } finally {
      trace_return("ConstructTriples");
    }
  }

// -------- Triple lists with property and object lists
  final public List<Triple> TriplesSameSubject() throws ParseException {
    trace_call("TriplesSameSubject");
    try {
 /*@bgen(jjtree) TriplesSameSubject */
  ASTTriplesSameSubject jjtn000 = new ASTTriplesSameSubject(JJTTRIPLESSAMESUBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);List<Triple > triples = new ArrayList<Triple>();
  INode subject;
  PropertiesAndObjects paos;
      try {
        subject = VarOrTerm();
        paos = PropertyListNotEmpty();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    for(INode curProp: paos.getProperties()){
      for(INode curObject: paos.getObjects(curProp)){
        triples.add(new Triple(subject, curProp, curObject));
      }
    }

    {if (true) return triples;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TriplesSameSubject");
    }
  }

  final public PropertiesAndObjects PropertyListNotEmpty() throws ParseException {
    trace_call("PropertyListNotEmpty");
    try {
 /*@bgen(jjtree) PropertyListNotEmpty */
  ASTPropertyListNotEmpty jjtn000 = new ASTPropertyListNotEmpty(JJTPROPERTYLISTNOTEMPTY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);PropertiesAndObjects paos = new PropertiesAndObjects();
  INode predicate ;
  List<INode > objects;
      try {
        predicate = Verb();
        objects = ObjectList();
    paos.putPropertyAndObjects(predicate, objects);
        label_11:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEMICOLON:
            ;
            break;
          default:
            jj_la1[58] = jj_gen;
            break label_11;
          }
          jj_consume_token(SEMICOLON);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
          case VAR1:
          case VAR2:
          case KW_A:
            predicate = Verb();
            objects = ObjectList();
          paos.putPropertyAndObjects(predicate, objects);
            break;
          default:
            jj_la1[59] = jj_gen;
            ;
          }
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return paos;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PropertyListNotEmpty");
    }
  }

  final public PropertiesAndObjects PropertyList() throws ParseException {
    trace_call("PropertyList");
    try {
                                       /*@bgen(jjtree) PropertyList */
                                        ASTPropertyList jjtn000 = new ASTPropertyList(JJTPROPERTYLIST);
                                        boolean jjtc000 = true;
                                        jjtree.openNodeScope(jjtn000);PropertiesAndObjects paos;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
        case KW_A:
          paos = PropertyListNotEmpty();
    {if (true) return paos;}
          break;
        default:
          jj_la1[60] = jj_gen;
          ;
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PropertyList");
    }
  }

// // Recursive
// void PropertyListNotEmpty(Node s, TripleCollector acc) : { Node p ; }
// {
//   p = Verb()
//   ObjectList(s, p, acc)
//   (<SEMICOLON> PropertyList(s, acc) ) ?
// #ifdef ARQ
//   |
//   Reification(s, acc)
// #endif
// }

// // Recursive
// void ObjectList(Node s, Node p, TripleCollector acc): { Node o ; } 
// {
//     { int mark = acc.mark() ; }
//   o = GraphNode(acc) 
//     { insert(acc, mark, s, p, o) ; }
//   ( <COMMA> ObjectList(s, p , acc) )?
// }
  final public List<INode> ObjectList() throws ParseException {
    trace_call("ObjectList");
    try {
 /*@bgen(jjtree) ObjectList */
  ASTObjectList jjtn000 = new ASTObjectList(JJTOBJECTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);List<INode > objects = new ArrayList<INode >();
  INode obj;
      try {
        obj = Object();
    objects.add(obj);
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[61] = jj_gen;
            break label_12;
          }
          jj_consume_token(COMMA);
          obj = Object();
    objects.add(obj);
        }
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     {if (true) return objects;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ObjectList");
    }
  }

  final public INode Object() throws ParseException {
    trace_call("Object");
    try {
                 /*@bgen(jjtree) Object */
                 ASTObject jjtn000 = new ASTObject(JJTOBJECT);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);INode object;
      try {
        object = GraphNode();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return object;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Object");
    }
  }

  final public INode Verb() throws ParseException {
    trace_call("Verb");
    try {
                /*@bgen(jjtree) Verb */
                ASTVerb jjtn000 = new ASTVerb(JJTVERB);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);INode p ; Token t;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
          p = VarOrIRIref();
          break;
        case KW_A:
          t = jj_consume_token(KW_A);
                                  p = new Literal("rdf:type");
          break;
        default:
          jj_la1[62] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return p ;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Verb");
    }
  }

// -------- Triple expansions

// Anything that can stand in a node slot and which is
// a number of triples
  final public INode TriplesNode() throws ParseException {
    trace_call("TriplesNode");
    try {
                       /*@bgen(jjtree) TriplesNode */
                        ASTTriplesNode jjtn000 = new ASTTriplesNode(JJTTRIPLESNODE);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);INode n ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          Collection();
          break;
        case LBRACKET:
          BlankNodePropertyList();
          break;
        default:
          jj_la1[63] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TriplesNode");
    }
  }

  final public void BlankNodePropertyList() throws ParseException {
    trace_call("BlankNodePropertyList");
    try {
                                /*@bgen(jjtree) BlankNodePropertyList */
  ASTBlankNodePropertyList jjtn000 = new ASTBlankNodePropertyList(JJTBLANKNODEPROPERTYLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        jj_consume_token(LBRACKET);
        PropertyListNotEmpty();
        jj_consume_token(RBRACKET);
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("BlankNodePropertyList");
    }
  }

// ------- RDF collections
  final public void Collection() throws ParseException {
    trace_call("Collection");
    try {
     /*@bgen(jjtree) Collection */
     ASTCollection jjtn000 = new ASTCollection(JJTCOLLECTION);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);INode graphNode;
      try {
        jj_consume_token(LPAREN);
        label_13:
        while (true) {
          graphNode = GraphNode();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
          case BLANK_NODE_LABEL:
          case VAR1:
          case VAR2:
          case TRUE:
          case FALSE:
          case INTEGER:
          case DECIMAL:
          case DOUBLE:
          case INTEGER_POSITIVE:
          case DECIMAL_POSITIVE:
          case DOUBLE_POSITIVE:
          case INTEGER_NEGATIVE:
          case DECIMAL_NEGATIVE:
          case DOUBLE_NEGATIVE:
          case STRING_LITERAL1:
          case STRING_LITERAL2:
          case STRING_LITERAL_LONG1:
          case STRING_LITERAL_LONG2:
          case LPAREN:
          case NIL:
          case LBRACKET:
          case ANON:
            ;
            break;
          default:
            jj_la1[64] = jj_gen;
            break label_13;
          }
        }
        jj_consume_token(RPAREN);
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    } finally {
      trace_return("Collection");
    }
  }

// -------- Nodes in a graph pattern or template
  final public INode GraphNode() throws ParseException {
    trace_call("GraphNode");
    try {
                     /*@bgen(jjtree) GraphNode */
                      ASTGraphNode jjtn000 = new ASTGraphNode(JJTGRAPHNODE);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);INode n ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case TRUE:
        case FALSE:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case NIL:
        case ANON:
          n = VarOrTerm();
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    {if (true) return n ;}
          break;
        case LPAREN:
        case LBRACKET:
          n = TriplesNode();
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                      {if (true) return n ;}
          break;
        default:
          jj_la1[65] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("GraphNode");
    }
  }

  final public INode VarOrTerm() throws ParseException {
    trace_call("VarOrTerm");
    try {
                     /*@bgen(jjtree) VarOrTerm */
                     ASTVarOrTerm jjtn000 = new ASTVarOrTerm(JJTVARORTERM);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);INode n = null ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR1:
        case VAR2:
          n = Var();
          break;
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case TRUE:
        case FALSE:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case NIL:
        case ANON:
          n = GraphTerm();
          break;
        default:
          jj_la1[66] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return n ;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("VarOrTerm");
    }
  }

// Property (if no bNodes) + DESCRIBE
  final public INode VarOrIRIref() throws ParseException {
    trace_call("VarOrIRIref");
    try {
                       /*@bgen(jjtree) VarOrIRIref */
                       ASTVarOrIRIref jjtn000 = new ASTVarOrIRIref(JJTVARORIRIREF);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);INode n = null ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR1:
        case VAR2:
          n = Var();
          break;
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
          n = IRIref();
          break;
        default:
          jj_la1[67] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return n ;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("VarOrIRIref");
    }
  }

// // GRAPH and property if including blank nodes are properties.
// Node VarOrBlankNodeOrIRIref() : {Node n = null ; }
// {
//   ( n = Var() | n = BlankNode() | n = IRIref() )
//   { return n ; }
// }
  final public Variable Var() throws ParseException {
    trace_call("Var");
    try {
                  /*@bgen(jjtree) Var */
                   ASTVar jjtn000 = new ASTVar(JJTVAR);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);Token t ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR1:
          t = jj_consume_token(VAR1);
          break;
        case VAR2:
          t = jj_consume_token(VAR2);
          break;
        default:
          jj_la1[68] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new Variable(t.image) ;}
      } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Var");
    }
  }

  final public INode GraphTerm() throws ParseException {
    trace_call("GraphTerm");
    try {
                     /*@bgen(jjtree) GraphTerm */
                      ASTGraphTerm jjtn000 = new ASTGraphTerm(JJTGRAPHTERM);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);INode n ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
          n = IRIref();
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 {if (true) return n ;}
          break;
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
          n = RDFLiteral();
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     {if (true) return n ;}
          break;
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
          n = NumericLiteral();
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         {if (true) return n ;}
          break;
        case TRUE:
        case FALSE:
          n = BooleanLiteral();
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         {if (true) return n ;}
          break;
        case BLANK_NODE_LABEL:
        case ANON:
          n = BlankNode();
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    {if (true) return n ;}
          break;
        case NIL:
          jj_consume_token(NIL);
         jjtree.closeNodeScope(jjtn000, true);
         jjtc000 = false;
        {if (true) return BlankNode.NIL;}
          break;
        default:
          jj_la1[69] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("GraphTerm");
    }
  }

// -------- Constraint syntax
  final public SimpleNode Expression() throws ParseException {
    trace_call("Expression");
    try {
                           /*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        ConditionalOrExpression();
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                            {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Expression");
    }
  }

  final public SimpleNode ConditionalOrExpression() throws ParseException {
    trace_call("ConditionalOrExpression");
    try {
                                        /*@bgen(jjtree) ConditionalOrExpression */
  ASTConditionalOrExpression jjtn000 = new ASTConditionalOrExpression(JJTCONDITIONALOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        ConditionalAndExpression();
        label_14:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SC_OR:
            ;
            break;
          default:
            jj_la1[70] = jj_gen;
            break label_14;
          }
          jj_consume_token(SC_OR);
          ConditionalAndExpression();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ConditionalOrExpression");
    }
  }

  final public SimpleNode ConditionalAndExpression() throws ParseException {
    trace_call("ConditionalAndExpression");
    try {
                                         /*@bgen(jjtree) ConditionalAndExpression */
  ASTConditionalAndExpression jjtn000 = new ASTConditionalAndExpression(JJTCONDITIONALANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        ValueLogical();
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SC_AND:
            ;
            break;
          default:
            jj_la1[71] = jj_gen;
            break label_15;
          }
          jj_consume_token(SC_AND);
          ValueLogical();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ConditionalAndExpression");
    }
  }

  final public SimpleNode ValueLogical() throws ParseException {
    trace_call("ValueLogical");
    try {
                             /*@bgen(jjtree) ValueLogical */
  ASTValueLogical jjtn000 = new ASTValueLogical(JJTVALUELOGICAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        RelationalExpression();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ValueLogical");
    }
  }

  final public SimpleNode RelationalExpression() throws ParseException {
    trace_call("RelationalExpression");
    try {
                                     /*@bgen(jjtree) RelationalExpression */
                                      ASTRelationalExpression jjtn000 = new ASTRelationalExpression(JJTRELATIONALEXPRESSION);
                                      boolean jjtc000 = true;
                                      jjtree.openNodeScope(jjtn000);Token t = null;
      try {
        NumericExpression();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQ:
        case NE:
        case GT:
        case LT:
        case LE:
        case GE:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EQ:
            t = jj_consume_token(EQ);
            NumericExpression();
            break;
          case NE:
            t = jj_consume_token(NE);
            NumericExpression();
            break;
          case LT:
            t = jj_consume_token(LT);
            NumericExpression();
            break;
          case GT:
            t = jj_consume_token(GT);
            NumericExpression();
            break;
          case LE:
            t = jj_consume_token(LE);
            NumericExpression();
            break;
          case GE:
            t = jj_consume_token(GE);
            NumericExpression();
            break;
          default:
            jj_la1[72] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[73] = jj_gen;
          ;
        }
    if(t != null){
      jjtn000.setCompareOperator(t.image);
    }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RelationalExpression");
    }
  }

  final public SimpleNode NumericExpression() throws ParseException {
    trace_call("NumericExpression");
    try {
                                   /*@bgen(jjtree) NumericExpression */
  ASTNumericExpression jjtn000 = new ASTNumericExpression(JJTNUMERICEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        AdditiveExpression();
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                       {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NumericExpression");
    }
  }

  final public SimpleNode AdditiveExpression() throws ParseException {
    trace_call("AdditiveExpression");
    try {
 /*@bgen(jjtree) AdditiveExpression */
  ASTAdditiveExpression jjtn000 = new ASTAdditiveExpression(JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str = "";
  SimpleNode tempExpr;
  INode lit;
      try {
        tempExpr = MultiplicativeExpression();
    str += tempExpr.toString();
        label_16:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INTEGER_POSITIVE:
          case DECIMAL_POSITIVE:
          case DOUBLE_POSITIVE:
          case INTEGER_NEGATIVE:
          case DECIMAL_NEGATIVE:
          case DOUBLE_NEGATIVE:
          case PLUS:
          case MINUS:
            ;
            break;
          default:
            jj_la1[74] = jj_gen;
            break label_16;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PLUS:
            jj_consume_token(PLUS);
            tempExpr = MultiplicativeExpression();
                                                 str += " + " + tempExpr.toString();
            break;
          case MINUS:
            jj_consume_token(MINUS);
            tempExpr = MultiplicativeExpression();
                                                  str += " - " + tempExpr.toString();
            break;
          case INTEGER_POSITIVE:
          case DECIMAL_POSITIVE:
          case DOUBLE_POSITIVE:
            lit = NumericLiteralPositive();
                                 str += lit.getName();
            break;
          case INTEGER_NEGATIVE:
          case DECIMAL_NEGATIVE:
          case DOUBLE_NEGATIVE:
            lit = NumericLiteralNegative();
                                 str += lit.getName();
            break;
          default:
            jj_la1[75] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
    jjtn000.setString(str);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AdditiveExpression");
    }
  }

  final public SimpleNode MultiplicativeExpression() throws ParseException {
    trace_call("MultiplicativeExpression");
    try {
 /*@bgen(jjtree) MultiplicativeExpression */
  ASTMultiplicativeExpression jjtn000 = new ASTMultiplicativeExpression(JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str = "";
  SimpleNode tempExpr;
      try {
        tempExpr = UnaryExpression();
                             str += tempExpr.toString();
        label_17:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case STAR:
          case SLASH:
            ;
            break;
          default:
            jj_la1[76] = jj_gen;
            break label_17;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case STAR:
            jj_consume_token(STAR);
            tempExpr = UnaryExpression();
                                      str+=" * " + tempExpr.toString();
            break;
          case SLASH:
            jj_consume_token(SLASH);
            tempExpr = UnaryExpression();
                                       str += "/" + tempExpr.toString();
            break;
          default:
            jj_la1[77] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        jjtn000.setString(str);
    {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MultiplicativeExpression");
    }
  }

  final public SimpleNode UnaryExpression() throws ParseException {
    trace_call("UnaryExpression");
    try {
 /*@bgen(jjtree) UnaryExpression */
        ASTUnaryExpression jjtn000 = new ASTUnaryExpression(JJTUNARYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String str = "";
        SimpleNode tempExpr;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          tempExpr = PrimaryExpression();
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                      str += " + " + tempExpr.toString();
          break;
        case MINUS:
          jj_consume_token(MINUS);
          tempExpr = PrimaryExpression();
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                         str += " - " + tempExpr.toString();
          break;
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
        case BOUND:
        case STR:
        case DTYPE:
        case LANG:
        case LANGMATCHES:
        case IS_URI:
        case IS_IRI:
        case IS_BLANK:
        case IS_LITERAL:
        case REGEX:
        case SAME_TERM:
        case TRUE:
        case FALSE:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case IDENTIFIER:
        case LPAREN:
          tempExpr = PrimaryExpression();
                                 str+= tempExpr.toString();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        jjtn000.setString(str);
        {if (true) return jjtn000;}
          break;
        default:
          jj_la1[78] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("UnaryExpression");
    }
  }

  final public SimpleNode PrimaryExpression() throws ParseException {
    trace_call("PrimaryExpression");
    try {
 /*@bgen(jjtree) PrimaryExpression */
        ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(JJTPRIMARYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);SimpleNode expr;
        String str;
        INode node;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          expr = BrackettedExpression();
                                jjtn000.setString(expr.toString());
          break;
        case BOUND:
        case STR:
        case DTYPE:
        case LANG:
        case LANGMATCHES:
        case IS_URI:
        case IS_IRI:
        case IS_BLANK:
        case IS_LITERAL:
        case REGEX:
        case SAME_TERM:
          expr = BuiltInCall();
                       jjtn000.setString(expr.toString());
          break;
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case IDENTIFIER:
          expr = IRIrefOrFunction();
                            jjtn000.setString(expr.toString());
          break;
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
          node = RDFLiteral();
                      jjtn000.setString(node.getName());
          break;
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
          node = NumericLiteral();
                          jjtn000.setString(node.getName());
          break;
        case TRUE:
        case FALSE:
          node = BooleanLiteral();
                          jjtn000.setString(node.getName());
          break;
        case VAR1:
        case VAR2:
          node = Var();
               jjtn000.setString(node.getName());
          break;
        default:
          jj_la1[79] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PrimaryExpression");
    }
  }

  final public SimpleNode BrackettedExpression() throws ParseException {
    trace_call("BrackettedExpression");
    try {
 /*@bgen(jjtree) BrackettedExpression */
  ASTBrackettedExpression jjtn000 = new ASTBrackettedExpression(JJTBRACKETTEDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        jj_consume_token(LPAREN);
        Expression();
        jj_consume_token(RPAREN);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
     {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
      } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BrackettedExpression");
    }
  }

  final public SimpleNode BuiltInCall() throws ParseException {
    trace_call("BuiltInCall");
    try {
 /*@bgen(jjtree) BuiltInCall */
        ASTBuiltInCall jjtn000 = new ASTBuiltInCall(JJTBUILTINCALL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String str = "";
        SimpleNode node;
        SimpleNode node2;
        Variable var;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STR:
          jj_consume_token(STR);
          jj_consume_token(LPAREN);
          node = Expression();
          jj_consume_token(RPAREN);
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                               jjtn000.setString("str(" + node.toString() + ")");
          break;
        case LANG:
          jj_consume_token(LANG);
          jj_consume_token(LPAREN);
          node = Expression();
          jj_consume_token(RPAREN);
                                                 jjtree.closeNodeScope(jjtn000, true);
                                                 jjtc000 = false;
                                                jjtn000.setString("lang(" + node.toString() + ")");
          break;
        case LANGMATCHES:
          jj_consume_token(LANGMATCHES);
          jj_consume_token(LPAREN);
          node = Expression();
          jj_consume_token(COMMA);
          node2 = Expression();
          jj_consume_token(RPAREN);
         jjtree.closeNodeScope(jjtn000, true);
         jjtc000 = false;
        jjtn000.setString("langMatches(" + node.toString() + ", " + node2.toString() + ")");
          break;
        case DTYPE:
          jj_consume_token(DTYPE);
          jj_consume_token(LPAREN);
          node = Expression();
          jj_consume_token(RPAREN);
                                                 jjtree.closeNodeScope(jjtn000, true);
                                                 jjtc000 = false;
                                                jjtn000.setString("datatype(" + node.toString() + ")");
          break;
        case BOUND:
          jj_consume_token(BOUND);
          jj_consume_token(LPAREN);
          var = Var();
          jj_consume_token(RPAREN);
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                        jjtn000.setString("bound(" + var.getName() + ")");
          break;
        case SAME_TERM:
          jj_consume_token(SAME_TERM);
          jj_consume_token(LPAREN);
          node = Expression();
          jj_consume_token(COMMA);
          node2 = Expression();
          jj_consume_token(RPAREN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   jjtn000.setString("sameTerm(" + node.toString() + ", " + node2.toString() + ")");
          break;
        case IS_IRI:
          jj_consume_token(IS_IRI);
          jj_consume_token(LPAREN);
          node = Expression();
          jj_consume_token(RPAREN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   jjtn000.setString("isIRI(" + node.toString() + ")");
          break;
        case IS_URI:
          jj_consume_token(IS_URI);
          jj_consume_token(LPAREN);
          node = Expression();
          jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         jjtn000.setString("isURI(" + node.toString() + ")");
          break;
        case IS_BLANK:
          jj_consume_token(IS_BLANK);
          jj_consume_token(LPAREN);
          node = Expression();
          jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         jjtn000.setString("isBlank(" + node.toString() + ")");
          break;
        case IS_LITERAL:
          jj_consume_token(IS_LITERAL);
          jj_consume_token(LPAREN);
          node = Expression();
          jj_consume_token(RPAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         jjtn000.setString("isLiteral(" + node.toString() + ")");
          break;
        case REGEX:
          // Regular expression matcher
              node = RegexExpression();
                           jjtn000.setString(node.toString());
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
     {if (true) return jjtn000;}
          break;
        default:
          jj_la1[80] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
      } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BuiltInCall");
    }
  }

  final public SimpleNode RegexExpression() throws ParseException {
    trace_call("RegexExpression");
    try {
 /*@bgen(jjtree) RegexExpression */
  ASTRegexExpression jjtn000 = new ASTRegexExpression(JJTREGEXEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        jj_consume_token(REGEX);
        jj_consume_token(LPAREN);
        Expression();
        jj_consume_token(COMMA);
        Expression();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          Expression();
          break;
        default:
          jj_la1[81] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
      } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
      } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RegexExpression");
    }
  }

// The case of "q:name()" or just "q:name"
// by expanding out FunctionCall()
  final public SimpleNode IRIrefOrFunction() throws ParseException {
    trace_call("IRIrefOrFunction");
    try {
 /*@bgen(jjtree) IRIrefOrFunction */
        ASTIRIrefOrFunction jjtn000 = new ASTIRIrefOrFunction(JJTIRIREFORFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);INode n;
        SimpleNode function;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
          n = IRIref();
                    jjtn000.setString(n.getName());
          break;
        case IDENTIFIER:
          function = FunctionCall();
                                jjtn000.setString(function.toString());
          break;
        default:
          jj_la1[82] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("IRIrefOrFunction");
    }
  }

  final public INode RDFLiteral() throws ParseException {
    trace_call("RDFLiteral");
    try {
 /*@bgen(jjtree) RDFLiteral */
        ASTRDFLiteral jjtn000 = new ASTRDFLiteral(JJTRDFLITERAL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String name;
        String lang;
        INode n;

        Literal lit;
      try {
        name = String();
                lit = new Literal(name);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AT:
          jj_consume_token(AT);
          lang = String();
                        lit.setLanguage(lang);
          break;
        default:
          jj_la1[83] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATATYPE:
          jj_consume_token(DATATYPE);
          n = IRIref();
                           lit.setDatatype(n.getName());
          break;
        default:
          jj_la1[84] = jj_gen;
          ;
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return lit;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RDFLiteral");
    }
  }

  final public INode NumericLiteral() throws ParseException {
    trace_call("NumericLiteral");
    try {
                          /*@bgen(jjtree) NumericLiteral */
                           ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);INode n ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
          n = NumericLiteralUnsigned();
          break;
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
          n = NumericLiteralPositive();
          break;
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
          n = NumericLiteralNegative();
          break;
        default:
          jj_la1[85] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return n ;}
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NumericLiteral");
    }
  }

  final public INode NumericLiteralUnsigned() throws ParseException {
    trace_call("NumericLiteralUnsigned");
    try {
                                  /*@bgen(jjtree) NumericLiteralUnsigned */
                                   ASTNumericLiteralUnsigned jjtn000 = new ASTNumericLiteralUnsigned(JJTNUMERICLITERALUNSIGNED);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);Token t ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
          t = jj_consume_token(INTEGER);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  {if (true) return new Literal(t.image) ;}
          break;
        case DECIMAL:
          t = jj_consume_token(DECIMAL);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  {if (true) return new Literal(t.image) ;}
          break;
        case DOUBLE:
          t = jj_consume_token(DOUBLE);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 {if (true) return new Literal(t.image) ;}
          break;
        default:
          jj_la1[86] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NumericLiteralUnsigned");
    }
  }

  final public INode NumericLiteralPositive() throws ParseException {
    trace_call("NumericLiteralPositive");
    try {
                                  /*@bgen(jjtree) NumericLiteralPositive */
                                   ASTNumericLiteralPositive jjtn000 = new ASTNumericLiteralPositive(JJTNUMERICLITERALPOSITIVE);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);Token t ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_POSITIVE:
          t = jj_consume_token(INTEGER_POSITIVE);
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                           {if (true) return new Literal(t.image) ;}
          break;
        case DECIMAL_POSITIVE:
          t = jj_consume_token(DECIMAL_POSITIVE);
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                           {if (true) return new Literal(t.image) ;}
          break;
        case DOUBLE_POSITIVE:
          t = jj_consume_token(DOUBLE_POSITIVE);
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          {if (true) return new Literal(t.image) ;}
          break;
        default:
          jj_la1[87] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NumericLiteralPositive");
    }
  }

  final public INode NumericLiteralNegative() throws ParseException {
    trace_call("NumericLiteralNegative");
    try {
                                  /*@bgen(jjtree) NumericLiteralNegative */
                                   ASTNumericLiteralNegative jjtn000 = new ASTNumericLiteralNegative(JJTNUMERICLITERALNEGATIVE);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);Token t ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_NEGATIVE:
          t = jj_consume_token(INTEGER_NEGATIVE);
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                           {if (true) return new Literal(t.image) ;}
          break;
        case DECIMAL_NEGATIVE:
          t = jj_consume_token(DECIMAL_NEGATIVE);
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                           {if (true) return new Literal(t.image) ;}
          break;
        case DOUBLE_NEGATIVE:
          t = jj_consume_token(DOUBLE_NEGATIVE);
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          {if (true) return new Literal(t.image) ;}
          break;
        default:
          jj_la1[88] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NumericLiteralNegative");
    }
  }

  final public INode BooleanLiteral() throws ParseException {
    trace_call("BooleanLiteral");
    try {
                          /*@bgen(jjtree) BooleanLiteral */
  ASTBooleanLiteral jjtn000 = new ASTBooleanLiteral(JJTBOOLEANLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TRUE:
          jj_consume_token(TRUE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return new Literal("true");}
          break;
        case FALSE:
          jj_consume_token(FALSE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return new Literal("false");}
          break;
        default:
          jj_la1[89] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BooleanLiteral");
    }
  }

  final public String String() throws ParseException {
    trace_call("String");
    try {
                   /*@bgen(jjtree) String */
                    ASTString jjtn000 = new ASTString(JJTSTRING);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t ; String lex ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL1:
          t = jj_consume_token(STRING_LITERAL1);
                            lex = stripQuotes(t.image) ;
          break;
        case STRING_LITERAL2:
          t = jj_consume_token(STRING_LITERAL2);
                            lex = stripQuotes(t.image) ;
          break;
        case STRING_LITERAL_LONG1:
          t = jj_consume_token(STRING_LITERAL_LONG1);
                                 lex = stripQuotes(t.image) ;
          break;
        case STRING_LITERAL_LONG2:
          t = jj_consume_token(STRING_LITERAL_LONG2);
                                 lex = stripQuotes(t.image) ;
          break;
        default:
          jj_la1[90] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      lex = unescapeStr(lex, t.beginLine, t.beginColumn) ;
      {if (true) return lex ;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("String");
    }
  }

  final public INode IRIref() throws ParseException {
    trace_call("IRIref");
    try {
                  /*@bgen(jjtree) IRIref */
                   ASTIRIref jjtn000 = new ASTIRIref(JJTIRIREF);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);INode n;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IRIref:
        case PNAME_LN:
          n = IRI_REF();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  {if (true) return n ;}
          break;
        case PNAME_NS:
          n = PrefixedName();
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                       {if (true) return n ;}
          break;
        default:
          jj_la1[91] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("IRIref");
    }
  }

  final public Literal PrefixedName() throws ParseException {
    trace_call("PrefixedName");
    try {
                          /*@bgen(jjtree) PrefixedName */
                           ASTPrefixedName jjtn000 = new ASTPrefixedName(JJTPREFIXEDNAME);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);Token t ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PNAME_LN:
          t = jj_consume_token(PNAME_LN);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new Literal(t.image);}
          break;
        case PNAME_NS:
          t = jj_consume_token(PNAME_NS);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new Literal(t.image);}
          break;
        default:
          jj_la1[92] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PrefixedName");
    }
  }

  final public BlankNode BlankNode() throws ParseException {
    trace_call("BlankNode");
    try {
                         /*@bgen(jjtree) BlankNode */
                          ASTBlankNode jjtn000 = new ASTBlankNode(JJTBLANKNODE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);Token t = null ;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BLANK_NODE_LABEL:
          t = jj_consume_token(BLANK_NODE_LABEL);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new BlankNode(t.image);}
          break;
        case ANON:
          jj_consume_token(ANON);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           {if (true) return createBlankNode() ;}
          break;
        default:
          jj_la1[93] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BlankNode");
    }
  }

  final public IRI IRI_REF() throws ParseException {
    trace_call("IRI_REF");
    try {
                 /*@bgen(jjtree) IRI_REF */
                  ASTIRI_REF jjtn000 = new ASTIRI_REF(JJTIRI_REF);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t ; String formatted = null;
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IRIref:
          t = jj_consume_token(IRIref);
                 formatted = t.image.substring(1, t.image.length() - 1);
          break;
        case PNAME_LN:
          t = jj_consume_token(PNAME_LN);
                                                                                            formatted = t.image;
          break;
        default:
          jj_la1[94] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return new IRI(formatted);}
      } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("IRI_REF");
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_3R_26() {
    if (jj_scan_token(HOUR)) return true;
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_scan_token(MINUTE)) return true;
    return false;
  }

  private boolean jj_3R_24() {
    if (jj_scan_token(S)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_20() {
    if (jj_scan_token(ADVANCE)) return true;
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_23() {
    if (jj_scan_token(MS)) return true;
    return false;
  }

  private boolean jj_3R_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_18() {
    if (jj_scan_token(WINDOW)) return true;
    if (jj_scan_token(RANGE)) return true;
    if (jj_3R_19()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_20()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_19() {
    if (jj_scan_token(INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_21()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_28() {
    if (jj_scan_token(WEEK)) return true;
    return false;
  }

  private boolean jj_3R_21() {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_scan_token(DAY)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SPARQLParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[95];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xe100000,0xe1c0000,0x0,0x0,0x0,0x0,0x0,0x40000,0x80000,0x200000,0x1800000,0x1800000,0x3000,0x3000,0x3000,0x0,0x0,0x0,0x3700,0x3700,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000,0x40000000,0x30000000,0x20000000,0x10000000,0x30000000,0x3000,0x0,0x3000,0x3000,0x3f00,0x0,0x0,0x0,0x3f00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f00,0x3f00,0x0,0x0,0x23700,0x23700,0x0,0x23700,0x0,0x3f00,0x3f00,0x3f00,0x3700,0x3000,0xf00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3700,0x3700,0x0,0x0,0x700,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x700,0x600,0x800,0x500,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x7000,0x7000,0x8200,0x130000,0x800,0x80000,0x0,0x0,0x0,0x0,0x0,0xf8,0xf8,0xf8,0x200,0x1,0x200,0x0,0x0,0x200,0x0,0x200,0x200,0x100,0x200000,0xf8,0x200000,0x1000000,0x1000000,0x200000,0xc0000000,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x6,0x0,0x6,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x7ff000,0x0,0x7ff000,0x7ff000,0xfd800000,0xb00,0xb00,0x0,0xfd800000,0x0,0x0,0x300,0x400,0x7ff000,0x0,0x0,0xfd800000,0xfd800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfd800000,0xfd800000,0xfd800000,0x0,0x0,0xfd800000,0x0,0x0,0x0,0x0,0xe0000000,0xe0000000,0x0,0x0,0xfdfff000,0xfdfff000,0x7ff000,0x0,0x0,0x0,0x0,0xfc000000,0x1c000000,0xe0000000,0x0,0x1800000,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4800,0x0,0x4800,0x4800,0x210787,0x20000,0x20000,0x1000000,0x210787,0x0,0x1000000,0x20000,0x0,0x4800,0x800000,0x14000,0x210787,0x210787,0x1000000,0x400000,0x0,0x0,0x800000,0x0,0x84000,0x294787,0x294787,0x210787,0x0,0x0,0x210787,0x0,0x0,0x7e000000,0x7e000000,0x7,0x7,0x0,0x0,0x4f87,0x4f87,0x0,0x800000,0x800,0x0,0x0,0x7,0x0,0x0,0x7,0x0,0x780,0x0,0x0,0x200000,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4,0x0,0x0,0x18,0x18,0x60,0x60,0x18,0x0,0x0,0x0,0x0,0x100,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[2];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SPARQLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SPARQLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SPARQLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SPARQLParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new SPARQLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SPARQLParser(SPARQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SPARQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[144];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 95; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 144; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 2; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
